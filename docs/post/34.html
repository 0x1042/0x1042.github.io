<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    <script src='https://blog.meekdai.com/Gmeek/plugins/GmeekVercount.js'></script>
    <link rel="icon" href="https://raw.githubusercontent.com/0x1042/0x1042.github.io/master/synthwave_option_4.ico"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="# origin post

> https://x.com/konradgajdus/status/1837196363735482396

- [origin post](#origin-post)
- [process data](#process-data)
  - [读取images](#读取images)
  - [读取labels](#读取labels)
- [定义网络](#定义网络)
  - [结构](#结构)
  - [初始化](#初始化)
- [前向传播](#前向传播)
- [反向传播](#反向传播)
- [训练](#训练)
  - [单个instance单次迭代](#单个instance单次迭代)
  - [batch训练](#batch训练)
- [预测](#预测)
- [验证](#验证)

# process data

> 数据下载地址 https://yann.lecun.com/exdb/mnist/

| 文件                    | 说明       |
| ----------------------- | ---------- |
| `train-images-idx3-ubyte` | 训练集图片 |
| `train-labels-idx1-ubyte` | 训练集标签 |
| `t10k-images-idx3-ubyte`  | 测试集图片 |
| `t10k-labels-idx1-ubyte`  | 测试集标签 |


## 读取images

> 数据格式 

```
[offset] [type]          [value]          [description]
0000     32 bit integer  0x00000803(2051) magic number
0004     32 bit integer  60000            number of images
0008     32 bit integer  28               number of rows
0012     32 bit integer  28               number of columns
0016     unsigned byte   ??               pixel
0017     unsigned byte   ??               pixel
........
xxxx     unsigned byte   ??               pixel
Pixels are organized row-wise. Pixel values are 0 to 255. 0 means background (white), 255 means foreground (black).
```

```c
void read_images(const char *fname, unsigned char **images, int *count) {
	FILE *file = fopen(fname, 'rb');
	if (file == NULL) {
		printf('%s open %s failed.', __FUNCTION__, fname);
		exit(1);
	}

	int magic = 0;
	int rows, cols;
	// magic numx
	fread(&magic, sizeof(int), 1, file);
	// number of images
	fread(count, sizeof(int), 1, file);
	// 转成大端
	*count = __builtin_bswap32(*count);

	// number of rows
	fread(&rows, sizeof(int), 1, file);
	//	number of columns
	fread(&cols, sizeof(int), 1, file);

	rows = __builtin_bswap32(rows);
	cols = __builtin_bswap32(cols);

	printf('%s: %d/%d/%d\n', __FUNCTION__, *count, rows, cols);

	*images = malloc((*count) * IMAGE_SIZE * IMAGE_SIZE);
	fread(*images, sizeof(unsigned char), (*count) * IMAGE_SIZE * IMAGE_SIZE, file);
	fclose(file);
}
```

## 读取labels

> 数据格式

```
[offset] [type]          [value]          [description]
0000     32 bit integer  0x00000801(2049) magic number (MSB first)
0004     32 bit integer  60000            number of items
0008     unsigned byte   ??               label
0009     unsigned byte   ??               label
........
xxxx     unsigned byte   ??               label
The labels values are 0 to 9.
```

```c
void read_labels(const char *fname, unsigned char **labels, int *count) {
	FILE *file = fopen(fname, 'rb');
	if (file == NULL) {
		exit(1);
	}
	printf('open file [%s] success.\n', fname);

	int magic = 0;
	fread(&magic, sizeof(int), 1, file);
	fread(count, sizeof(int), 1, file);
	*count = __builtin_bswap32(*count);

	printf('labels count. %d.\n', *count);

	*labels = malloc(*count);

	fread(*labels, sizeof(unsigned char), *count, file);
	fclose(file);
}
```

# 定义网络 

## 结构 

```c
typedef struct {
	float *weights; // 权重 
	float *biases;  // 偏差
	int input_size;
	int output_size;
} Layer;

typedef struct {
	Layer hidden;
	Layer output;
} Network;
```

## 初始化 

> 神经网络的训练过程本质是对权重参数的更新，那么这个权重的初始值是什么?
> 首先不能是0，因为 $y = wx +b $ 中，如果w = 0，那么所有神经元的输出是相同的 反向传播过程的梯度也是相同的 

**He initialization**

> 思想是将权重初始化为满足一个标准正态分布

```c
void init_layer(Layer *layer, int in_size, int out_size) {
	int n = in_size * out_size;
	float scale = sqrtf(2.0f / in_size);

	layer->input_size = in_size;
	layer->output_size = out_size;
	layer->weights = malloc(n * sizeof(float));
	layer->biases = calloc(out_size, sizeof(float));

	for (int i = 0; i < n; i++)
		layer->weights[i] = ((float)rand() / RAND_MAX - 0.5f) * 2 * scale;
}
```

# 前向传播

> 即给定输入 计算神经网络输出的过程 
> 步骤: 将输入数据移动到网络的每一层，应用线形变换和激活函数，产生输出

```c
void forward(Layer *layer, float *input, float *output) {
	for (int i = 0; i < layer->output_size; i++) {
		output[i] = layer->biases[i];
		for (int j = 0; j < layer->input_size; j++)
			output[i] += input[j] * layer->weights[j * layer->output_size + i];
	}
}

void relu(float *hidden, int size) {
	for (int i = 0; i < size; i++) {
		hidden[i] = hidden[i] > 0 ? hidden[i] : 0;
	}
}

void softmax(float *input, int size) {
	float max = input[0], sum = 0;
	for (int i = 1; i < size; i++) {
		if (input[i] > max) max = input[i];
	}
	for (int i = 0; i < size; i++) {
		input[i] = expf(input[i] - max);
		sum += input[i];
	}
	for (int i = 0; i < size; i++) {
		input[i] /= sum;
	}
}
```

# 反向传播 

> 根据梯度更新权重和偏差
> 步骤:

```c
void backward(Layer *layer, float *input, float *output_grad, float *input_grad, float lr) {
	for (int i = 0; i < layer->output_size; i++) {
		for (int j = 0; j < layer->input_size; j++) {
			int idx = j * layer->output_size + i;
			// 相对于权重的损失梯度等于相对于输出的损失梯度乘以输入值
			float grad = output_grad[i] * input[j];
			// 新的权重 = 旧的权重 减去 学习率乘以相对于权重的损失梯度
			layer->weights[idx] -= lr * grad;
			//	相对于输入 j 的损失梯度是所有输出的（关于每个输出 i 的损失梯度乘以将输入 j 连接到输出 i 的权重）的总和
			if (input_grad) {
				input_grad[j] += output_grad[i] * layer->weights[idx];
			}
		}

		// 新偏差等于旧偏差减去学习率乘以相对于偏差的损失梯度。">
<meta property="og:title" content="ml 扫盲四">
<meta property="og:description" content="# origin post

> https://x.com/konradgajdus/status/1837196363735482396

- [origin post](#origin-post)
- [process data](#process-data)
  - [读取images](#读取images)
  - [读取labels](#读取labels)
- [定义网络](#定义网络)
  - [结构](#结构)
  - [初始化](#初始化)
- [前向传播](#前向传播)
- [反向传播](#反向传播)
- [训练](#训练)
  - [单个instance单次迭代](#单个instance单次迭代)
  - [batch训练](#batch训练)
- [预测](#预测)
- [验证](#验证)

# process data

> 数据下载地址 https://yann.lecun.com/exdb/mnist/

| 文件                    | 说明       |
| ----------------------- | ---------- |
| `train-images-idx3-ubyte` | 训练集图片 |
| `train-labels-idx1-ubyte` | 训练集标签 |
| `t10k-images-idx3-ubyte`  | 测试集图片 |
| `t10k-labels-idx1-ubyte`  | 测试集标签 |


## 读取images

> 数据格式 

```
[offset] [type]          [value]          [description]
0000     32 bit integer  0x00000803(2051) magic number
0004     32 bit integer  60000            number of images
0008     32 bit integer  28               number of rows
0012     32 bit integer  28               number of columns
0016     unsigned byte   ??               pixel
0017     unsigned byte   ??               pixel
........
xxxx     unsigned byte   ??               pixel
Pixels are organized row-wise. Pixel values are 0 to 255. 0 means background (white), 255 means foreground (black).
```

```c
void read_images(const char *fname, unsigned char **images, int *count) {
	FILE *file = fopen(fname, 'rb');
	if (file == NULL) {
		printf('%s open %s failed.', __FUNCTION__, fname);
		exit(1);
	}

	int magic = 0;
	int rows, cols;
	// magic numx
	fread(&magic, sizeof(int), 1, file);
	// number of images
	fread(count, sizeof(int), 1, file);
	// 转成大端
	*count = __builtin_bswap32(*count);

	// number of rows
	fread(&rows, sizeof(int), 1, file);
	//	number of columns
	fread(&cols, sizeof(int), 1, file);

	rows = __builtin_bswap32(rows);
	cols = __builtin_bswap32(cols);

	printf('%s: %d/%d/%d\n', __FUNCTION__, *count, rows, cols);

	*images = malloc((*count) * IMAGE_SIZE * IMAGE_SIZE);
	fread(*images, sizeof(unsigned char), (*count) * IMAGE_SIZE * IMAGE_SIZE, file);
	fclose(file);
}
```

## 读取labels

> 数据格式

```
[offset] [type]          [value]          [description]
0000     32 bit integer  0x00000801(2049) magic number (MSB first)
0004     32 bit integer  60000            number of items
0008     unsigned byte   ??               label
0009     unsigned byte   ??               label
........
xxxx     unsigned byte   ??               label
The labels values are 0 to 9.
```

```c
void read_labels(const char *fname, unsigned char **labels, int *count) {
	FILE *file = fopen(fname, 'rb');
	if (file == NULL) {
		exit(1);
	}
	printf('open file [%s] success.\n', fname);

	int magic = 0;
	fread(&magic, sizeof(int), 1, file);
	fread(count, sizeof(int), 1, file);
	*count = __builtin_bswap32(*count);

	printf('labels count. %d.\n', *count);

	*labels = malloc(*count);

	fread(*labels, sizeof(unsigned char), *count, file);
	fclose(file);
}
```

# 定义网络 

## 结构 

```c
typedef struct {
	float *weights; // 权重 
	float *biases;  // 偏差
	int input_size;
	int output_size;
} Layer;

typedef struct {
	Layer hidden;
	Layer output;
} Network;
```

## 初始化 

> 神经网络的训练过程本质是对权重参数的更新，那么这个权重的初始值是什么?
> 首先不能是0，因为 $y = wx +b $ 中，如果w = 0，那么所有神经元的输出是相同的 反向传播过程的梯度也是相同的 

**He initialization**

> 思想是将权重初始化为满足一个标准正态分布

```c
void init_layer(Layer *layer, int in_size, int out_size) {
	int n = in_size * out_size;
	float scale = sqrtf(2.0f / in_size);

	layer->input_size = in_size;
	layer->output_size = out_size;
	layer->weights = malloc(n * sizeof(float));
	layer->biases = calloc(out_size, sizeof(float));

	for (int i = 0; i < n; i++)
		layer->weights[i] = ((float)rand() / RAND_MAX - 0.5f) * 2 * scale;
}
```

# 前向传播

> 即给定输入 计算神经网络输出的过程 
> 步骤: 将输入数据移动到网络的每一层，应用线形变换和激活函数，产生输出

```c
void forward(Layer *layer, float *input, float *output) {
	for (int i = 0; i < layer->output_size; i++) {
		output[i] = layer->biases[i];
		for (int j = 0; j < layer->input_size; j++)
			output[i] += input[j] * layer->weights[j * layer->output_size + i];
	}
}

void relu(float *hidden, int size) {
	for (int i = 0; i < size; i++) {
		hidden[i] = hidden[i] > 0 ? hidden[i] : 0;
	}
}

void softmax(float *input, int size) {
	float max = input[0], sum = 0;
	for (int i = 1; i < size; i++) {
		if (input[i] > max) max = input[i];
	}
	for (int i = 0; i < size; i++) {
		input[i] = expf(input[i] - max);
		sum += input[i];
	}
	for (int i = 0; i < size; i++) {
		input[i] /= sum;
	}
}
```

# 反向传播 

> 根据梯度更新权重和偏差
> 步骤:

```c
void backward(Layer *layer, float *input, float *output_grad, float *input_grad, float lr) {
	for (int i = 0; i < layer->output_size; i++) {
		for (int j = 0; j < layer->input_size; j++) {
			int idx = j * layer->output_size + i;
			// 相对于权重的损失梯度等于相对于输出的损失梯度乘以输入值
			float grad = output_grad[i] * input[j];
			// 新的权重 = 旧的权重 减去 学习率乘以相对于权重的损失梯度
			layer->weights[idx] -= lr * grad;
			//	相对于输入 j 的损失梯度是所有输出的（关于每个输出 i 的损失梯度乘以将输入 j 连接到输出 i 的权重）的总和
			if (input_grad) {
				input_grad[j] += output_grad[i] * layer->weights[idx];
			}
		}

		// 新偏差等于旧偏差减去学习率乘以相对于偏差的损失梯度。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://0x1042.github.io//post/34.html">
<meta property="og:image" content="https://raw.githubusercontent.com/0x1042/0x1042.github.io/master/synthwave_option_4.png">
<title>ml 扫盲四</title>
<link href="//unpkg.com/@wooorm/starry-night@2.1.1/style/both.css" rel="stylesheet" />


</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">ml 扫盲四</h1>
<div class="title-right">
    <a href="https://0x1042.github.io/" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/0x1042/0x1042.github.io/issues/34" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><h1>origin post</h1>
<blockquote>
<p><a href="https://x.com/konradgajdus/status/1837196363735482396" rel="nofollow">https://x.com/konradgajdus/status/1837196363735482396</a></p>
</blockquote>
<ul>
<li><a href="#origin-post">origin post</a></li>
<li><a href="#process-data">process data</a>
<ul>
<li><a href="#%E8%AF%BB%E5%8F%96images">读取images</a></li>
<li><a href="#%E8%AF%BB%E5%8F%96labels">读取labels</a></li>
</ul>
</li>
<li><a href="#%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C">定义网络</a>
<ul>
<li><a href="#%E7%BB%93%E6%9E%84">结构</a></li>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</a></li>
</ul>
</li>
<li><a href="#%E5%89%8D%E5%90%91%E4%BC%A0%E6%92%AD">前向传播</a></li>
<li><a href="#%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD">反向传播</a></li>
<li><a href="#%E8%AE%AD%E7%BB%83">训练</a>
<ul>
<li><a href="#%E5%8D%95%E4%B8%AAinstance%E5%8D%95%E6%AC%A1%E8%BF%AD%E4%BB%A3">单个instance单次迭代</a></li>
<li><a href="#batch%E8%AE%AD%E7%BB%83">batch训练</a></li>
</ul>
</li>
<li><a href="#%E9%A2%84%E6%B5%8B">预测</a></li>
<li><a href="#%E9%AA%8C%E8%AF%81">验证</a></li>
</ul>
<h1>process data</h1>
<blockquote>
<p>数据下载地址 <a href="https://yann.lecun.com/exdb/mnist/" rel="nofollow">https://yann.lecun.com/exdb/mnist/</a></p>
</blockquote>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th>文件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code class="notranslate">train-images-idx3-ubyte</code></td>
<td>训练集图片</td>
</tr>
<tr>
<td><code class="notranslate">train-labels-idx1-ubyte</code></td>
<td>训练集标签</td>
</tr>
<tr>
<td><code class="notranslate">t10k-images-idx3-ubyte</code></td>
<td>测试集图片</td>
</tr>
<tr>
<td><code class="notranslate">t10k-labels-idx1-ubyte</code></td>
<td>测试集标签</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<h2>读取images</h2>
<blockquote>
<p>数据格式</p>
</blockquote>
<pre class="notranslate"><code class="notranslate">[offset] [type]          [value]          [description]
0000     32 bit integer  0x00000803(2051) magic number
0004     32 bit integer  60000            number of images
0008     32 bit integer  28               number of rows
0012     32 bit integer  28               number of columns
0016     unsigned byte   ??               pixel
0017     unsigned byte   ??               pixel
........
xxxx     unsigned byte   ??               pixel
Pixels are organized row-wise. Pixel values are 0 to 255. 0 means background (white), 255 means foreground (black).
</code></pre>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-smi">void</span> <span class="pl-en">read_images</span>(<span class="pl-k">const</span> <span class="pl-smi">char</span> <span class="pl-c1">*</span><span class="pl-s1">fname</span>, <span class="pl-smi">unsigned <span class="pl-smi">char</span></span> <span class="pl-c1">*</span><span class="pl-c1">*</span><span class="pl-s1">images</span>, <span class="pl-smi">int</span> <span class="pl-c1">*</span><span class="pl-s1">count</span>) {
	<span class="pl-smi">FILE</span> <span class="pl-c1">*</span><span class="pl-s1">file</span> <span class="pl-c1">=</span> <span class="pl-en">fopen</span>(<span class="pl-s1">fname</span>, <span class="pl-s">"rb"</span>);
	<span class="pl-k">if</span> (<span class="pl-s1">file</span> <span class="pl-c1">==</span> <span class="pl-c1">NULL</span>) {
		<span class="pl-en">printf</span>(<span class="pl-s">"%s open %s failed."</span>, <span class="pl-s1">__FUNCTION__</span>, <span class="pl-s1">fname</span>);
		<span class="pl-en">exit</span>(<span class="pl-c1">1</span>);
	}

	<span class="pl-smi">int</span> <span class="pl-s1">magic</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>;
	<span class="pl-smi">int</span> <span class="pl-s1">rows</span>, <span class="pl-s1">cols</span>;
	<span class="pl-c">// magic numx</span>
	<span class="pl-en">fread</span>(<span class="pl-c1">&amp;</span><span class="pl-s1">magic</span>, <span class="pl-k">sizeof</span>(<span class="pl-smi">int</span>), <span class="pl-c1">1</span>, <span class="pl-s1">file</span>);
	<span class="pl-c">// number of images</span>
	<span class="pl-en">fread</span>(<span class="pl-s1">count</span>, <span class="pl-k">sizeof</span>(<span class="pl-smi">int</span>), <span class="pl-c1">1</span>, <span class="pl-s1">file</span>);
	<span class="pl-c">// 转成大端</span>
	<span class="pl-c1">*</span><span class="pl-s1">count</span> <span class="pl-c1">=</span> <span class="pl-en">__builtin_bswap32</span>(<span class="pl-c1">*</span><span class="pl-s1">count</span>);

	<span class="pl-c">// number of rows</span>
	<span class="pl-en">fread</span>(<span class="pl-c1">&amp;</span><span class="pl-s1">rows</span>, <span class="pl-k">sizeof</span>(<span class="pl-smi">int</span>), <span class="pl-c1">1</span>, <span class="pl-s1">file</span>);
	<span class="pl-c">//	number of columns</span>
	<span class="pl-en">fread</span>(<span class="pl-c1">&amp;</span><span class="pl-s1">cols</span>, <span class="pl-k">sizeof</span>(<span class="pl-smi">int</span>), <span class="pl-c1">1</span>, <span class="pl-s1">file</span>);

	<span class="pl-s1">rows</span> <span class="pl-c1">=</span> <span class="pl-en">__builtin_bswap32</span>(<span class="pl-s1">rows</span>);
	<span class="pl-s1">cols</span> <span class="pl-c1">=</span> <span class="pl-en">__builtin_bswap32</span>(<span class="pl-s1">cols</span>);

	<span class="pl-en">printf</span>(<span class="pl-s">"%s: %d/%d/%d\n"</span>, <span class="pl-s1">__FUNCTION__</span>, <span class="pl-c1">*</span><span class="pl-s1">count</span>, <span class="pl-s1">rows</span>, <span class="pl-s1">cols</span>);

	<span class="pl-c1">*</span><span class="pl-s1">images</span> <span class="pl-c1">=</span> <span class="pl-en">malloc</span>((<span class="pl-c1">*</span><span class="pl-s1">count</span>) <span class="pl-c1">*</span> <span class="pl-c1">IMAGE_SIZE</span> <span class="pl-c1">*</span> <span class="pl-c1">IMAGE_SIZE</span>);
	<span class="pl-en">fread</span>(<span class="pl-c1">*</span><span class="pl-s1">images</span>, <span class="pl-k">sizeof</span>(<span class="pl-smi">unsigned <span class="pl-smi">char</span></span>), (<span class="pl-c1">*</span><span class="pl-s1">count</span>) <span class="pl-c1">*</span> <span class="pl-c1">IMAGE_SIZE</span> <span class="pl-c1">*</span> <span class="pl-c1">IMAGE_SIZE</span>, <span class="pl-s1">file</span>);
	<span class="pl-en">fclose</span>(<span class="pl-s1">file</span>);
}</pre></div>
<h2>读取labels</h2>
<blockquote>
<p>数据格式</p>
</blockquote>
<pre class="notranslate"><code class="notranslate">[offset] [type]          [value]          [description]
0000     32 bit integer  0x00000801(2049) magic number (MSB first)
0004     32 bit integer  60000            number of items
0008     unsigned byte   ??               label
0009     unsigned byte   ??               label
........
xxxx     unsigned byte   ??               label
The labels values are 0 to 9.
</code></pre>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-smi">void</span> <span class="pl-en">read_labels</span>(<span class="pl-k">const</span> <span class="pl-smi">char</span> <span class="pl-c1">*</span><span class="pl-s1">fname</span>, <span class="pl-smi">unsigned <span class="pl-smi">char</span></span> <span class="pl-c1">*</span><span class="pl-c1">*</span><span class="pl-s1">labels</span>, <span class="pl-smi">int</span> <span class="pl-c1">*</span><span class="pl-s1">count</span>) {
	<span class="pl-smi">FILE</span> <span class="pl-c1">*</span><span class="pl-s1">file</span> <span class="pl-c1">=</span> <span class="pl-en">fopen</span>(<span class="pl-s1">fname</span>, <span class="pl-s">"rb"</span>);
	<span class="pl-k">if</span> (<span class="pl-s1">file</span> <span class="pl-c1">==</span> <span class="pl-c1">NULL</span>) {
		<span class="pl-en">exit</span>(<span class="pl-c1">1</span>);
	}
	<span class="pl-en">printf</span>(<span class="pl-s">"open file [%s] success.\n"</span>, <span class="pl-s1">fname</span>);

	<span class="pl-smi">int</span> <span class="pl-s1">magic</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>;
	<span class="pl-en">fread</span>(<span class="pl-c1">&amp;</span><span class="pl-s1">magic</span>, <span class="pl-k">sizeof</span>(<span class="pl-smi">int</span>), <span class="pl-c1">1</span>, <span class="pl-s1">file</span>);
	<span class="pl-en">fread</span>(<span class="pl-s1">count</span>, <span class="pl-k">sizeof</span>(<span class="pl-smi">int</span>), <span class="pl-c1">1</span>, <span class="pl-s1">file</span>);
	<span class="pl-c1">*</span><span class="pl-s1">count</span> <span class="pl-c1">=</span> <span class="pl-en">__builtin_bswap32</span>(<span class="pl-c1">*</span><span class="pl-s1">count</span>);

	<span class="pl-en">printf</span>(<span class="pl-s">"labels count. %d.\n"</span>, <span class="pl-c1">*</span><span class="pl-s1">count</span>);

	<span class="pl-c1">*</span><span class="pl-s1">labels</span> <span class="pl-c1">=</span> <span class="pl-en">malloc</span>(<span class="pl-c1">*</span><span class="pl-s1">count</span>);

	<span class="pl-en">fread</span>(<span class="pl-c1">*</span><span class="pl-s1">labels</span>, <span class="pl-k">sizeof</span>(<span class="pl-smi">unsigned <span class="pl-smi">char</span></span>), <span class="pl-c1">*</span><span class="pl-s1">count</span>, <span class="pl-s1">file</span>);
	<span class="pl-en">fclose</span>(<span class="pl-s1">file</span>);
}</pre></div>
<h1>定义网络</h1>
<h2>结构</h2>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-k">typedef</span> <span class="pl-k">struct</span> {
	<span class="pl-smi">float</span> <span class="pl-c1">*</span><span class="pl-c1">weights</span>; <span class="pl-c">// 权重 </span>
	<span class="pl-smi">float</span> <span class="pl-c1">*</span><span class="pl-c1">biases</span>;  <span class="pl-c">// 偏差</span>
	<span class="pl-smi">int</span> <span class="pl-c1">input_size</span>;
	<span class="pl-smi">int</span> <span class="pl-c1">output_size</span>;
} <span class="pl-smi">Layer</span>;

<span class="pl-k">typedef</span> <span class="pl-k">struct</span> {
	<span class="pl-smi">Layer</span> <span class="pl-c1">hidden</span>;
	<span class="pl-smi">Layer</span> <span class="pl-c1">output</span>;
} <span class="pl-smi">Network</span>;</pre></div>
<h2>初始化</h2>
<blockquote>
<p>神经网络的训练过程本质是对权重参数的更新，那么这个权重的初始值是什么?<br>
首先不能是0，因为 $y = wx +b $ 中，如果w = 0，那么所有神经元的输出是相同的 反向传播过程的梯度也是相同的</p>
</blockquote>
<p><strong>He initialization</strong></p>
<blockquote>
<p>思想是将权重初始化为满足一个标准正态分布</p>
</blockquote>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-smi">void</span> <span class="pl-en">init_layer</span>(<span class="pl-smi">Layer</span> <span class="pl-c1">*</span><span class="pl-s1">layer</span>, <span class="pl-smi">int</span> <span class="pl-s1">in_size</span>, <span class="pl-smi">int</span> <span class="pl-s1">out_size</span>) {
	<span class="pl-smi">int</span> <span class="pl-s1">n</span> <span class="pl-c1">=</span> <span class="pl-s1">in_size</span> <span class="pl-c1">*</span> <span class="pl-s1">out_size</span>;
	<span class="pl-smi">float</span> <span class="pl-s1">scale</span> <span class="pl-c1">=</span> <span class="pl-en">sqrtf</span>(<span class="pl-c1">2.0f</span> / <span class="pl-s1">in_size</span>);

	<span class="pl-s1">layer</span><span class="pl-c1">-&gt;</span><span class="pl-c1">input_size</span> <span class="pl-c1">=</span> <span class="pl-s1">in_size</span>;
	<span class="pl-s1">layer</span><span class="pl-c1">-&gt;</span><span class="pl-c1">output_size</span> <span class="pl-c1">=</span> <span class="pl-s1">out_size</span>;
	<span class="pl-s1">layer</span><span class="pl-c1">-&gt;</span><span class="pl-c1">weights</span> <span class="pl-c1">=</span> <span class="pl-en">malloc</span>(<span class="pl-s1">n</span> <span class="pl-c1">*</span> <span class="pl-k">sizeof</span>(<span class="pl-smi">float</span>));
	<span class="pl-s1">layer</span><span class="pl-c1">-&gt;</span><span class="pl-c1">biases</span> <span class="pl-c1">=</span> <span class="pl-en">calloc</span>(<span class="pl-s1">out_size</span>, <span class="pl-k">sizeof</span>(<span class="pl-smi">float</span>));

	<span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>; <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-s1">n</span>; <span class="pl-s1">i</span><span class="pl-c1">++</span>)
		<span class="pl-s1">layer</span><span class="pl-c1">-&gt;</span><span class="pl-c1">weights</span>[<span class="pl-s1">i</span>] <span class="pl-c1">=</span> ((<span class="pl-smi">float</span>)<span class="pl-en">rand</span>() / <span class="pl-c1">RAND_MAX</span> <span class="pl-c1">-</span> <span class="pl-c1">0.5f</span>) <span class="pl-c1">*</span> <span class="pl-c1">2</span> <span class="pl-c1">*</span> <span class="pl-s1">scale</span>;
}</pre></div>
<h1>前向传播</h1>
<blockquote>
<p>即给定输入 计算神经网络输出的过程<br>
步骤: 将输入数据移动到网络的每一层，应用线形变换和激活函数，产生输出</p>
</blockquote>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-smi">void</span> <span class="pl-en">forward</span>(<span class="pl-smi">Layer</span> <span class="pl-c1">*</span><span class="pl-s1">layer</span>, <span class="pl-smi">float</span> <span class="pl-c1">*</span><span class="pl-s1">input</span>, <span class="pl-smi">float</span> <span class="pl-c1">*</span><span class="pl-s1">output</span>) {
	<span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>; <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-s1">layer</span><span class="pl-c1">-&gt;</span><span class="pl-c1">output_size</span>; <span class="pl-s1">i</span><span class="pl-c1">++</span>) {
		<span class="pl-s1">output</span>[<span class="pl-s1">i</span>] <span class="pl-c1">=</span> <span class="pl-s1">layer</span><span class="pl-c1">-&gt;</span><span class="pl-c1">biases</span>[<span class="pl-s1">i</span>];
		<span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">j</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>; <span class="pl-s1">j</span> <span class="pl-c1">&lt;</span> <span class="pl-s1">layer</span><span class="pl-c1">-&gt;</span><span class="pl-c1">input_size</span>; <span class="pl-s1">j</span><span class="pl-c1">++</span>)
			<span class="pl-s1">output</span>[<span class="pl-s1">i</span>] <span class="pl-c1">+=</span> <span class="pl-s1">input</span>[<span class="pl-s1">j</span>] <span class="pl-c1">*</span> <span class="pl-s1">layer</span><span class="pl-c1">-&gt;</span><span class="pl-c1">weights</span>[<span class="pl-s1">j</span> <span class="pl-c1">*</span> <span class="pl-s1">layer</span><span class="pl-c1">-&gt;</span><span class="pl-c1">output_size</span> <span class="pl-c1">+</span> <span class="pl-s1">i</span>];
	}
}

<span class="pl-smi">void</span> <span class="pl-en">relu</span>(<span class="pl-smi">float</span> <span class="pl-c1">*</span><span class="pl-s1">hidden</span>, <span class="pl-smi">int</span> <span class="pl-s1">size</span>) {
	<span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>; <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-s1">size</span>; <span class="pl-s1">i</span><span class="pl-c1">++</span>) {
		<span class="pl-s1">hidden</span>[<span class="pl-s1">i</span>] <span class="pl-c1">=</span> <span class="pl-s1">hidden</span>[<span class="pl-s1">i</span>] <span class="pl-c1">&gt;</span> <span class="pl-c1">0</span> ? <span class="pl-s1">hidden</span>[<span class="pl-s1">i</span>] : <span class="pl-c1">0</span>;
	}
}

<span class="pl-smi">void</span> <span class="pl-en">softmax</span>(<span class="pl-smi">float</span> <span class="pl-c1">*</span><span class="pl-s1">input</span>, <span class="pl-smi">int</span> <span class="pl-s1">size</span>) {
	<span class="pl-smi">float</span> <span class="pl-s1">max</span> <span class="pl-c1">=</span> <span class="pl-s1">input</span>[<span class="pl-c1">0</span>], <span class="pl-s1">sum</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>;
	<span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> <span class="pl-c1">=</span> <span class="pl-c1">1</span>; <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-s1">size</span>; <span class="pl-s1">i</span><span class="pl-c1">++</span>) {
		<span class="pl-k">if</span> (<span class="pl-s1">input</span>[<span class="pl-s1">i</span>] <span class="pl-c1">&gt;</span> <span class="pl-s1">max</span>) <span class="pl-s1">max</span> <span class="pl-c1">=</span> <span class="pl-s1">input</span>[<span class="pl-s1">i</span>];
	}
	<span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>; <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-s1">size</span>; <span class="pl-s1">i</span><span class="pl-c1">++</span>) {
		<span class="pl-s1">input</span>[<span class="pl-s1">i</span>] <span class="pl-c1">=</span> <span class="pl-en">expf</span>(<span class="pl-s1">input</span>[<span class="pl-s1">i</span>] <span class="pl-c1">-</span> <span class="pl-s1">max</span>);
		<span class="pl-s1">sum</span> <span class="pl-c1">+=</span> <span class="pl-s1">input</span>[<span class="pl-s1">i</span>];
	}
	<span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>; <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-s1">size</span>; <span class="pl-s1">i</span><span class="pl-c1">++</span>) {
		<span class="pl-s1">input</span>[<span class="pl-s1">i</span>] /= <span class="pl-s1">sum</span>;
	}
}</pre></div>
<h1>反向传播</h1>
<blockquote>
<p>根据梯度更新权重和偏差<br>
步骤:</p>
</blockquote>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-smi">void</span> <span class="pl-en">backward</span>(<span class="pl-smi">Layer</span> <span class="pl-c1">*</span><span class="pl-s1">layer</span>, <span class="pl-smi">float</span> <span class="pl-c1">*</span><span class="pl-s1">input</span>, <span class="pl-smi">float</span> <span class="pl-c1">*</span><span class="pl-s1">output_grad</span>, <span class="pl-smi">float</span> <span class="pl-c1">*</span><span class="pl-s1">input_grad</span>, <span class="pl-smi">float</span> <span class="pl-s1">lr</span>) {
	<span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>; <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-s1">layer</span><span class="pl-c1">-&gt;</span><span class="pl-c1">output_size</span>; <span class="pl-s1">i</span><span class="pl-c1">++</span>) {
		<span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">j</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>; <span class="pl-s1">j</span> <span class="pl-c1">&lt;</span> <span class="pl-s1">layer</span><span class="pl-c1">-&gt;</span><span class="pl-c1">input_size</span>; <span class="pl-s1">j</span><span class="pl-c1">++</span>) {
			<span class="pl-smi">int</span> <span class="pl-s1">idx</span> <span class="pl-c1">=</span> <span class="pl-s1">j</span> <span class="pl-c1">*</span> <span class="pl-s1">layer</span><span class="pl-c1">-&gt;</span><span class="pl-c1">output_size</span> <span class="pl-c1">+</span> <span class="pl-s1">i</span>;
			<span class="pl-c">// 相对于权重的损失梯度等于相对于输出的损失梯度乘以输入值</span>
			<span class="pl-smi">float</span> <span class="pl-s1">grad</span> <span class="pl-c1">=</span> <span class="pl-s1">output_grad</span>[<span class="pl-s1">i</span>] <span class="pl-c1">*</span> <span class="pl-s1">input</span>[<span class="pl-s1">j</span>];
			<span class="pl-c">// 新的权重 = 旧的权重 减去 学习率乘以相对于权重的损失梯度</span>
			<span class="pl-s1">layer</span><span class="pl-c1">-&gt;</span><span class="pl-c1">weights</span>[<span class="pl-s1">idx</span>] <span class="pl-c1">-=</span> <span class="pl-s1">lr</span> <span class="pl-c1">*</span> <span class="pl-s1">grad</span>;
			<span class="pl-c">//	相对于输入 j 的损失梯度是所有输出的（关于每个输出 i 的损失梯度乘以将输入 j 连接到输出 i 的权重）的总和</span>
			<span class="pl-k">if</span> (<span class="pl-s1">input_grad</span>) {
				<span class="pl-s1">input_grad</span>[<span class="pl-s1">j</span>] <span class="pl-c1">+=</span> <span class="pl-s1">output_grad</span>[<span class="pl-s1">i</span>] <span class="pl-c1">*</span> <span class="pl-s1">layer</span><span class="pl-c1">-&gt;</span><span class="pl-c1">weights</span>[<span class="pl-s1">idx</span>];
			}
		}

		<span class="pl-c">// 新偏差等于旧偏差减去学习率乘以相对于偏差的损失梯度。</span>
		<span class="pl-s1">layer</span><span class="pl-c1">-&gt;</span><span class="pl-c1">biases</span>[<span class="pl-s1">i</span>] <span class="pl-c1">-=</span> <span class="pl-s1">lr</span> <span class="pl-c1">*</span> <span class="pl-s1">output_grad</span>[<span class="pl-s1">i</span>];
	}
}</pre></div>
<h1>训练</h1>
<h2>单个instance单次迭代</h2>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-c">/**</span>
<span class="pl-c"> * @brief 对单个instance 的训练(单张图片)</span>
<span class="pl-c"> */</span>
<span class="pl-smi">void</span> <span class="pl-en">train</span>(<span class="pl-smi">Network</span> <span class="pl-c1">*</span><span class="pl-s1">net</span>, <span class="pl-smi">float</span> <span class="pl-c1">*</span><span class="pl-s1">input</span>, <span class="pl-smi">int</span> <span class="pl-s1">label</span>, <span class="pl-smi">float</span> <span class="pl-s1">lr</span>) {
	<span class="pl-smi">float</span> <span class="pl-s1">hidden_output</span>[<span class="pl-c1">HIDDEN_SIZE</span>], <span class="pl-s1">final_output</span>[<span class="pl-c1">OUTPUT_SIZE</span>];
	<span class="pl-smi">float</span> <span class="pl-s1">output_grad</span>[<span class="pl-c1">OUTPUT_SIZE</span>] <span class="pl-c1">=</span> {<span class="pl-c1">0</span>}, <span class="pl-s1">hidden_grad</span>[<span class="pl-c1">HIDDEN_SIZE</span>] <span class="pl-c1">=</span> {<span class="pl-c1">0</span>};

    <span class="pl-c">// 前向传播，将输入的图片传入隐藏层</span>
	<span class="pl-en">forward</span>(<span class="pl-c1">&amp;</span><span class="pl-s1">net</span><span class="pl-c1">-&gt;</span><span class="pl-c1">hidden</span>, <span class="pl-s1">input</span>, <span class="pl-s1">hidden_output</span>);
    <span class="pl-en">relu</span>(<span class="pl-s1">hidden_output</span>, <span class="pl-c1">HIDDEN_SIZE</span>);

    <span class="pl-c">// 隐藏层到输出层 </span>
	<span class="pl-en">forward</span>(<span class="pl-c1">&amp;</span><span class="pl-s1">net</span><span class="pl-c1">-&gt;</span><span class="pl-c1">output</span>, <span class="pl-s1">hidden_output</span>, <span class="pl-s1">final_output</span>);
	<span class="pl-en">softmax</span>(<span class="pl-s1">final_output</span>, <span class="pl-c1">OUTPUT_SIZE</span>);

	<span class="pl-c">// 损失函数</span>
    <span class="pl-c">// 计算输出梯度</span>
	<span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>; <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-c1">OUTPUT_SIZE</span>; <span class="pl-s1">i</span><span class="pl-c1">++</span>)
		<span class="pl-s1">output_grad</span>[<span class="pl-s1">i</span>] <span class="pl-c1">=</span> <span class="pl-s1">final_output</span>[<span class="pl-s1">i</span>] <span class="pl-c1">-</span> (<span class="pl-s1">i</span> <span class="pl-c1">==</span> <span class="pl-s1">label</span>);

    <span class="pl-c">// 反向传播，输出层到隐藏层 </span>
	<span class="pl-en">backward</span>(<span class="pl-c1">&amp;</span><span class="pl-s1">net</span><span class="pl-c1">-&gt;</span><span class="pl-c1">output</span>, <span class="pl-s1">hidden_output</span>, <span class="pl-s1">output_grad</span>, <span class="pl-s1">hidden_grad</span>, <span class="pl-s1">lr</span>);

	<span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>; <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-c1">HIDDEN_SIZE</span>; <span class="pl-s1">i</span><span class="pl-c1">++</span>)
		<span class="pl-s1">hidden_grad</span>[<span class="pl-s1">i</span>] *= <span class="pl-s1">hidden_output</span>[<span class="pl-s1">i</span>] <span class="pl-c1">&gt;</span> <span class="pl-c1">0</span> ? <span class="pl-c1">1</span> : <span class="pl-c1">0</span>;<span class="pl-c">// ReLU derivative</span>

    <span class="pl-c">// 反向传播，隐藏层到输入层 </span>
	<span class="pl-en">backward</span>(<span class="pl-c1">&amp;</span><span class="pl-s1">net</span><span class="pl-c1">-&gt;</span><span class="pl-c1">hidden</span>, <span class="pl-s1">input</span>, <span class="pl-s1">hidden_grad</span>, <span class="pl-c1">NULL</span>, <span class="pl-s1">lr</span>);
}</pre></div>
<h2>batch训练</h2>
<div class="highlight highlight-source-c"><pre class="notranslate">	<span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">epoch</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>; <span class="pl-s1">epoch</span> <span class="pl-c1">&lt;</span> <span class="pl-c1">EPOCHS</span>; <span class="pl-s1">epoch</span><span class="pl-c1">++</span>) {
		<span class="pl-smi">float</span> <span class="pl-s1">total_loss</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>;
		<span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>; <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-s1">train_size</span>; <span class="pl-s1">i</span> <span class="pl-c1">+=</span> <span class="pl-c1">BATCH_SIZE</span>) {
			<span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">j</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>; <span class="pl-s1">j</span> <span class="pl-c1">&lt;</span> <span class="pl-c1">BATCH_SIZE</span> <span class="pl-c1">&amp;&amp;</span> <span class="pl-s1">i</span> <span class="pl-c1">+</span> <span class="pl-s1">j</span> <span class="pl-c1">&lt;</span> <span class="pl-s1">train_size</span>; <span class="pl-s1">j</span><span class="pl-c1">++</span>) {
				<span class="pl-smi">int</span> <span class="pl-s1">idx</span> <span class="pl-c1">=</span> <span class="pl-s1">i</span> <span class="pl-c1">+</span> <span class="pl-s1">j</span>;
				<span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">k</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>; <span class="pl-s1">k</span> <span class="pl-c1">&lt;</span> <span class="pl-c1">INPUT_SIZE</span>; <span class="pl-s1">k</span><span class="pl-c1">++</span>)
					<span class="pl-s1">img</span>[<span class="pl-s1">k</span>] <span class="pl-c1">=</span> <span class="pl-s1">data</span>.<span class="pl-c1">images</span>[<span class="pl-s1">idx</span> <span class="pl-c1">*</span> <span class="pl-c1">INPUT_SIZE</span> <span class="pl-c1">+</span> <span class="pl-s1">k</span>] / <span class="pl-c1">255.0f</span>;

				<span class="pl-en">train</span>(<span class="pl-c1">&amp;</span><span class="pl-s1">net</span>, <span class="pl-s1">img</span>, <span class="pl-s1">data</span>.<span class="pl-c1">labels</span>[<span class="pl-s1">idx</span>], <span class="pl-s1">learning_rate</span>);

				<span class="pl-smi">float</span> <span class="pl-s1">hidden_output</span>[<span class="pl-c1">HIDDEN_SIZE</span>], <span class="pl-s1">final_output</span>[<span class="pl-c1">OUTPUT_SIZE</span>];
				<span class="pl-en">forward</span>(<span class="pl-c1">&amp;</span><span class="pl-s1">net</span>.<span class="pl-c1">hidden</span>, <span class="pl-s1">img</span>, <span class="pl-s1">hidden_output</span>);
				<span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">k</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>; <span class="pl-s1">k</span> <span class="pl-c1">&lt;</span> <span class="pl-c1">HIDDEN_SIZE</span>; <span class="pl-s1">k</span><span class="pl-c1">++</span>)
					<span class="pl-s1">hidden_output</span>[<span class="pl-s1">k</span>] <span class="pl-c1">=</span> <span class="pl-s1">hidden_output</span>[<span class="pl-s1">k</span>] <span class="pl-c1">&gt;</span> <span class="pl-c1">0</span> ? <span class="pl-s1">hidden_output</span>[<span class="pl-s1">k</span>] : <span class="pl-c1">0</span>;<span class="pl-c">// ReLU</span>
				<span class="pl-en">forward</span>(<span class="pl-c1">&amp;</span><span class="pl-s1">net</span>.<span class="pl-c1">output</span>, <span class="pl-s1">hidden_output</span>, <span class="pl-s1">final_output</span>);
				<span class="pl-en">softmax</span>(<span class="pl-s1">final_output</span>, <span class="pl-c1">OUTPUT_SIZE</span>);

				<span class="pl-s1">total_loss</span> <span class="pl-c1">+=</span> <span class="pl-c1">-</span><span class="pl-en">logf</span>(<span class="pl-s1">final_output</span>[<span class="pl-s1">data</span>.<span class="pl-c1">labels</span>[<span class="pl-s1">idx</span>]] <span class="pl-c1">+</span> <span class="pl-c1">1e-10f</span>);
			}
		}
	}</pre></div>
<h1>预测</h1>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-smi">int</span> <span class="pl-en">predict</span>(<span class="pl-smi">Network</span> <span class="pl-c1">*</span><span class="pl-s1">net</span>, <span class="pl-smi">float</span> <span class="pl-c1">*</span><span class="pl-s1">input</span>) {
	<span class="pl-smi">float</span> <span class="pl-s1">hidden_output</span>[<span class="pl-c1">HIDDEN_SIZE</span>], <span class="pl-s1">final_output</span>[<span class="pl-c1">OUTPUT_SIZE</span>];

    <span class="pl-c">// 前向传播，将输入的图片传入隐藏层</span>
	<span class="pl-en">forward</span>(<span class="pl-c1">&amp;</span><span class="pl-s1">net</span><span class="pl-c1">-&gt;</span><span class="pl-c1">hidden</span>, <span class="pl-s1">input</span>, <span class="pl-s1">hidden_output</span>);
    <span class="pl-en">relu</span>(<span class="pl-s1">hidden_output</span>, <span class="pl-c1">HIDDEN_SIZE</span>);

    <span class="pl-c">// 隐藏层到输出层 </span>
	<span class="pl-en">forward</span>(<span class="pl-c1">&amp;</span><span class="pl-s1">net</span><span class="pl-c1">-&gt;</span><span class="pl-c1">output</span>, <span class="pl-s1">hidden_output</span>, <span class="pl-s1">final_output</span>);
	<span class="pl-en">softmax</span>(<span class="pl-s1">final_output</span>, <span class="pl-c1">OUTPUT_SIZE</span>);

	<span class="pl-smi">int</span> <span class="pl-s1">max_index</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>;
	<span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> <span class="pl-c1">=</span> <span class="pl-c1">1</span>; <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-c1">OUTPUT_SIZE</span>; <span class="pl-s1">i</span><span class="pl-c1">++</span>)
		<span class="pl-k">if</span> (<span class="pl-s1">final_output</span>[<span class="pl-s1">i</span>] <span class="pl-c1">&gt;</span> <span class="pl-s1">final_output</span>[<span class="pl-s1">max_index</span>])
			<span class="pl-s1">max_index</span> <span class="pl-c1">=</span> <span class="pl-s1">i</span>;

	<span class="pl-k">return</span> <span class="pl-s1">max_index</span>;
}</pre></div>
<h1>验证</h1>
<div class="highlight highlight-source-c"><pre class="notranslate"><span class="pl-k">typedef</span> <span class="pl-k">struct</span> {
	<span class="pl-smi">unsigned <span class="pl-smi">char</span></span> <span class="pl-c1">*</span><span class="pl-c1">images</span>;
	<span class="pl-smi">unsigned <span class="pl-smi">char</span></span> <span class="pl-c1">*</span><span class="pl-c1">labels</span>;
	<span class="pl-smi">int</span> <span class="pl-c1">image_count</span>;
	<span class="pl-smi">int</span> <span class="pl-c1">label_count</span>;
} <span class="pl-smi">InputData</span>;

<span class="pl-c">// 读取测试数据</span>
<span class="pl-smi">InputData</span> <span class="pl-s1">testdata</span> <span class="pl-c1">=</span> {<span class="pl-c1">0</span>};
<span class="pl-en">read_mnist_images</span>(<span class="pl-c1">TEST_IMG_PATH</span>, <span class="pl-c1">&amp;</span><span class="pl-s1">testdata</span>.<span class="pl-c1">images</span>, <span class="pl-c1">&amp;</span><span class="pl-s1">testdata</span>.<span class="pl-c1">nImages</span>);
<span class="pl-en">read_mnist_labels</span>(<span class="pl-c1">TEST_LBL_PATH</span>, <span class="pl-c1">&amp;</span><span class="pl-s1">testdata</span>.<span class="pl-c1">labels</span>, <span class="pl-c1">&amp;</span><span class="pl-s1">testdata</span>.<span class="pl-c1">nImages</span>);

{
	<span class="pl-smi">float</span> <span class="pl-s1">tmp</span>[<span class="pl-c1">INPUT_SIZE</span>];
	<span class="pl-smi">int</span> <span class="pl-s1">corrent</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>;
	<span class="pl-smi">int</span> <span class="pl-s1">total</span> <span class="pl-c1">=</span> <span class="pl-s1">testdata</span>.<span class="pl-c1">nImages</span>;
	<span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">i</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>; <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-s1">testdata</span>.<span class="pl-c1">nImages</span>; <span class="pl-s1">i</span><span class="pl-c1">++</span>) {
		<span class="pl-k">for</span> (<span class="pl-smi">int</span> <span class="pl-s1">k</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>; <span class="pl-s1">k</span> <span class="pl-c1">&lt;</span> <span class="pl-c1">INPUT_SIZE</span>; <span class="pl-s1">k</span><span class="pl-c1">++</span>)
			<span class="pl-s1">tmp</span>[<span class="pl-s1">k</span>] <span class="pl-c1">=</span> <span class="pl-s1">testdata</span>.<span class="pl-c1">images</span>[<span class="pl-s1">i</span> <span class="pl-c1">*</span> <span class="pl-c1">INPUT_SIZE</span> <span class="pl-c1">+</span> <span class="pl-s1">k</span>] / <span class="pl-c1">255.0f</span>;
		<span class="pl-smi">int</span> <span class="pl-s1">pre</span> <span class="pl-c1">=</span> <span class="pl-en">predict</span>(<span class="pl-c1">&amp;</span><span class="pl-s1">net</span>, <span class="pl-s1">tmp</span>);
		<span class="pl-smi">int</span> <span class="pl-s1">post</span> <span class="pl-c1">=</span> <span class="pl-s1">testdata</span>.<span class="pl-c1">labels</span>[<span class="pl-s1">i</span>];
		<span class="pl-s1">corrent</span> <span class="pl-c1">+=</span> (<span class="pl-s1">pre</span> <span class="pl-c1">==</span> <span class="pl-s1">post</span>);
	}
	<span class="pl-en">printf</span>(<span class="pl-s">"rate %.4f\n"</span>, (<span class="pl-smi">float</span>) <span class="pl-s1">corrent</span> / (<span class="pl-smi">float</span>) <span class="pl-s1">total</span>);
}</pre></div>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/user-attachments/assets/34eb1ea4-d2b1-475a-896b-cf5b64c109bd"><img width="754" alt="image" src="https://github.com/user-attachments/assets/34eb1ea4-d2b1-475a-896b-cf5b64c109bd" style="max-width: 100%;"></a></p></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://0x1042.github.io/">Daily</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if("10/25/2023"!=""){
    var startSite=new Date("10/25/2023");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek main https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.disabled=true;
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","0x1042/0x1042.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>
<script src='https://blog.meekdai.com/Gmeek/plugins/GmeekTOC.js'></script><script src='https://blog.meekdai.com/Gmeek/plugins/lightbox.js'></script>

</html>
