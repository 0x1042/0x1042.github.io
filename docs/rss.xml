<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Daily</title><link>http://0x1042.github.io</link><description>我自倾怀，君且随意。</description><copyright>Daily</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://raw.githubusercontent.com/0x1042/0x1042.github.io/master/synthwave_option_4.png</url><title>avatar</title><link>http://0x1042.github.io</link></image><lastBuildDate>Sat, 11 Nov 2023 14:47:34 +0000</lastBuildDate><managingEditor>Daily</managingEditor><pubDate>Sat, 11 Nov 2023 14:47:34 +0000</pubDate><ttl>60</ttl><webMaster>Daily</webMaster><item><title>一、c++中的值类型</title><link>http://0x1042.github.io/post/yi-%E3%80%81c%2B%2B-zhong-de-zhi-lei-xing.html</link><description># 值类别 &#13;
&#13;
- [值类别](#值类别)&#13;
  - [如何区分左值和右值](#如何区分左值和右值)&#13;
  - [函数参数匹配](#函数参数匹配)&#13;
  - [值类型](#值类型)&#13;
  - [万能引用 **universal reference**](#万能引用-universal-reference)&#13;
  - [引用折叠 **reference collapsing**](#引用折叠-reference-collapsing)&#13;
  - [完美转发 **perfect forward**](#完美转发-perfect-forward)&#13;
&#13;
## 如何区分左值和右值&#13;
&#13;
```c++&#13;
void log(std::string_view message, std::source_location location) {&#13;
    std::clog &lt;&lt; "file: " &lt;&lt; location.file_name() &lt;&lt; '(' &lt;&lt; location.line() &lt;&lt; ':' &lt;&lt; location.column() &lt;&lt; ") `" &lt;&lt; location.function_name()&#13;
              &lt;&lt; "`: " &lt;&lt; message &lt;&lt; '\n';&#13;
}&#13;
&#13;
void foo(int &amp; /*val*/) {&#13;
    log("foo1");&#13;
}&#13;
&#13;
void foo(int &amp;&amp; /*val*/) {&#13;
    log("foo2");&#13;
}&#13;
```&#13;
&#13;
```cpp&#13;
int &amp;&amp; value = 1024;&#13;
foo(value); // 调用的是 void foo(int &amp;)&#13;
```&#13;
&#13;
- 匿名的临时对象是右值，具名的右值引用对象是左值 &#13;
- 如果表达式可以取地址，则为左值表达式，否则，为右值表达式&#13;
- 表达式 value 是具名的右值引用对象，value 也可以取地址，所以 表达式value 是一个左值，匹配第一个函数&#13;
&#13;
## 函数参数匹配&#13;
&#13;
| 参数类型      | 说明                                     |&#13;
| ------------- | ---------------------------------------- |&#13;
| Value&amp;        | 只能匹配左值表达式                       |&#13;
| Value&amp;&amp;       | 只能绑定右值表达式（模板函数下单独讨论） |&#13;
| const Value&amp;  | 可以匹配左值和右值表达式                 |&#13;
| const Value&amp;&amp; | 实际不使用                               |&#13;
&#13;
&#13;
## 值类型 &#13;
&#13;
- 泛左值： 左值 和 将亡值&#13;
- 右值：纯右值 和 将亡值&#13;
- `static_cast&lt;Value&amp;&amp;&gt;(value)` 是将亡值，常见的将亡值是 函数的返回值 &#13;
![types](https://github.com/0x1042/0x1042.github.io/assets/7525242/0fae6f7f-bce8-41b6-ad2d-45cc312ec7b4)&#13;
&#13;
&#13;
## 万能引用 **universal reference** &#13;
&#13;
&gt; 如何区分 Arg&amp;&amp; 是右值引用还是万能引用？&#13;
&#13;
- **如果 Arg&amp;&amp; 是模板参数或者 auto，则是万能引用，「既可以接受左值，也可以接受右值」，否则为右值引用**&#13;
- **万能引用在类型推导语境下，可以保留类型的cv限定符「const和volatile」和值类别**&#13;
&#13;
## 引用折叠 **reference collapsing**&#13;
&#13;
&gt; 为了解决 reference to reference 的问题&#13;
&#13;
c++ 中不允许指向引用的引用，对于指向引用的引用会被简化，推导规则如下 &#13;
&#13;
```cpp&#13;
template &lt;typename T&gt;&#13;
void Example(T &amp;&amp; input) {}&#13;
```&#13;
&#13;
- 函数形参是左值，T&amp;，传入的实参是左值，即input 是 `T&amp; &amp;`&#13;
- 函数形参是左值，T&amp;，传入的实参是右值，即input 是 `T&amp; &amp;&amp;`&#13;
- 函数形参是右值，T&amp;&amp;，传入的实参是左值，即input 是 `T&amp;&amp; &amp;`&#13;
- 函数形参是右值，T&amp;&amp;，传入的实参是右值，即input 是 `T&amp;&amp; &amp;&amp;`&#13;
&#13;
推导规则是： **仅当两个都是右值引用时，推导为右值，其余情况为左值**，也就是 `T&amp;&amp; &amp;&amp;`为右值，其他情况为左值 &#13;
&#13;
&#13;
## 完美转发 **perfect forward** &#13;
&#13;
&gt; 在传参的过程中，保留参数的原始类型 &#13;
&#13;
```cpp&#13;
void foo(int &amp; val);&#13;
void foo(int &amp;&amp; val);&#13;
&#13;
template &lt;typename T&gt; void call_foo(T &amp;&amp; t) {&#13;
    foo(std::forward&lt;T&gt;(t));&#13;
}&#13;
```&#13;
&#13;
如何实现的？&#13;
&#13;
```cpp&#13;
template &lt;class _Tp&gt;&#13;
_LIBCPP_NODISCARD_EXT inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR _Tp&amp;&amp;&#13;
forward(_LIBCPP_LIFETIMEBOUND __libcpp_remove_reference_t&lt;_Tp&gt;&amp; __t) _NOEXCEPT {&#13;
  return static_cast&lt;_Tp&amp;&amp;&gt;(__t);&#13;
}&#13;
&#13;
template &lt;class _Tp&gt;&#13;
_LIBCPP_NODISCARD_EXT inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR _Tp&amp;&amp;&#13;
forward(_LIBCPP_LIFETIMEBOUND __libcpp_remove_reference_t&lt;_Tp&gt;&amp;&amp; __t) _NOEXCEPT {&#13;
  static_assert(!is_lvalue_reference&lt;_Tp&gt;::value, "cannot forward an rvalue as an lvalue");&#13;
  return static_cast&lt;_Tp&amp;&amp;&gt;(__t);&#13;
}&#13;
```&#13;
&#13;
- Tp 是左值， `static_cast&lt;_Tp&amp;&amp;&gt;(__t)` 后是 T&amp; &amp;&amp;，按照引用折叠规则，`T&amp; &amp;&amp; -&gt; T&amp;`, Tp是左值 &#13;
- Tp 是右值， `static_cast&lt;_Tp&amp;&amp;&gt;(__t)` 后是 T&amp;&amp; &amp;&amp;，按照引用折叠规则，`T&amp;&amp; &amp;&amp; -&gt; T&amp;&amp;`, Tp是右值 。</description><guid isPermaLink="true">http://0x1042.github.io/post/yi-%E3%80%81c%2B%2B-zhong-de-zhi-lei-xing.html</guid><pubDate>Sat, 11 Nov 2023 08:48:15 +0000</pubDate></item><item><title>struct 使用生命周期标注</title><link>http://0x1042.github.io/post/struct%20-shi-yong-sheng-ming-zhou-qi-biao-zhu.html</link><description>```rust&#13;
#[derive(Debug)]&#13;
struct Sheep&lt;'c, 'd&gt; {&#13;
    age: &amp;'c u32,&#13;
    name: &amp;'d str,&#13;
}&#13;
&#13;
impl&lt;'c, 'd&gt; Sheep&lt;'c, 'd&gt; {&#13;
    /// Returns the get age of this [`Sheep`].&#13;
    pub fn get_age(&amp;self) -&gt; u32 {&#13;
        *self.age&#13;
    }&#13;
&#13;
    /// Returns the get name of this [`Sheep`].&#13;
    pub fn get_name(&amp;self) -&gt; String {&#13;
        self.name.to_owned()&#13;
    }&#13;
}&#13;
&#13;
#[cfg(test)]&#13;
mod tests {&#13;
    use super::Sheep;&#13;
    #[test]&#13;
    fn test_lt() {&#13;
        let age = 5;&#13;
        let name = "dollor";&#13;
&#13;
        let sheep = Sheep {&#13;
            age: &amp;age,&#13;
            name: name,&#13;
        };&#13;
&#13;
        println!("name is {:?}", sheep.get_name());&#13;
        println!("age is {:?}", sheep.get_age());&#13;
&#13;
        println!("sheep :{:?}", sheep);&#13;
    }&#13;
}&#13;
```。</description><guid isPermaLink="true">http://0x1042.github.io/post/struct%20-shi-yong-sheng-ming-zhou-qi-biao-zhu.html</guid><pubDate>Wed, 01 Nov 2023 16:55:48 +0000</pubDate></item><item><title>golang中protobuf 反序列化性能优化</title><link>http://0x1042.github.io/post/golang-zhong-protobuf%20-fan-xu-lie-hua-xing-neng-you-hua.html</link><description># 背景&#13;
&#13;
线上有一些公共使用的超大`protobuf`，部分单**message的field大于10000**。</description><guid isPermaLink="true">http://0x1042.github.io/post/golang-zhong-protobuf%20-fan-xu-lie-hua-xing-neng-you-hua.html</guid><pubDate>Sat, 28 Oct 2023 09:07:59 +0000</pubDate></item><item><title>c++中实现golang中的defer功能</title><link>http://0x1042.github.io/post/c%2B%2B-zhong-shi-xian-golang-zhong-de-defer-gong-neng.html</link><description># 使用`folly`&#13;
&#13;
```c++&#13;
#include &lt;folly/ScopeGuard.h&gt;&#13;
&#13;
auto main() -&gt; int {&#13;
    std::string msg = "exit...";&#13;
&#13;
    auto guard1 = folly::makeGuard([&amp;] { std::cerr &lt;&lt; "from folly::makeGuard:" &lt;&lt; msg &lt;&lt; '\n'; });&#13;
&#13;
    std::cout &lt;&lt; "Hello, World!" &lt;&lt; '\n';&#13;
    return 0;&#13;
}&#13;
&#13;
```&#13;
&#13;
# 自定义实现&#13;
&#13;
```c++&#13;
template &lt;typename Lambda&gt; &#13;
struct Defer : Lambda {&#13;
    ~Defer() { Lambda::operator()(); }&#13;
};&#13;
&#13;
template &lt;typename Lambda&gt; &#13;
Defer(Lambda) -&gt; Defer&lt;Lambda&gt;;&#13;
&#13;
auto main() -&gt; int {&#13;
    std::string msg = "exit...";&#13;
&#13;
    Defer guard{[&amp;] { std::cerr &lt;&lt; msg &lt;&lt; '\n'; }};&#13;
&#13;
    std::cout &lt;&lt; "Hello, World!" &lt;&lt; '\n';&#13;
    return 0;&#13;
}&#13;
```&#13;
。</description><guid isPermaLink="true">http://0x1042.github.io/post/c%2B%2B-zhong-shi-xian-golang-zhong-de-defer-gong-neng.html</guid><pubDate>Wed, 25 Oct 2023 15:57:21 +0000</pubDate></item></channel></rss>