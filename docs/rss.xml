<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Daily</title><link>https://0x1042.github.io/</link><description>我自倾怀，君且随意。</description><copyright>Daily</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://raw.githubusercontent.com/0x1042/0x1042.github.io/master/synthwave_option_4.png</url><title>avatar</title><link>https://0x1042.github.io/</link></image><lastBuildDate>Sat, 27 Sep 2025 09:37:53 +0000</lastBuildDate><managingEditor>Daily</managingEditor><ttl>60</ttl><webMaster>Daily</webMaster><item><title>bazel 基本使用</title><link>https://0x1042.github.io//post/54.html</link><description># bazel samples

## `use protobuf`

- `MODULE.bazel`

```bazel{highlight=1 .line-numbers}
bazel_dep(name = 'protobuf', version = '32.1')
bazel_dep(name = 'rules_proto', version = '7.1.0')
```

- `app/BUILD.bazel`

```bazel{highlight=1 .line-numbers}
load('@protobuf//bazel:cc_proto_library.bzl', 'cc_proto_library')
load('@rules_cc//cc:defs.bzl', 'cc_binary', 'cc_library')
load('@rules_proto//proto:defs.bzl', 'proto_library')

proto_library(
    name = 'graph_proto',
    srcs = [
        'idls/graph.proto',
    ],
    visibility = ['//visibility:public'],
)

cc_proto_library(
    name = 'graph_cc_proto',
    visibility = ['//visibility:public'],
    deps = [':graph_proto'],
)
```

## `replace malloc`

```starlark{highlight=1 .line-numbers}
bazel_dep(name = 'mimalloc', version = '2.2.4')

cc_binary(
    name = 'unittest2',
    srcs = [
        'main.cc',
    ],
    copts = DEFAULT_COPTS,
    linkopts = DEFAULT_LINKOPTS,
    malloc = '@mimalloc',
    deps = [
        '@mimalloc//:mimalloc-api'
    ],
)
```

```CPP{highlight=1 .line-numbers}
#include &lt;mimalloc.h&gt;

auto main(int argc, char ** argv) -&gt; int {
    LOG(INFO) &lt;&lt; 'mimalloc version ' &lt;&lt; mi_version();
    return RUN_ALL_TESTS();
}
```
。</description><guid isPermaLink="true">https://0x1042.github.io//post/54.html</guid><pubDate>Sat, 27 Sep 2025 09:37:32 +0000</pubDate></item><item><title>google colab cuda 编程</title><link>https://0x1042.github.io//post/53.html</link><description># 环境搭建 

## 连接到GPU实例

&gt; change runtime type -&gt; GPU

&lt;img width='1098' height='992' alt='Image' src='https://github.com/user-attachments/assets/d4ad2c85-d936-496d-bbe4-fcfef1c7ee2e' /&gt;

## 检查状态 

```python
!nvcc --version
!nvidia-smi
```

```
nvcc: NVIDIA (R) Cuda compiler driver
Copyright (c) 2005-2024 NVIDIA Corporation
Built on Thu_Jun__6_02:18:23_PDT_2024
Cuda compilation tools, release 12.5, V12.5.82
Build cuda_12.5.r12.5/compiler.34385749_0
Sun Sep 21 07:02:16 2025       
+-----------------------------------------------------------------------------------------+
| NVIDIA-SMI 550.54.15              Driver Version: 550.54.15      CUDA Version: 12.4     |
|-----------------------------------------+------------------------+----------------------+
| GPU  Name                 Persistence-M | Bus-Id          Disp.A | Volatile Uncorr. ECC |
| Fan  Temp   Perf          Pwr:Usage/Cap |           Memory-Usage | GPU-Util  Compute M. |
|                                         |                        |               MIG M. |
|=========================================+========================+======================|
|   0  Tesla T4                       Off |   00000000:00:04.0 Off |                    0 |
| N/A   60C    P8             10W /   70W |       0MiB /  15360MiB |      0%      Default |
|                                         |                        |                  N/A |
+-----------------------------------------+------------------------+----------------------+
                                                                                         
+-----------------------------------------------------------------------------------------+
| Processes:                                                                              |
|  GPU   GI   CI        PID   Type   Process name                              GPU Memory |
|        ID   ID                                                               Usage      |
|=========================================================================================|
|  No running processes found                                                             |
+-----------------------------------------------------------------------------------------+
```

## 安装插件 

```python
!pip install nvcc4jupyter
%load_ext nvcc4jupyter
```

## 修复版本 

from [learning-cuda-on-a-budget-on-google](https://leetarxiv.substack.com/p/learning-cuda-on-a-budget-on-google)

```
%%cuda -c '-I /does/not/exist -arch sm_75'
```

# hello world

```cuda
%%cuda -c '-I /does/not/exist -arch sm_75'
#include &lt;stdio.h&gt;

// This is a special function that runs on the GPU (device) instead of the CPU (host)
__global__ void kernel() {
  printf('Hello world!\n');
}

int main() {
  // Invoke the kernel function on the GPU with one block of one thread
  kernel&lt;&lt;&lt;1,1&gt;&gt;&gt;();

  // Check for error codes (remember to do this for _every_ CUDA function)
  if(cudaDeviceSynchronize() != cudaSuccess) {
    fprintf(stderr, 'CUDA Error: %s\n', cudaGetErrorString(cudaPeekAtLastError()));
  }
  return 0;
}
```

&lt;img width='2190' height='962' alt='Image' src='https://github.com/user-attachments/assets/7e5977be-514c-46df-a8fc-98587725b3d5' /&gt;


# 基本术语


## 函数修饰符

| 修饰符                | 含义                                    | 备注                                                     |
| --------------------- | --------------------------------------- | -------------------------------------------------------- |
| `__global__`          | 标记核函数                              | 在`host`(CPU) 端调用，由`device`（GPU）端执行            |
| `__device__`          | 标记设备函数                            | 只能在 GPU 上调用和执行，不能从 CPU 端直接调用           |
| `__host__`            | 标记主机函数，在CPU上执行（默认修饰符） | 只能在 CPU 上调用和执行（实际上 C++ 普通函数默认就host） |
| `__host__ __device__` |                                         | 可以同时在CPU和GPU上编译执行                             |

## 变量修饰符

| 修饰符         | 含义                                |
| -------------- | ----------------------------------- |
| `__shared__`   | 声明共享内存变量，`block`内线程共享 |
| `__constant__` | 声明常量内存变量，只读且有缓存      |
| `__device__`   | 声明全局设备变量                    |


## 执行模型

| 概念     | 含义                                                                         |
| -------- | ---------------------------------------------------------------------------- |
| `Kernel` | 在GPU上并行执行的函数，类似于CPU的函数但会被数千个线程同时执行               |
| `Grid`   | block 的集合，一个 kernel 启动时会指定一个 grid，grid 内包含多个 block       |
| `Block`  | 线程的集合，一个 kernel 的执行可以分为多个 block，每个 block 内有多个 thread |
| `Thread` | GPU 的最小执行单元，每个 kernel 启动后会并行运行许多线程                     |


## 内存层级 

## 内置变量 


| 概念              | 含义                    |
| ----------------- | ----------------------- |
| `threadIdx.x/y/z` | 当前线程在block中的索引 |
| `blockIdx.x/y/z`  | 当前block在grid中的索引 |
| `blockDim.x/y/z`  | block的维度大小         |
| `gridDim.x/y/z`   | grid的维度大小          |



# 语法

```
&lt;&lt;&lt;Dg, Db, Ns, S&gt;&gt;&gt;(args)
- Dg. Grid维度 
- Db. Block维度
- Ns. 动态共享内存大小
- S. Stream，用于异步执行
```。</description><guid isPermaLink="true">https://0x1042.github.io//post/53.html</guid><pubDate>Sun, 21 Sep 2025 07:15:22 +0000</pubDate></item><item><title>async</title><link>https://0x1042.github.io//post/52.html</link><description># 异步

## 线程

同步的实现

```C++
auto get(const std::string &amp;url) -&gt; std::string {
  ScopedTimer timer(__PRETTY_FUNCTION__);
  cpr::Response rsp = cpr::Get(cpr::Url{url});
  return rsp.text;
}
```

### `std::async`

```C++
auto get_async(const std::string &amp;url) -&gt; std::future&lt;std::string&gt; {
  return std::async(std::launch::async, get, url);
}

TEST(get, get2) {
  const std::string url = 'https://www.bilibili.com';
  auto &amp;&amp;rsp = get_async(url);
  LOG(INFO) &lt;&lt; 'get async start ';
  const auto &amp;content = rsp.get();
  LOG(INFO) &lt;&lt; 'content is ' &lt;&lt; content;
}
```

### `std::packaged_task`

&gt; [!Tip]
&gt; &lt;ins&gt;**1. packaged_task 参数是一个无参的可调用对象**&lt;/ins&gt;
&gt; &lt;ins&gt;**2. 在任务被执行前，先获取它的 future**&lt;/ins&gt;
&gt; &lt;ins&gt;**3. 将任务提交到线程池**&lt;/ins&gt;

```c++
auto get_async2(const std::string &amp;url) -&gt; std::future&lt;std::string&gt; {
  auto fn = [url]() { return get(url); };

  std::packaged_task&lt;std::string()&gt; task(std::move(fn));
  std::future&lt;std::string&gt; future = task.get_future();
  thread_pool()-&gt;add([t = std::move(task)]() mutable { t(); });

  return future;
}
```

### `folly::via`

```C++
auto get_async3(const std::string &amp;url) -&gt; folly::Future&lt;std::string&gt; {
  return folly::via(thread_pool().get(), [url]() { return get(url); });
}
```

## 协程

&gt; todo。</description><guid isPermaLink="true">https://0x1042.github.io//post/52.html</guid><pubDate>Sat, 14 Jun 2025 06:48:12 +0000</pubDate></item><item><title>iterator</title><link>https://0x1042.github.io//post/51.html</link><description># 迭代器

## 原理

&lt;ins&gt;**当编译器看到 `for (auto&amp; element : container)` 时，它会大致将其转换为如下的等价代码:**&lt;/ins&gt;

```C++
auto&amp;&amp; __range = container; // 获取容器引用
auto __begin = std::begin(__range); // 获取起始迭代器
auto __end = std::end(__range);     // 获取结束迭代器
for (; __begin != __end; ++__begin) { // 循环直到结束
    auto&amp; element = *__begin;        // 解引用迭代器获取元素
    // ... 循环体 ...
}
```

## 分类 

```mermaid
graph LR
    A[type] --&gt; B[容器的封装类型]
    A[type] --&gt; C[variant]
    A[type] --&gt; D[普通类型]
```

## 容器的封装类型

&gt; [!IMPORTANT]
&gt; &lt;ins&gt;**实现`begin/end` 等函数即可**&lt;/ins&gt;


```c++
class VecWrap {
public:
    VecWrap(std::initializer_list&lt;int64_t&gt; list)
        : data_(list) {}

    auto begin() -&gt; std::vector&lt;int64_t&gt;::iterator { return data_.begin(); }

    auto end() -&gt; std::vector&lt;int64_t&gt;::iterator { return data_.end(); }

    [[nodiscard]] auto begin() const -&gt; std::vector&lt;int64_t&gt;::const_iterator { return data_.begin(); }

    [[nodiscard]] auto end() const -&gt; std::vector&lt;int64_t&gt;::const_iterator { return data_.end(); }

    [[nodiscard]] auto size() const -&gt; size_t { return data_.size(); }

    [[nodiscard]] auto empty() const -&gt; bool { return data_.empty(); }

private:
    std::vector&lt;int64_t&gt; data_;
};
```

## `variant`

```C++
struct Items {
    using ItemVec = std::variant&lt;
        std::monostate,
        std::vector&lt;Item1Ptr&gt;,
        std::vector&lt;Item2Ptr&gt;,
        std::vector&lt;Item3Ptr&gt;,
        std::vector&lt;Item4Ptr&gt;&gt;;

    ItemVec vec_;
};

void Items::range() {
    std::visit(
        [&amp;](const auto&amp; vec) {
            using VectorType = std::decay_t&lt;decltype(vec)&gt;;

            if constexpr (std::is_same_v&lt;std::vector&lt;Item1Ptr&gt;, VectorType&gt;)
            {
                LOG(INFO) &lt;&lt; 'Content of vector&lt;A&gt;:' &lt;&lt; std::endl;
                for (const Item1Ptr&amp; item : vec)
                {
                    LOG(INFO) &lt;&lt; 'is a. ' &lt;&lt; item-&gt;ida &lt;&lt; ' ' &lt;&lt; item-&gt;namea;
                }
            } else if constexpr (std::is_same_v&lt;std::vector&lt;Item2Ptr&gt;, VectorType&gt;)
            {
                LOG(INFO) &lt;&lt; 'Content of vector&lt;A&gt;:' &lt;&lt; std::endl;
                for (const Item2Ptr&amp; item : vec)
                {
                    LOG(INFO) &lt;&lt; 'is b. ' &lt;&lt; item-&gt;idb &lt;&lt; ' ' &lt;&lt; item-&gt;nameb;
                }
            } else if constexpr (std::is_same_v&lt;std::vector&lt;Item3Ptr&gt;, VectorType&gt;)
            {
                LOG(INFO) &lt;&lt; 'Content of vector&lt;A&gt;:' &lt;&lt; std::endl;
                for (const Item3Ptr&amp; item : vec)
                {
                    LOG(INFO) &lt;&lt; 'is c. ' &lt;&lt; item-&gt;idc &lt;&lt; ' ' &lt;&lt; item-&gt;namec;
                }
            } else if constexpr (std::is_same_v&lt;std::vector&lt;Item4Ptr&gt;, VectorType&gt;)
            {
                LOG(INFO) &lt;&lt; 'Content of vector&lt;A&gt;:' &lt;&lt; std::endl;
                for (const Item4Ptr&amp; item : vec)
                {
                    LOG(INFO) &lt;&lt; 'is d. ' &lt;&lt; item-&gt;idd &lt;&lt; ' ' &lt;&lt; item-&gt;named;
                }
            }
        },
        vec_);
}
```

## 普通类型

&gt; [!IMPORTANT]
&gt; &lt;ins&gt;**实现 容器类 (Container Class)：负责存储数据和状态**&lt;/ins&gt;
&gt; &lt;ins&gt;**迭代器类 (Iterator Class)：一个独立的类（通常作为容器的嵌套类），它知道如何在容器中导航（移动到下一个元素）并访问当前元素**&lt;/ins&gt;

### step1
&gt; [!IMPORTANT]
&gt; &lt;ins&gt;**定义容器和迭代器的基本结构**&lt;/ins&gt;

```C++
template &lt;typename T, size_t N&gt;
class FixedArray {
private:
    T data_[N];
    size_t size_;

public:
    FixedArray()
        : size_(0) {}

    // 内部迭代器类
    class iterator {
    public:
        using iterator_category = std::random_access_iterator_tag; // 1. 类别：这是最强大的，支持随机访问
        using value_type = T; // 2. 所指元素的类型
        using difference_type = std::ptrdiff_t; // 3. 两个迭代器相减的结果类型
        using pointer = T*; // 4. 指向元素的指针类型
        using reference = T&amp;; // 5. 解引用返回的引用类型
    };
};
```

### step2
&gt; [!IMPORTANT]
&gt; &lt;ins&gt;**实现迭代器类 (iterator)**&lt;/ins&gt;

```C++
    class iterator {
    public:
        using iterator_category = std::random_access_iterator_tag; // 1. 类别：这是最强大的，支持随机访问
        using value_type = T; // 2. 所指元素的类型
        using difference_type = std::ptrdiff_t; // 3. 两个迭代器相减的结果类型
        using pointer = T*; // 4. 指向元素的指针类型
        using reference = T&amp;; // 5. 解引用返回的引用类型

    public:
        explicit iterator(pointer ptr)
            : ptr_(ptr) {}

        // --- 核心操作符 ---
        // 1. 解引用 (Dereference) -&gt; 获取元素
        auto operator*() const -&gt; reference { return *ptr_; }
        auto operator-&gt;() const -&gt; pointer { return ptr_; }


        // 2. 前置递增 (Prefix Increment) -&gt; 移动到下一个
        auto operator++() -&gt; iterator&amp; {
            ++ptr_;
            return *this;
        }
        // 后置递增 (Postfix Increment)
        auto operator++(int) -&gt; iterator {
            iterator temp = *this;
            ++(*this);
            return temp;
        }


        // 3. 比较 (Comparison) -&gt; for循环的终止条件
        auto operator==(const iterator&amp; other) const -&gt; bool { return ptr_ == other.ptr_; }
        auto operator!=(const iterator&amp; other) const -&gt; bool { return ptr_ != other.ptr_; }

        // --- (可选) 为 random_access_iterator_tag 提供更多操作符 ---
        auto operator--() -&gt; iterator&amp; {
            --ptr_;
            return *this;
        }
        auto operator--(int) -&gt; iterator {
            iterator temp = *this;
            --(*this);
            return temp;
        }
        auto operator+=(difference_type offset) -&gt; iterator&amp; {
            ptr_ += offset;
            return *this;
        }
        auto operator+(difference_type offset) const -&gt; iterator {
            iterator temp = *this;
            temp += offset;
            return temp;
        }
        auto operator-=(difference_type offset) -&gt; iterator&amp; {
            ptr_ -= offset;
            return *this;
        }
        auto operator-(difference_type offset) const -&gt; iterator {
            iterator temp = *this;
            temp -= offset;
            return temp;
        }
        auto operator-(const iterator&amp; other) const -&gt; difference_type { return ptr_ - other.ptr_; }
        auto operator[](difference_type offset) const -&gt; reference { return ptr_[offset]; }
        auto operator&lt;(const iterator&amp; other) const -&gt; bool { return ptr_ &lt; other.ptr_; }

    private:
        pointer ptr_;
    };
```

### step3 

&gt; [!IMPORTANT]
&gt; &lt;ins&gt;**在容器中实现 begin() 和 end()**&lt;/ins&gt;

```C++
public:
    iterator begin() {
        return iterator(data_); // 创建一个指向数组头部的迭代器
    }

    iterator end() {
        return iterator(data_ + N); // 创建一个指向数组末尾之后一个位置的迭代器
    }
```

### step4 
&gt; [!IMPORTANT]
&gt; &lt;ins&gt;**const 正确性 - 实现 const_iterator**&lt;/ins&gt;

```C++
public:
    // (接在 iterator 类定义之后)
    class const_iterator {
        // 实现与 iterator 类似, 但所有返回的引用和指针都是 const
    public:
        using iterator_category = std::random_access_iterator_tag;
        using value_type        = T;
        using difference_type   = std::ptrdiff_t;
        using pointer           = const T*; // 注意这里是 const
        using reference         = const T&amp;; // 注意这里是 const

    private:
        pointer ptr_;

    public:
        explicit const_iterator(pointer ptr) : ptr_(ptr) {}

        reference operator*() const { return *ptr_; }
        const_iterator&amp; operator++() { ++ptr_; return *this; }
        bool operator!=(const const_iterator&amp; other) const { return ptr_ != other.ptr_; }
    };


    // --- 非 const 版本，返回可修改的迭代器 ---
    iterator begin() { return iterator(data_); }
    iterator end()   { return iterator(data_ + N); }

    // --- const 版本，返回只读的迭代器 ---
    const_iterator begin() const { return const_iterator(data_); }
    const_iterator end() const   { return const_iterator(data_ + N); }

    // --- 显式的 const 版本 (最佳实践) ---
    const_iterator cbegin() const { return const_iterator(data_); }
    const_iterator cend() const   { return const_iterator(data_ + N); 
}
```
。</description><guid isPermaLink="true">https://0x1042.github.io//post/51.html</guid><pubDate>Mon, 09 Jun 2025 17:52:57 +0000</pubDate></item><item><title>decltype &amp;&amp; declval</title><link>https://0x1042.github.io//post/50.html</link><description>
# decltype 

&lt;ins&gt;**decltype是一个关键字,而不是函数,用于在编译期推断一个表达式的类型,不会实际计算表达式的值**&lt;/ins&gt;


&gt; [!IMPORTANT]
&gt; decltype(expression): 如果 expression 是一个未加括号的 id-expression (标识符表达式，如变量名) 或者一个未加括号的类成员访问表达式 ( object.member 或 pointer-&gt;member ), 返回该标识符或成员被声明时的类型 (declared type)
&gt; - 例如，如果 int x = 0;，那么 decltype(x) 就是 int。</description><guid isPermaLink="true">https://0x1042.github.io//post/50.html</guid><pubDate>Sat, 31 May 2025 15:44:17 +0000</pubDate></item><item><title>value</title><link>https://0x1042.github.io//post/49.html</link><description># value

## 分类

```mermaid
graph LR
    A[expression] --&gt; B[glvalue]
    A[expression] --&gt; C[rvalue]
    B --&gt; D[lvalue]
    B --&gt; E[xvalue]
    C --&gt; E[xvalue]
    C --&gt; F[prvalue]
```

- glvalue = lvalue + xvalue , 有identity, 可以被取地址
- rvalue = xvalue + prvalue , 可以移动

## 如何区分

&gt; [!Tip]
&gt; 1. 有名字(`identity`)的都是左值, 即便是右值引用 变量本身,当它被用作表达式时,也是左值
&gt; 2. 可以被取地址的,都是左值
&gt; 3. &lt;ins&gt;**字符串字面量是左值**&lt;/ins&gt;,&lt;ins&gt;**其他字面量(42/MyClass{})是右值**&lt;/ins&gt;
&gt; 4. `std::move(arg) `的结果是 `xvalue`
&gt; 5. 临时对象 `MyClass()` 是 `prvalue`


## 函数返回值

1. &lt;ins&gt;**返回左值引用 (T&amp; func())：结果是 lvalue.**&lt;/ins&gt;
2. &lt;ins&gt;**返回右值引用 (T&amp;&amp; func())：结果是 xvalue.**&lt;/ins&gt;
3. &lt;ins&gt;**返回非引用类型/值类型 (T func())：结果是 prvalue.**&lt;/ins&gt;


## 字符串字面量

&gt; [!IMPORTANT]
&gt; `'hello world'` 是左值

- 字符串字面量在程序编译后，会被存储在内存的特定区域（通常是只读数据段）。</description><guid isPermaLink="true">https://0x1042.github.io//post/49.html</guid><pubDate>Sat, 31 May 2025 10:58:58 +0000</pubDate></item><item><title>trait</title><link>https://0x1042.github.io//post/48.html</link><description>
# trait

## 定义

- 是一个&lt;ins&gt;**类模板**&lt;/ins&gt;,通常是&lt;ins&gt;**struct**&lt;/ins&gt;
- 用于在&lt;ins&gt;**编译时获取或者查询某个类型T的信息或者属性**&lt;/ins&gt;
- 不包含运行时数据,通常通过&lt;ins&gt;**static constexpr 成员**&lt;/ins&gt;或者&lt;ins&gt;**嵌套类型别名(using type = ...)**&lt;/ins&gt;


## 功能

- 类型信息查询. 比如&lt;ins&gt;**`std::is_integral&lt;T&gt;`**&lt;/ins&gt; 查询`T`是否是整形
- 类型转换/关联. 比如&lt;ins&gt;**`std::remove_pointer&lt;T*&gt;::type`**&lt;/ins&gt; 移除`T`的指针属性
- 条件编译. 与 &lt;ins&gt;**std::enable_if 或 if constexpr**&lt;/ins&gt; 结合,根据类型特性选择不同的代码路径

## 原理

- 主模板 (Primary Template): &lt;ins&gt;**定义通用的情况或默认值**&lt;/ins&gt;
- 模板特化 (Template Specialization): 为&lt;ins&gt;**特定类型或满足特定条件的类型提供特定的信息**&lt;/ins&gt;


## 🌰

```c++

// step 1
// 主模板 定义通用情况
template &lt;typename T&gt;
struct is_my_void {
  static constexpr bool value = false;
};

// step 2
// 特化模板 定义特例情况
template &lt;&gt; struct
is_my_void&lt;void&gt; {
  static constexpr bool value = true;
};

// step3 可选 定义辅助变量
template &lt;typename T&gt;
inline constexpr bool is_my_void_v = is_my_void&lt;T&gt;::value;
```
。</description><guid isPermaLink="true">https://0x1042.github.io//post/48.html</guid><pubDate>Tue, 27 May 2025 18:01:43 +0000</pubDate></item><item><title>交叉编译c++</title><link>https://0x1042.github.io//post/47.html</link><description># 安装 

## 安装基础依赖 

```shell
sudo apt update
sudo apt install build-essential git curl make gcc libncurses-dev
```

## 安装编译器

```
git clone https://github.com/richfelker/musl-cross-make.git

cat &lt;&lt; EOF &gt; config.mak
GCC_VER = 14.2.0
TARGET = mipsel-linux-musl
OUTPUT = /opt/musl-cross
GNU_SITE = https://mirrors.tuna.tsinghua.edu.cn/gnu/
EOF
```

&gt; target 支持

- `aarch64[_be]-linux-musl`
- `arm[eb]-linux-musleabi[hf]`
- `i*86-linux-musl`
- `microblaze[el]-linux-musl`
- `mips-linux-musl`
- `mips[el]-linux-musl[sf]`
- `mips64[el]-linux-musl[n32][sf]`
- `powerpc-linux-musl[sf]`
- `powerpc64[le]-linux-musl`
- `riscv64-linux-musl`
- `s390x-linux-musl`
- `sh*[eb]-linux-musl[fdpic][sf]`
- `x86_64-linux-musl[x32]`


&gt; Here Document

- 语法

```shell
命令 &lt;&lt; 终止符
多行文本内容...
终止符

eg:

cat &lt;&lt; EOF 
hello
world
EOF 

ssh user@host &lt;&lt; EOF
ls -l
df -h
EOF

```

## 编译

```shell
make -j$(nproc)
sudo make install
echo 'export PATH='/opt/musl-cross/bin:$PATH'' &gt;&gt; ~/.bashrc
source ~/.bashrc
```

## 验证

```shell
/opt/musl-cross/bin/mipsel-linux-musl-c++ --version
```

# `with meson`

## 配置

```shell

cat &lt;&lt; EOF &gt; mips.ini
[constants]
toolchain = '/opt/musl-cross'
sysroot = toolchain + '/mipsel-linux-musl'

[binaries]
c = toolchain + '/bin/mipsel-linux-musl-cc'
cpp = toolchain + '/bin/mipsel-linux-musl-c++'
ar = toolchain + '/bin/mipsel-linux-musl-ar'
strip = toolchain + '/bin/mipsel-linux-musl-strip'

[properties]
sys_root = sysroot
debug = false
strip = true

[host_machine]
system = 'linux'
cpu_family = 'mips'
cpu = 'mipsel'
endian = 'little'

EOF
```

## 编译

```shell
meson setup target -Db_lto=true -Dbuildtype=release --cross-file mips.ini -Dstrip=true
meson compile -C target --verbose
meson install -C target --destdir=./install

```
。</description><guid isPermaLink="true">https://0x1042.github.io//post/47.html</guid><pubDate>Sun, 30 Mar 2025 11:30:29 +0000</pubDate></item><item><title>c++ basic</title><link>https://0x1042.github.io//post/46.html</link><description># 构造函数

```c++
Object a; // 默认构造函数
Object b = a; // 拷贝构造函数
Object c(b);// 拷贝构造函数
c = a; // 赋值运算符
```

- **拷贝构造函数用于新对象的初始化**
- **赋值运算符用于已存在对象的赋值**
- **函数按值传参或返回对象时，也会触发拷贝构造函数或者移动构造函数**

# lvalue/rvalue

```c++
int f(std::string &amp;str) { return 0; }
int f(const std::string &amp;str) { return 1; }
int f(std::string &amp;&amp;str) { return 2; }

f('Hello!') -&gt; 2
```

**重载解析优先级**

- 右值引用(**&amp;&amp;**): 优先匹配右值
- 常量左值引用(**const &amp;**): 可接受右值，但是优先级低于右值引用
- 非const左值引用(**&amp;**): 无法绑定右值

&gt; `'Hello!` 是字符串字面量，即右值，优先匹配右值引用的函数

# 类型转换

```c++
struct B {
  int m_a;
};

struct A {
  int m_a;
};

A a{0};
B b = static_cast&lt;B&gt;(a); // 允许编译通过
```

## 用户自定义转换函数

&gt; https://zh.cppreference.com/w/cpp/language/cast_operator

```c++
struct A {
  int m_a;

// 允许A 通过static_cast的方式转换为B
  explicit operator B() const {
      return B{m_a};
  }
};
```

- 语法
    - `operator 转换类型标识`
    - `explicit operator 转换类型标识`
    - `explicit ( 表达式 ) operator 转换类型标识`

## 构造函数

```c++
struct A {
  int m_a;
};

struct B {
  int m_a;
  explicit B(const A &amp;aObj) : m_a(aObj.m_a) {}
};

B b = static_cast&lt;B&gt;(a);
```

- `static_cast` 支持基本类型之间的合法转换
- `static_cast` 非基本类型时，尝试寻找显示构造函数和用户自定义构造函数，两种不能同时存在

# `const`

- **const 就近原则，修饰的是const左边的东西，如果左边没有，就修饰右边的**
- **左定值，右定向: const 在`*`左边时，指针指向的值（内容）不可变，在`*`右边时，指针的指向不可改变**

## 左定值

```c++

struct Item {
  int id = 0;
  std::string name;
};

const Item *item_ptr = new Item(1, 'hello');
```

**const 在`*`的左边，即值不可变**

- 不可变部分: *item_ptr

&gt; 编译报错 `error: read-only variable is not assignable`

```c++
(*item_ptr).id = 2;
(*item_ptr).name = 'world';
```
- 可变部分: item_ptr

&gt; 下面的编译正常

```c++
Item item2(2, 'world');
item_ptr = &amp;item2;
```

## 右定向

```c++
Item *const item_ptr = new Item(3, 'hello');
```
- 不可变部分: `Item *`，也就是不能修改指向

&gt; 下面的编译报错 `error: cannot assign to variable 'item_ptr' with const-qualified type 'Item *const'`

```c++
Item item3(3, 'world');
item_ptr = &amp;item3; // 不能修改指向
```

- 可变部分: `*item_ptr`

```c++
(*item_ptr).id = 4;
(*item_ptr).name = 'world2';

```


。</description><guid isPermaLink="true">https://0x1042.github.io//post/46.html</guid><pubDate>Sat, 08 Mar 2025 10:08:51 +0000</pubDate></item><item><title>simd hello world</title><link>https://0x1042.github.io//post/44.html</link><description># SIMD Dot Product

## 实现

```cpp
#include &lt;immintrin.h&gt;
#include &lt;pmmintrin.h&gt;
#include &lt;x86intrin.h&gt;
#include &lt;xmmintrin.h&gt;

/**
 * @brief base 版本
 *
 * @param a
 * @param b
 * @param dim
 * @return float
 */
float dot(const void *a, const void *b, size_t dim) {
  float sum = 0;
  for (unsigned i = 0; i &lt; dim; i++) {
    sum += ((float *)a)[i] * ((float *)b)[i];
  }
  return sum;
}

/**
 * @brief simd 版本
 *
 * @param a
 * @param b
 * @param dim
 * @return float
 */
float dot_simd(const void *a, const void *b, size_t dim) {

  float *va = (float *)a;
  float *vb = (float *)b;

  size_t qty16 = dim / 16;

  const float *enda = va + 16 * qty16;

  // 初始化一个零向量 长度为8
  __m256 sum = _mm256_set1_ps(0);

  while (va &lt; enda) {
      // 将va的前8个元素加载到向量v1中
    __m256 v1 = _mm256_loadu_ps(va);
    va += 8;
    // 将vb的前8个元素加载到向量v2中
    __m256 v2 = _mm256_loadu_ps(vb);
    vb += 8;

    // 执行乘法和加法：sum += v1 * v2
    sum = _mm256_fmadd_ps(v1, v2, sum);

    // 将va的前8个元素加载到向量v1中
    v1 = _mm256_loadu_ps(va);
    va += 8;
    // 将vb的前8个元素加载到向量v2中
    v2 = _mm256_loadu_ps(vb);
    vb += 8;

    // 执行乘法和加法：sum += v1 * v2
    sum = _mm256_fmadd_ps(v1, v2, sum);
  }

    // 从256位向量中提取两个128位部分
  __m128 low = _mm256_extractf128_ps(sum, 0);// 低128位
  __m128 hight = _mm256_extractf128_ps(sum, 1); // 高128位


 // 将两个128位向量相加，得到一个包含4个float的向量
  __m128 sum128 = _mm_add_ps(low, hight);

  // 这时sum128包含4个float值：[a, b, c, d]

  // 第一次hadd：将相邻元素两两相加
  // 输入：[a, b, c, d]
  // 输出：[a+b, c+d, a+b, c+d]
  sum128 = _mm_hadd_ps(sum128, sum128);

  // 第二次hadd：再次将相邻元素两两相加
  // 输入：[a+b, c+d, a+b, c+d]
  // 输出：[a+b+c+d, a+b+c+d, a+b+c+d, a+b+c+d]
  sum128 = _mm_hadd_ps(sum128, sum128);

  // 处理剩余部分
  float tail_sum = 0.0f;
  size_t remainder = dim % 16;
  for (size_t i = 0; i &lt; remainder; ++i) {
    tail_sum += va[i] * vb[i];
  }

 //_mm_cvtss_f32 将结果从SIMD寄存器提取到普通浮点数
  return _mm_cvtss_f32(sum128) + tail_sum;
}

```

## 编译

```meson
add_global_arguments('-march=native', language: 'cpp')
add_global_arguments('-mavx2', language: 'cpp')
add_global_arguments('-mpclmul', language: 'cpp')
add_global_arguments('-mbmi', language: 'cpp')

dot_inc = include_directories('.')

dot_src = files(
    'dot.cc',
)

dot = library(
    'dot',
    dot_src,
    dependencies: [
        random_dep,
    ],
    include_directories: dot_inc,
)

dot_dep = declare_dependency(
    include_directories: dot_inc,
    link_with: dot,
)
```

## unittest

### 实现

```c++
#include 'dot.h'
#include &lt;gtest/gtest.h&gt;

TEST(check, check1) {
  constexpr size_t dim = 128;

  const auto &amp;va = random(dim);
  const auto &amp;vb = random(dim);

  const auto &amp;base = dot(va.data(), vb.data(), dim);
  const auto &amp;simd = dot_simd(va.data(), vb.data(), dim);

  EXPECT_NE(base, 0);
  EXPECT_NE(simd, 0);
  EXPECT_FLOAT_EQ(base, simd);
}

TEST(check, check2) {
  constexpr size_t dim = 333;

  const auto &amp;va = random(dim);
  const auto &amp;vb = random(dim);

  const auto &amp;base = dot(va.data(), vb.data(), dim);
  const auto &amp;simd = dot_simd(va.data(), vb.data(), dim);

  EXPECT_NE(base, 0);
  EXPECT_NE(simd, 0);
  EXPECT_FLOAT_EQ(base, simd);
}

int main(int argc, char **argv) {
  testing::InitGoogleTest(&amp;argc, argv);
  return RUN_ALL_TESTS();
}

```

### 编译

```meson
executable(
    'ut',
    'ut.cc',
    install: true,
    dependencies: [thread_dep, random_dep, gtest_dep, dot_dep],
)
```

## benchmark

### 实现
```c++
#include 'dot.h'
#include &lt;benchmark/benchmark.h&gt;

static void BM_dot(benchmark::State &amp;state) {
  constexpr size_t dim = 128;

  const auto &amp;va = random(dim);
  const auto &amp;vb = random(dim);

  for (auto _ : state) {
    const auto &amp;simd = dot_simd(va.data(), vb.data(), dim);
    benchmark::DoNotOptimize(simd);
  }
}

BENCHMARK(BM_dot);

int main(int argc, char **argv) {
  benchmark::Initialize(&amp;argc, argv);
  benchmark::RunSpecifiedBenchmarks();
  return 0;
}

```

### 编译

```meson
executable(
    'bench',
    'bench.cc',
    install: true,
    dependencies: [thread_dep, random_dep, bench_dep, dot_dep],
)
```

``` text
./target/bench --benchmark_min_time=10s
2025-02-19T01:19:44+08:00
Running ./target/bench
Run on (16 X 2300 MHz CPU s)
CPU Caches:
  L1 Data 32 KiB
  L1 Instruction 32 KiB
  L2 Unified 256 KiB (x8)
  L3 Unified 16384 KiB
Load Average: 1.89, 2.17, 2.30
------------------------------------------------------
Benchmark            Time             CPU   Iterations
------------------------------------------------------
BM_dot            94.0 ns         94.0 ns    147363798
BM_dot_simd       10.3 ns         10.2 ns   1442614248
```
。</description><guid isPermaLink="true">https://0x1042.github.io//post/44.html</guid><pubDate>Tue, 18 Feb 2025 17:42:07 +0000</pubDate></item><item><title>zig build misc</title><link>https://0x1042.github.io//post/43.html</link><description># 跨平台编译

```zig

const targets: []const std.Target.Query = &amp;.{
    .{ .cpu_arch = .x86_64, .os_tag = .macos },
    .{ .cpu_arch = .x86_64, .os_tag = .linux, .abi = .gnu },
    .{ .cpu_arch = .x86_64, .os_tag = .linux, .abi = .musl },
    .{ .cpu_arch = .x86_64, .os_tag = .windows },
    .{ .cpu_arch = .aarch64, .os_tag = .macos },
    .{ .cpu_arch = .aarch64, .os_tag = .linux },
    .{ .cpu_arch = .aarch64, .os_tag = .windows },
    .{ .cpu_arch = .mips, .os_tag = .linux, .abi = .musl },
    .{ .cpu_arch = .mipsel, .os_tag = .linux, .abi = .musl },
    .{ .cpu_arch = .mips64, .os_tag = .linux, .abi = .musl },
    .{ .cpu_arch = .mips64el, .os_tag = .linux, .abi = .musl },
};

pub fn build(b: *std.Build) void {
    const optimize = b.standardOptimizeOption(.{});

    for (targets) |t| {
        var name: []u8 = undefined;
        const arch = if (t.cpu_arch) |arch| @tagName(arch) else 'native';
        const os = if (t.os_tag) |os| @tagName(os) else 'unknown';
        if (t.abi) |abi| {
            name = b.fmt('{s}-{s}-{s}', .{ os, arch, @tagName(abi) });
        } else {
            name = b.fmt('{s}-{s}', .{ os, arch });
        }

        const exe = b.addExecutable(.{
            .name = name,
            .root_source_file = b.path('src/main.zig'),
            .target = b.resolveTargetQuery(t),
            .optimize = optimize,
        });

        b.installArtifact(exe);
    }
}

```

# 自定义编译选项 


```zig

fn addOption(b: *std.Build) *std.Build.Step.Options {
    const version = b.option([]const u8, 'version', 'build version') orelse 'dev';
    const date = b.option([]const u8, 'date', 'build date') orelse 'unknown';

    const options = b.addOptions();
    options.addOption([]const u8, 'version', version);
    options.addOption([]const u8, 'date', date);

    return options;
}

exe.root_module.addOptions('config', options);

```

编译时，指定选项

```shell
zig build -freference-trace --summary all --verbose -Dversion=22c0548 -Ddate=2025-01-18
```

`addOptions` 会将选项转换成zig代码，同时可以在项目中直接依赖，可以使用这个功能来生成与`golang`中通过 `ldflags -X` 编译时生成构建日期/commit等一样的功能

```zig
// main.zig

const config = @import('config');

const version = config.date ++ ' ' ++ config.version;

```

# 根据编译类型控制日志级别

```zig
pub const level = switch (@import('builtin').mode) {
    .Debug =&gt; std.log.Level.debug,
    else =&gt; std.log.Level.info,
};

pub const std_options = .{
    .log_level = level,
    .logFn = logger.logfn,
};
```



。</description><guid isPermaLink="true">https://0x1042.github.io//post/43.html</guid><pubDate>Sat, 18 Jan 2025 10:32:33 +0000</pubDate></item><item><title>zig cc 编译c项目</title><link>https://0x1042.github.io//post/42.html</link><description># zig cc 编译c项目 &#13;
&#13;
## 单个c文件&#13;
&#13;
```zig&#13;
    const flags = .{&#13;
        '-Wall',&#13;
        '-Wextra',&#13;
        '-Wpedantic',&#13;
        '-Werror=return-type',&#13;
        '-std=gnu23',&#13;
    };&#13;
&#13;
    exe.addCSourceFile(.{&#13;
        .file = std.Build.LazyPath{ .cwd_relative = 'http.c' },&#13;
        .flags = &amp;flags,&#13;
    });&#13;
&#13;
    exe.linkLibC();&#13;
```&#13;
&#13;
## 多个c文件&#13;
&#13;
```zig&#13;
    const cfiles = .{&#13;
        'http.c',&#13;
        'log.c',&#13;
        'server.c',&#13;
        'main.c',&#13;
        'relay.c',&#13;
        'socks.c',&#13;
    };&#13;
&#13;
    exe.addCSourceFiles(.{&#13;
        .files = &amp;cfiles,&#13;
        .flags = &amp;flags,&#13;
    });&#13;
```&#13;
&#13;
## 自定义目录和后缀&#13;
&#13;
```zig&#13;
&#13;
    {&#13;
        var sources = std.ArrayList([]const u8).init(b.allocator);&#13;
        var dir = try std.fs.cwd().openDir('.', .{ .access_sub_paths = true });&#13;
        var walker = try dir.walk(b.allocator);&#13;
        defer walker.deinit();&#13;
&#13;
        const allowed_exts = [_][]const u8{ '.c', '.cpp', '.cxx', '.c++', '.cc' };&#13;
&#13;
        while (try walker.next()) |entry| {&#13;
            const ext = std.fs.path.extension(entry.basename);&#13;
            const include_file = for (allowed_exts) |e| {&#13;
                if (std.mem.eql(u8, ext, e))&#13;
                    break true;&#13;
            } else false;&#13;
            if (include_file) {&#13;
                // we have to clone the path as walker.next() or walker.deinit() will override/kill it&#13;
                try sources.append(b.dupe(entry.path));&#13;
            }&#13;
        }&#13;
    }&#13;
```&#13;
&#13;
## todo1 外部库 &#13;
&#13;
## todo2 c++&#13;
&#13;
&#13;
## 编译 &#13;
&#13;
- native &#13;
&#13;
```zig &#13;
&#13;
VERBOSE := '--verbose --summary all'&#13;
zb_rel:&#13;
    zig build {{ VERBOSE }} --release=safe -Doptimize=ReleaseSafe --prefix {{ OUTPUT }}/rel&#13;
&#13;
```&#13;
- 交叉&#13;
&#13;
```zig &#13;
zb_linux_rel:&#13;
    zig build {{ VERBOSE }} -Dtarget=x86_64-linux-gnu -Doptimize=ReleaseSafe --prefix {{ OUTPUT }}/linux/rel&#13;
```&#13;
&#13;
。</description><guid isPermaLink="true">https://0x1042.github.io//post/42.html</guid><pubDate>Sat, 04 Jan 2025 18:49:48 +0000</pubDate></item><item><title>criterion 单元测试使用</title><link>https://0x1042.github.io//post/41.html</link><description># 添加依赖&#13;
&#13;
```meson&#13;
// meson.build&#13;
&#13;
libcriterion = dependency(&#13;
    'criterion',&#13;
    method: 'pkg-config',&#13;
    required: true,&#13;
)&#13;
&#13;
lib_xmacro_sources = files(&#13;
    'xmacro.c',&#13;
    'xmacro.h',&#13;
)&#13;
&#13;
libxmacro = shared_library(&#13;
    'xmacro',&#13;
    lib_xmacro_sources,&#13;
    dependencies: [&#13;
        libcriterion,&#13;
    ],&#13;
)&#13;
&#13;
&#13;
samples = [&#13;
    'xmacro_test.c',&#13;
]&#13;
&#13;
foreach sample : samples&#13;
    e = executable(&#13;
        sample + '.bin',&#13;
        sample,&#13;
        dependencies: [libcriterion],&#13;
        link_with: [libxmacro],&#13;
    )&#13;
    test('sample / ' + sample, e)&#13;
endforeach&#13;
&#13;
```&#13;
&#13;
&#13;
# 使用 &#13;
&#13;
```c&#13;
#include 'xmacro.h'&#13;
#include &lt;criterion/criterion.h&gt;&#13;
#include &lt;criterion/logging.h&gt;&#13;
#include &lt;criterion/options.h&gt;&#13;
#include &lt;string.h&gt;&#13;
&#13;
Test(http_mhd, to_str) {&#13;
&#13;
  {&#13;
    const char *tmp = mhd_to_str(HTTP_GET);&#13;
    cr_log_info('HTTP_GET %s ', tmp);&#13;
    cr_assert(tmp, 'GET');&#13;
  }&#13;
&#13;
  {&#13;
    const char *tmp = mhd_to_str(HTTP_CONNECT);&#13;
    cr_log_info('HTTP_CONNECT %s ', tmp);&#13;
    cr_assert(tmp, 'CONNECT');&#13;
  }&#13;
}&#13;
&#13;
Test(http_mhd, from_str) {&#13;
  {&#13;
    http_method_t tmp = str_to_mhd('GET');&#13;
    cr_log_info('GET %d ', tmp);&#13;
    cr_assert_eq(tmp, HTTP_GET);&#13;
  }&#13;
  {&#13;
    http_method_t tmp = str_to_mhd('Post');&#13;
    cr_log_info('Post %d ', tmp);&#13;
    cr_assert_eq(tmp, HTTP_POST);&#13;
  }&#13;
  {&#13;
    http_method_t tmp = str_to_mhd('TRACE');&#13;
    cr_log_info('TRACE %d ', tmp);&#13;
    cr_assert_eq(tmp, HTTP_TRACE);&#13;
  }&#13;
}&#13;
&#13;
```&#13;
&#13;
# 编译&#13;
&#13;
```&#13;
build_asan:&#13;
  meson setup buildDir -Db_sanitize=address -Db_lundef=false&#13;
  meson compile -C buildDir&#13;
  ln -sf buildDir/compile_commands.json .&#13;
&#13;
run_test:&#13;
    ./buildDir/xmacro_test.c.bin --verbos --full-stats&#13;
```&#13;
。</description><guid isPermaLink="true">https://0x1042.github.io//post/41.html</guid><pubDate>Sat, 04 Jan 2025 17:32:54 +0000</pubDate></item><item><title>x macro</title><link>https://0x1042.github.io//post/40.html</link><description># x 宏&#13;
&#13;
&gt; 实现枚举与str互相转换的时候，搜到的一个用法。</description><guid isPermaLink="true">https://0x1042.github.io//post/40.html</guid><pubDate>Sat, 04 Jan 2025 17:27:58 +0000</pubDate></item><item><title>c++ misc</title><link>https://0x1042.github.io//post/39.html</link><description># 元函数 &#13;
&#13;
- 输入: 通过模板参数 &#13;
- 输出: 通常通过类型别名(using/typedef)或静态成员来提供 &#13;
- 计算过程: 编译期&#13;
&#13;
```c++&#13;
template &lt;typename T&gt; // 输入 &#13;
struct is_pointer {&#13;
    static constexpr bool value = false; // 输出&#13;
};&#13;
&#13;
template &lt;typename T&gt;&#13;
struct is_pointer&lt;T *&gt; {&#13;
    static constexpr bool value = true;&#13;
};&#13;
&#13;
static_assert(is_pointer&lt;int *&gt;::value); // 计算过程&#13;
static_assert(!is_pointer&lt;int&gt;::value);&#13;
```&#13;
&#13;
# 模板参数 &#13;
&#13;
- 类型参数&#13;
&#13;
```c++&#13;
template &lt;typename T&gt;&#13;
struct Container {&#13;
    T val;&#13;
};&#13;
```&#13;
&#13;
- 非类型参数&#13;
&#13;
&gt; 必须是 编译期常量&#13;
&#13;
```c++&#13;
template &lt;int size&gt;&#13;
struct Array {&#13;
    std::array&lt;int, size&gt; data;&#13;
};&#13;
```&#13;
&#13;
- 模板参数 &#13;
```c++&#13;
template &lt;template &lt;typename&gt; class Container&gt;&#13;
class Wrapper {&#13;
    Container&lt;int&gt; data; // 使用传入的模板&#13;
public:&#13;
    void add(int value) { data.push_back(value); }&#13;
};&#13;
```&#13;
&#13;
&#13;
# `restrict` 关键字&#13;
&#13;
## 作用&#13;
&#13;
&gt; 程序员向编译器保证，在指针的整个生命周期内，只有这个指针能用来访问它指向的对象。</description><guid isPermaLink="true">https://0x1042.github.io//post/39.html</guid><pubDate>Sun, 22 Dec 2024 10:06:11 +0000</pubDate></item><item><title>strict weak order</title><link>https://0x1042.github.io//post/38.html</link><description># 背景&#13;
&#13;
&gt; 上线了业务逻辑代码，发现有`coredump`, 从堆栈看，是出现了越界。</description><guid isPermaLink="true">https://0x1042.github.io//post/38.html</guid><pubDate>Mon, 02 Dec 2024 16:25:56 +0000</pubDate></item><item><title>macos cmake 依赖 omp</title><link>https://0x1042.github.io//post/37.html</link><description>&#13;
# 配置&#13;
&#13;
```cmake&#13;
set(CMAKE_CXX_FLAGS '${CMAKE_CXX_FLAGS} -stdlib=libc++')&#13;
link_directories(/usr/local/opt/llvm/lib/c++)&#13;
&#13;
find_package(OpenMP COMPONENTS CXX)&#13;
target_link_libraries(&#13;
  ${PROJECT_NAME}&#13;
  PUBLIC OpenMP::OpenMP_CXX&#13;
  PUBLIC c++abi&#13;
  PUBLIC c++&#13;
)&#13;
```&#13;
&#13;
# 使用&#13;
&#13;
```c++&#13;
auto batch_get2(const std::vector&lt;std::string&gt; &amp; urls, std::vector&lt;std::string&gt; &amp; resps) -&gt; int {&#13;
    std::chrono::high_resolution_clock::time_point start = std::chrono::high_resolution_clock::now();&#13;
    resps.resize(urls.size());&#13;
&#13;
#pragma omp parallel for schedule(dynamic, 1)&#13;
    for (int i = 0; i &lt; urls.size(); i++) {&#13;
        get(urls[i], resps[i]);&#13;
    }&#13;
    std::chrono::high_resolution_clock::time_point finish = std::chrono::high_resolution_clock::now();&#13;
&#13;
    spdlog::info('omp cost {}', std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(finish - start).count());&#13;
&#13;
    return 0;&#13;
}&#13;
```&#13;
。</description><guid isPermaLink="true">https://0x1042.github.io//post/37.html</guid><pubDate>Thu, 07 Nov 2024 17:19:02 +0000</pubDate></item><item><title>protobuf ListValue 使用</title><link>https://0x1042.github.io//post/36.html</link><description># 背景&#13;
&#13;
&gt; 考虑这个`json` 如何定义对应的`protobuf` 结构？&#13;
&#13;
```json&#13;
{&#13;
    'show_list': {&#13;
        'hello1': [&#13;
            'world1',&#13;
            'world1'&#13;
        ],&#13;
        'hello2': [&#13;
            'world2',&#13;
            'world2'&#13;
        ]&#13;
    }&#13;
}&#13;
```&#13;
&#13;
**`protobuf` 中无法直接声明`map&lt;key,repeated values&gt;` 对应的结构，需要借助`ListValue`**&#13;
&#13;
# 定义&#13;
&#13;
```protobuf&#13;
syntax = 'proto3';&#13;
&#13;
package demo;&#13;
option go_package = './demos';&#13;
&#13;
import 'google/protobuf/struct.proto';&#13;
&#13;
message UaInfo {&#13;
  map&lt;string, google.protobuf.ListValue&gt; show_list = 1;&#13;
}&#13;
&#13;
```&#13;
&#13;
# cpp &#13;
&#13;
&gt; 生成 `protoc --proto_path=proto --cpp_out=pbgen proto/*.proto`&#13;
&#13;
- 反序列化&#13;
&#13;
```cpp&#13;
TEST(pb, valus) {&#13;
    const std::string json = R'({'show_list':{'hello1':['world1','world1'],'hello2':['world2','world2']}})';&#13;
&#13;
    google::protobuf::json::ParseOptions opt;&#13;
    opt.ignore_unknown_fields = true;&#13;
    opt.case_insensitive_enum_parsing = true;&#13;
    demo::UaInfo info;&#13;
&#13;
    const auto &amp; status = google::protobuf::json::JsonStringToMessage(json, &amp;info, opt);&#13;
&#13;
    std::clog &lt;&lt; 'status ' &lt;&lt; status &lt;&lt; '\n';&#13;
&#13;
    std::clog &lt;&lt; info.DebugString() &lt;&lt; '\n';&#13;
&#13;
    std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt; db;&#13;
&#13;
    for (const auto &amp; inner : info.show_list()) {&#13;
        for (const auto &amp; list : inner.second.values()) {&#13;
            db[inner.first].push_back(list.string_value());&#13;
        }&#13;
    }&#13;
&#13;
    // 输出 {'hello1': ['world1', 'world1'], 'hello2': ['world2', 'world2']}&#13;
    std::clog &lt;&lt; fmt::to_string(db) &lt;&lt; '\n';&#13;
}&#13;
```&#13;
&#13;
- 生成&#13;
&#13;
```cpp&#13;
TEST(pb, valus2) {&#13;
    google::protobuf::json::PrintOptions opt;&#13;
    opt.add_whitespace = true;&#13;
    demo::UaInfo info;&#13;
    auto * map = info.mutable_show_list();&#13;
&#13;
    {&#13;
        google::protobuf::ListValue list_value;&#13;
        list_value.add_values()-&gt;set_string_value('orld1010');&#13;
        list_value.add_values()-&gt;set_string_value('orld1020');&#13;
        (*map)['hello101'] = std::move(list_value);&#13;
    }&#13;
&#13;
    {&#13;
        google::protobuf::ListValue list_value;&#13;
        list_value.add_values()-&gt;set_string_value('orld2010');&#13;
        list_value.add_values()-&gt;set_string_value('orld2020');&#13;
        (*map)['hello202'] = std::move(list_value);&#13;
    }&#13;
&#13;
    std::clog &lt;&lt; info.DebugString() &lt;&lt; '\n';&#13;
&#13;
    std::string message;&#13;
&#13;
    const auto &amp; status = google::protobuf::json::MessageToJsonString(info, &amp;message, opt);&#13;
&#13;
    std::clog &lt;&lt; 'status ' &lt;&lt; status &lt;&lt; '\n';&#13;
&#13;
    std::clog &lt;&lt; 'message ' &lt;&lt; message &lt;&lt; '\n';&#13;
}&#13;
```&#13;
&#13;
# go&#13;
&#13;
&gt; 生成 `protoc --proto_path=. --go_out=. --go_opt=paths=source_relative *.proto`&#13;
&#13;
- 反序列化&#13;
&#13;
```go&#13;
func Test_test(t *testing.T) {&#13;
	str := '{\'show_list\':{\'hello1\':[\'world1\',\'world1\'],\'hello2\':[\'world2\',\'world2\']}}'&#13;
	uainfo := new(UaInfo)&#13;
&#13;
	if err := json.Unmarshal([]byte(str), uainfo); err != nil {&#13;
		log.Fatal(err)&#13;
	}&#13;
&#13;
	log.Printf('%+v', uainfo)&#13;
&#13;
	bs, err := json.Marshal(uainfo)&#13;
&#13;
	if err != nil {&#13;
		panic(err)&#13;
	}&#13;
	log.Printf('\n%s', bs)&#13;
}&#13;
&#13;
```&#13;
&#13;
- 生成&#13;
&#13;
```go&#13;
func Test_test2(t *testing.T) {&#13;
	uainfo := new(UaInfo)&#13;
	uainfo.ShowList = make(map[string]*structpb.ListValue)&#13;
	l1, _ := structpb.NewList([]any{'world101', 'world102'})&#13;
	uainfo.ShowList['hello1'] = l1&#13;
&#13;
	l2, _ := structpb.NewList([]any{'world202', 'world201'})&#13;
	uainfo.ShowList['hello2'] = l2&#13;
&#13;
	bs, err := json.Marshal(uainfo)&#13;
&#13;
	if err != nil {&#13;
		panic(err)&#13;
	}&#13;
	log.Printf('uainfo\n%s', bs)&#13;
}&#13;
```&#13;
。</description><guid isPermaLink="true">https://0x1042.github.io//post/36.html</guid><pubDate>Fri, 11 Oct 2024 15:29:37 +0000</pubDate></item><item><title>misc error</title><link>https://0x1042.github.io//post/35.html</link><description># vscode 

## terminal 打开报错 

```
SecCodeCheckValidity: Error Domain=NSOSStatusErrorDomain Code=-67062 '(null)' (-67062)
```

## 修复 

```
xattr -cr  /Applications/Visual\ Studio\ Code.app
sudo codesign --force --deep --sign - /Applications/Visual\ Studio\ Code.app
``` 

# apt 

## install warning

```
Key is stored in legacy trusted.gpg keyring (/etc/apt/trusted.gpg), see the DEPRECATION section in apt-key(8) for details.
```

## 修复

[askubuntu.com](https://askubuntu.com/questions/1398344/apt-key-deprecation-warning-when-updating-system-key-is-stored-in-legacy-trust)

```
cd /etc/apt
sudo cp trusted.gpg trusted.gpg.d
```。</description><guid isPermaLink="true">https://0x1042.github.io//post/35.html</guid><pubDate>Sun, 22 Sep 2024 07:23:14 +0000</pubDate></item><item><title>ml 扫盲四</title><link>https://0x1042.github.io//post/34.html</link><description># origin post&#13;
&#13;
&gt; https://x.com/konradgajdus/status/1837196363735482396&#13;
&#13;
- [origin post](#origin-post)&#13;
- [process data](#process-data)&#13;
  - [读取images](#读取images)&#13;
  - [读取labels](#读取labels)&#13;
- [定义网络](#定义网络)&#13;
  - [结构](#结构)&#13;
  - [初始化](#初始化)&#13;
- [前向传播](#前向传播)&#13;
- [反向传播](#反向传播)&#13;
- [训练](#训练)&#13;
  - [单个instance单次迭代](#单个instance单次迭代)&#13;
  - [batch训练](#batch训练)&#13;
- [预测](#预测)&#13;
- [验证](#验证)&#13;
&#13;
# process data&#13;
&#13;
&gt; 数据下载地址 https://yann.lecun.com/exdb/mnist/&#13;
&#13;
| 文件                    | 说明       |&#13;
| ----------------------- | ---------- |&#13;
| `train-images-idx3-ubyte` | 训练集图片 |&#13;
| `train-labels-idx1-ubyte` | 训练集标签 |&#13;
| `t10k-images-idx3-ubyte`  | 测试集图片 |&#13;
| `t10k-labels-idx1-ubyte`  | 测试集标签 |&#13;
&#13;
&#13;
## 读取images&#13;
&#13;
&gt; 数据格式 &#13;
&#13;
```&#13;
[offset] [type]          [value]          [description]&#13;
0000     32 bit integer  0x00000803(2051) magic number&#13;
0004     32 bit integer  60000            number of images&#13;
0008     32 bit integer  28               number of rows&#13;
0012     32 bit integer  28               number of columns&#13;
0016     unsigned byte   ??               pixel&#13;
0017     unsigned byte   ??               pixel&#13;
........&#13;
xxxx     unsigned byte   ??               pixel&#13;
Pixels are organized row-wise. Pixel values are 0 to 255. 0 means background (white), 255 means foreground (black).&#13;
```&#13;
&#13;
```c&#13;
void read_images(const char *fname, unsigned char **images, int *count) {&#13;
	FILE *file = fopen(fname, 'rb');&#13;
	if (file == NULL) {&#13;
		printf('%s open %s failed.', __FUNCTION__, fname);&#13;
		exit(1);&#13;
	}&#13;
&#13;
	int magic = 0;&#13;
	int rows, cols;&#13;
	// magic numx&#13;
	fread(&amp;magic, sizeof(int), 1, file);&#13;
	// number of images&#13;
	fread(count, sizeof(int), 1, file);&#13;
	// 转成大端&#13;
	*count = __builtin_bswap32(*count);&#13;
&#13;
	// number of rows&#13;
	fread(&amp;rows, sizeof(int), 1, file);&#13;
	//	number of columns&#13;
	fread(&amp;cols, sizeof(int), 1, file);&#13;
&#13;
	rows = __builtin_bswap32(rows);&#13;
	cols = __builtin_bswap32(cols);&#13;
&#13;
	printf('%s: %d/%d/%d\n', __FUNCTION__, *count, rows, cols);&#13;
&#13;
	*images = malloc((*count) * IMAGE_SIZE * IMAGE_SIZE);&#13;
	fread(*images, sizeof(unsigned char), (*count) * IMAGE_SIZE * IMAGE_SIZE, file);&#13;
	fclose(file);&#13;
}&#13;
```&#13;
&#13;
## 读取labels&#13;
&#13;
&gt; 数据格式&#13;
&#13;
```&#13;
[offset] [type]          [value]          [description]&#13;
0000     32 bit integer  0x00000801(2049) magic number (MSB first)&#13;
0004     32 bit integer  60000            number of items&#13;
0008     unsigned byte   ??               label&#13;
0009     unsigned byte   ??               label&#13;
........&#13;
xxxx     unsigned byte   ??               label&#13;
The labels values are 0 to 9.&#13;
```&#13;
&#13;
```c&#13;
void read_labels(const char *fname, unsigned char **labels, int *count) {&#13;
	FILE *file = fopen(fname, 'rb');&#13;
	if (file == NULL) {&#13;
		exit(1);&#13;
	}&#13;
	printf('open file [%s] success.\n', fname);&#13;
&#13;
	int magic = 0;&#13;
	fread(&amp;magic, sizeof(int), 1, file);&#13;
	fread(count, sizeof(int), 1, file);&#13;
	*count = __builtin_bswap32(*count);&#13;
&#13;
	printf('labels count. %d.\n', *count);&#13;
&#13;
	*labels = malloc(*count);&#13;
&#13;
	fread(*labels, sizeof(unsigned char), *count, file);&#13;
	fclose(file);&#13;
}&#13;
```&#13;
&#13;
# 定义网络 &#13;
&#13;
## 结构 &#13;
&#13;
```c&#13;
typedef struct {&#13;
	float *weights; // 权重 &#13;
	float *biases;  // 偏差&#13;
	int input_size;&#13;
	int output_size;&#13;
} Layer;&#13;
&#13;
typedef struct {&#13;
	Layer hidden;&#13;
	Layer output;&#13;
} Network;&#13;
```&#13;
&#13;
## 初始化 &#13;
&#13;
&gt; 神经网络的训练过程本质是对权重参数的更新，那么这个权重的初始值是什么?&#13;
&gt; 首先不能是0，因为 $y = wx +b $ 中，如果w = 0，那么所有神经元的输出是相同的 反向传播过程的梯度也是相同的 &#13;
&#13;
**He initialization**&#13;
&#13;
&gt; 思想是将权重初始化为满足一个标准正态分布&#13;
&#13;
```c&#13;
void init_layer(Layer *layer, int in_size, int out_size) {&#13;
	int n = in_size * out_size;&#13;
	float scale = sqrtf(2.0f / in_size);&#13;
&#13;
	layer-&gt;input_size = in_size;&#13;
	layer-&gt;output_size = out_size;&#13;
	layer-&gt;weights = malloc(n * sizeof(float));&#13;
	layer-&gt;biases = calloc(out_size, sizeof(float));&#13;
&#13;
	for (int i = 0; i &lt; n; i++)&#13;
		layer-&gt;weights[i] = ((float)rand() / RAND_MAX - 0.5f) * 2 * scale;&#13;
}&#13;
```&#13;
&#13;
# 前向传播&#13;
&#13;
&gt; 即给定输入 计算神经网络输出的过程 &#13;
&gt; 步骤: 将输入数据移动到网络的每一层，应用线形变换和激活函数，产生输出&#13;
&#13;
```c&#13;
void forward(Layer *layer, float *input, float *output) {&#13;
	for (int i = 0; i &lt; layer-&gt;output_size; i++) {&#13;
		output[i] = layer-&gt;biases[i];&#13;
		for (int j = 0; j &lt; layer-&gt;input_size; j++)&#13;
			output[i] += input[j] * layer-&gt;weights[j * layer-&gt;output_size + i];&#13;
	}&#13;
}&#13;
&#13;
void relu(float *hidden, int size) {&#13;
	for (int i = 0; i &lt; size; i++) {&#13;
		hidden[i] = hidden[i] &gt; 0 ? hidden[i] : 0;&#13;
	}&#13;
}&#13;
&#13;
void softmax(float *input, int size) {&#13;
	float max = input[0], sum = 0;&#13;
	for (int i = 1; i &lt; size; i++) {&#13;
		if (input[i] &gt; max) max = input[i];&#13;
	}&#13;
	for (int i = 0; i &lt; size; i++) {&#13;
		input[i] = expf(input[i] - max);&#13;
		sum += input[i];&#13;
	}&#13;
	for (int i = 0; i &lt; size; i++) {&#13;
		input[i] /= sum;&#13;
	}&#13;
}&#13;
```&#13;
&#13;
# 反向传播 &#13;
&#13;
&gt; 根据梯度更新权重和偏差&#13;
&gt; 步骤:&#13;
&#13;
```c&#13;
void backward(Layer *layer, float *input, float *output_grad, float *input_grad, float lr) {&#13;
	for (int i = 0; i &lt; layer-&gt;output_size; i++) {&#13;
		for (int j = 0; j &lt; layer-&gt;input_size; j++) {&#13;
			int idx = j * layer-&gt;output_size + i;&#13;
			// 相对于权重的损失梯度等于相对于输出的损失梯度乘以输入值&#13;
			float grad = output_grad[i] * input[j];&#13;
			// 新的权重 = 旧的权重 减去 学习率乘以相对于权重的损失梯度&#13;
			layer-&gt;weights[idx] -= lr * grad;&#13;
			//	相对于输入 j 的损失梯度是所有输出的（关于每个输出 i 的损失梯度乘以将输入 j 连接到输出 i 的权重）的总和&#13;
			if (input_grad) {&#13;
				input_grad[j] += output_grad[i] * layer-&gt;weights[idx];&#13;
			}&#13;
		}&#13;
&#13;
		// 新偏差等于旧偏差减去学习率乘以相对于偏差的损失梯度。</description><guid isPermaLink="true">https://0x1042.github.io//post/34.html</guid><pubDate>Sat, 21 Sep 2024 17:00:28 +0000</pubDate></item><item><title>ml 扫盲三</title><link>https://0x1042.github.io//post/33.html</link><description># 神经网络搭建步骤 &#13;
&#13;
- [神经网络搭建步骤](#神经网络搭建步骤)&#13;
  - [加载数据](#加载数据)&#13;
  - [定义网络模型](#定义网络模型)&#13;
  - [定义损失函数](#定义损失函数)&#13;
  - [定义优化器](#定义优化器)&#13;
  - [训练](#训练)&#13;
  - [测试](#测试)&#13;
  - [保存模型](#保存模型)&#13;
&#13;
&#13;
```mermaid&#13;
flowchart LR&#13;
&#13;
数据--&gt;网络结构&#13;
网络结构--&gt;损失函数&#13;
损失函数--&gt;优化器&#13;
优化器--&gt;训练&#13;
训练--&gt;测试&#13;
测试--&gt;导出模型&#13;
```&#13;
&#13;
## 加载数据&#13;
&#13;
```python&#13;
import torch&#13;
from torchvision import datasets, transforms&#13;
import torch.optim as optim &#13;
import torch.nn as nn&#13;
import torch.utils.data as data&#13;
&#13;
train_data = datasets.MNIST(root='data/mnist', train=True, transform=transforms.ToTensor(), download=True)&#13;
test_data = datasets.MNIST(root='data/mnist', train=False, transform=transforms.ToTensor(), download=True)&#13;
```&#13;
&#13;
&gt; 由于数据规模，不可能将所有的数据加载一次训练。</description><guid isPermaLink="true">https://0x1042.github.io//post/33.html</guid><pubDate>Tue, 17 Sep 2024 06:21:07 +0000</pubDate></item><item><title>汇编(1)</title><link>https://0x1042.github.io//post/32.html</link><description>&#13;
- [基本特征](#基本特征)&#13;
- [`hello world`](#hello-world)&#13;
- [寻址](#寻址)&#13;
  - [寄存器寻址](#寄存器寻址)&#13;
  - [立即寻址](#立即寻址)&#13;
  - [间接(内存)寻址](#间接内存寻址)&#13;
  - [索引寻址](#索引寻址)&#13;
  - [基址寻址](#基址寻址)&#13;
- [op](#op)&#13;
&#13;
&gt; `gdb` 默认的汇编风格是`AT&amp;T` &#13;
&#13;
# 基本特征 &#13;
&#13;
- 源操作数在前，目的操作数在后 &#13;
- 寄存器以`%`开头  &#13;
- 立即数以 `$`开头，即常量数&#13;
&#13;
&#13;
# `hello world`&#13;
&#13;
```asm&#13;
movl %eax,%ebx ; 把寄存器eax的值移动到ebx寄存器&#13;
```&#13;
&#13;
```asm&#13;
movl $5, %eax    ; 把立即数 5 移动到 EAX&#13;
```&#13;
&#13;
# 寻址&#13;
&#13;
```asm &#13;
&#13;
; 地址或偏移(%基址或偏移量寄存器,%索引寄存器,比例因子)&#13;
&#13;
; dst = 地址或偏移 + %索引寄存器 * 比例因子&#13;
&#13;
```&#13;
&#13;
## 寄存器寻址&#13;
&#13;
```asm&#13;
mov    %rax,%rdi ;把寄存器rax的值移动到rdi寄存器&#13;
&#13;
; 与内存无关&#13;
; 如果rax = 0x12345678&#13;
; 那么这条指令执行结束后，rdi的值也是 0x12345678&#13;
```&#13;
&#13;
## 立即寻址&#13;
&#13;
```asm&#13;
mov    $0xa,%esi&#13;
; $ 表示立即数 ，0xa 即十进制的10&#13;
; 执行结束后，寄存器esi的值就是10&#13;
```&#13;
&#13;
## 间接(内存)寻址 &#13;
&#13;
```asm&#13;
mov     (%rip),%rdi&#13;
; rip寄存器存放的是一个内存地址&#13;
; (%rip) 表示该内存地址指向的数据&#13;
; 上述指令的是意思是 将 rip寄存器所指向的内存中的值加载到rdi寄存器中 &#13;
```&#13;
&#13;
## 索引寻址&#13;
&#13;
```asm&#13;
subl -0x20(%ebx, %ecx, 0x4), %eax&#13;
&#13;
; eax = %ebx + (%ecx * 0x4) - 0x20&#13;
```&#13;
&#13;
## 基址寻址&#13;
&#13;
```asm&#13;
movsd  -0x18(%rbp),%xmm0&#13;
; 从 (rbp)地址-0x18 的内存地址读取数据，移动到xmm0 寄存器 &#13;
&#13;
mov    0x2db6(%rip),%rdi&#13;
; 从 (rip)地址 + 0x2db6 的内存地址读取数据，移动到rdi 寄存器&#13;
```&#13;
&#13;
# op&#13;
&#13;
&gt; 后缀表示操作数的长度&#13;
&#13;
| 后缀 | 说明            | 长度(字节) | C声明                     |&#13;
| ---- | --------------- | ---------- | ------------------------- |&#13;
| `b`  | `byte`          | **1**      | `char c = 'z';`           |&#13;
| `w`  | `word`          | **2**      | `short len = 3;`          |&#13;
| `l`  | `long`          | **4**      | `int32_t val = 1024;`     |&#13;
| `q`  | `quad`          | **8**      | `uint64_t id = 42;`       |&#13;
| `sd` | `Scalar Double` | **8**      | `double p = 3.141592653;` |。</description><guid isPermaLink="true">https://0x1042.github.io//post/32.html</guid><pubDate>Sat, 07 Sep 2024 06:21:44 +0000</pubDate></item><item><title>Rust调用C++ 32bit lib(1)</title><link>https://0x1042.github.io//post/31.html</link><description># c兼容&#13;
&#13;
```c++&#13;
#pragma once&#13;
&#13;
#ifdef __cplusplus&#13;
&#13;
extern 'C' {&#13;
#endif&#13;
void parse_entry(char *fname, int level);&#13;
&#13;
#ifdef __cplusplus&#13;
}&#13;
&#13;
#endif&#13;
```&#13;
&#13;
# cmake &#13;
&#13;
```cmake&#13;
set(CMAKE_POSITION_INDEPENDENT_CODE ON)&#13;
set(CMAKE_INTERPROCEDURAL_OPTIMIZATION TRUE)&#13;
&#13;
add_library(parse STATIC ${LIBSRC})&#13;
```&#13;
&#13;
&#13;
# rust 32 bit target&#13;
&#13;
```&#13;
&#13;
# add target&#13;
rustup target add i686-unknown-linux-gnu&#13;
&#13;
# 编译&#13;
cargo build --target=i686-unknown-linux-gnu&#13;
```&#13;
&#13;
# 导入&#13;
&#13;
## 依赖&#13;
&#13;
```rust&#13;
[build-dependencies]&#13;
cc = '1.0'&#13;
```&#13;
&#13;
## 代码 &#13;
&#13;
```rust &#13;
#[link(name = 'parse', kind = 'static')]&#13;
extern 'C' {&#13;
    fn parsev2() -&gt; c_void;&#13;
}&#13;
```&#13;
&#13;
## build.rs&#13;
&#13;
```rust&#13;
fn main() {&#13;
    println!('cargo:rustc-link-search=native=reallibpath');&#13;
}&#13;
&#13;
```&#13;
&#13;
## 编译失败 &#13;
&lt;img width='1876' alt='image' src='https://github.com/user-attachments/assets/e2121d3b-f342-490f-bf15-e19141aaae35'&gt;&#13;
&#13;
```&#13;
undefined reference to std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, &#13;
std::allocator&lt;char&gt; &gt;::rfind(char, unsigned int) const&#13;
```&#13;
&#13;
&gt; 更新build.rs&#13;
&#13;
```rust&#13;
// build.sh &#13;
&#13;
fn main() {&#13;
    // 链接c++标准库和gcc动态库 &#13;
    println!('cargo:rustc-link-lib=dylib=stdc++');&#13;
    println!('cargo:rustc-link-lib=dylib=gcc_s');&#13;
}&#13;
```&#13;
&#13;
&gt; 或者全静态编译lib&#13;
&#13;
```cmake&#13;
target_link_libraries(parse&#13;
    -static-libstdc++&#13;
    -static-libgcc&#13;
)&#13;
```&#13;
&#13;
。</description><guid isPermaLink="true">https://0x1042.github.io//post/31.html</guid><pubDate>Sun, 25 Aug 2024 09:01:17 +0000</pubDate></item><item><title>gcc 32位编译</title><link>https://0x1042.github.io//post/30.html</link><description># 32位编译 m32 &#13;
&#13;
```&#13;
set(CMAKE_C_FLAGS '${CMAKE_C_FLAGS} -m32')&#13;
set(CMAKE_CXX_FLAGS '${CMAKE_CXX_FLAGS} -m32')&#13;
```&#13;
&#13;
# 安装32位lib &#13;
&#13;
```&#13;
sudo apt install gcc-multilib g++-multilib libc6-dev-i386 -y&#13;
```&#13;
&#13;
# 开启O3&#13;
&#13;
&gt; `cmake` 默认`RelWithDebInfo` 模式是`O2`&#13;
&#13;
```cmake&#13;
set(CMAKE_C_FLAGS_RELWITHDEBINFO&#13;
    '-O3 -g'&#13;
    CACHE STRING&#13;
          'Flags used by the C compiler during release builds with debug info.'&#13;
          FORCE)&#13;
set(CMAKE_CXX_FLAGS_RELWITHDEBINFO&#13;
    '-O3 -g'&#13;
    CACHE&#13;
      STRING&#13;
      'Flags used by the C++ compiler during release builds with debug info.'&#13;
      FORCE)&#13;
```&#13;
 &#13;
&#13;
&#13;
。</description><guid isPermaLink="true">https://0x1042.github.io//post/30.html</guid><pubDate>Sun, 25 Aug 2024 07:30:57 +0000</pubDate></item><item><title>debian/ubuntu基本使用</title><link>https://0x1042.github.io//post/29.html</link><description># apt update&#13;
&#13;
## warning&#13;
&#13;
```&#13;
 sudo apt update&#13;
W: https://mirrors.tuna.tsinghua.edu.cn/llvm-apt/jammy/dists/llvm-toolchain-jammy-18/InRelease: &#13;
Key is stored in legacy trusted.gpg keyring (/etc/apt/trusted.gpg),&#13;
see the DEPRECATION section in apt-key(8) for details.&#13;
```&#13;
&#13;
&#13;
## 处理&#13;
&#13;
- 找到对应的key &#13;
```&#13;
sudo apt-key list&#13;
&#13;
# 找到与warning相关的key&#13;
# 这里是llvm的 pub line 最后8个字符 &#13;
&#13;
```&#13;
&#13;
- 导入&#13;
&#13;
```&#13;
sudo apt-key export AF4F7421 | sudo gpg --dearmour -o /etc/apt/trusted.gpg.d/llvm.gpg&#13;
```&#13;
&#13;
- 重新update &#13;
&#13;
# 清理无效软连接&#13;
&#13;
```shell&#13;
&#13;
find . -xtype l&#13;
&#13;
find /path -xtype l&#13;
```&#13;
&#13;
&#13;
。</description><guid isPermaLink="true">https://0x1042.github.io//post/29.html</guid><pubDate>Sat, 24 Aug 2024 08:24:42 +0000</pubDate></item><item><title>sock5 &amp;&amp; http proxy in go</title><link>https://0x1042.github.io//post/28.html</link><description># listen&#13;
&#13;
```go&#13;
type Stream struct {&#13;
	r *bufio.Reader&#13;
	net.Conn&#13;
}&#13;
&#13;
func newStream(c net.Conn) *Stream {&#13;
	return &amp;Stream{bufio.NewReader(c), c}&#13;
}&#13;
&#13;
func (b *Stream) Peek(n int) ([]byte, error) {&#13;
	return b.r.Peek(n)&#13;
}&#13;
&#13;
func (b *Stream) Read(p []byte) (int, error) {&#13;
	return b.r.Read(p)&#13;
}&#13;
&#13;
func (b *Stream) Line() (string, error) {&#13;
	line, _, err := b.r.ReadLine()&#13;
	return string(line), err&#13;
}&#13;
&#13;
func readBe[T any](r io.Reader, data T) (err error) {&#13;
	if err = binary.Read(r, binary.BigEndian, data); err != nil {&#13;
		log.Error().Err(err).Msg('readBe error')&#13;
	}&#13;
	return&#13;
}&#13;
&#13;
func writeBe[T any](r io.Writer, data T) (err error) {&#13;
	if err = binary.Write(r, binary.BigEndian, data); err != nil {&#13;
		log.Error().Err(err).Msg('writeBe error')&#13;
	}&#13;
	return&#13;
}&#13;
&#13;
func listen(option Option) error {&#13;
	var lc net.ListenConfig&#13;
	lc.SetMultipathTCP(true)&#13;
	lc.Control = func(_, _ string, c syscall.RawConn) error {&#13;
		var err error&#13;
		_ = c.Control(func(fd uintptr) {&#13;
			if option.nodelay {&#13;
				err = unix.SetsockoptInt(int(fd), unix.IPPROTO_TCP, unix.TCP_NODELAY, 1)&#13;
			}&#13;
			if option.fastOpen {&#13;
				err = unix.SetsockoptInt(int(fd), unix.IPPROTO_TCP, unix.TCP_FASTOPEN, 1)&#13;
			}&#13;
			if option.reuseAddr {&#13;
				err = unix.SetsockoptInt(int(fd), unix.SOL_SOCKET, unix.SO_REUSEADDR, 1)&#13;
				err = unix.SetsockoptInt(int(fd), unix.SOL_SOCKET, unix.SO_REUSEPORT, 1)&#13;
			}&#13;
		})&#13;
		return err&#13;
	}&#13;
	ln, err := lc.Listen(context.Background(), 'tcp', option.addr)&#13;
	if err != nil {&#13;
		return err&#13;
	}&#13;
&#13;
	log.Info().Str('addr', option.addr).Msg('server start')&#13;
&#13;
	for {&#13;
		conn, err := ln.Accept()&#13;
		if err != nil {&#13;
			log.Error().Err(err).Msg('accept error')&#13;
			break&#13;
		}&#13;
		stream := newStream(conn)&#13;
&#13;
		peek, _ := stream.Peek(1)&#13;
		log.Trace().Uint8('type', peek[0]).Str('from', conn.LocalAddr().String()).Msg('incomeing request')&#13;
		if peek[0] == 0x05 {&#13;
			go serveSocks(stream)&#13;
		} else {&#13;
			go serveHTTP(stream)&#13;
		}&#13;
	}&#13;
	return nil&#13;
}&#13;
&#13;
```&#13;
&#13;
&#13;
# http&#13;
&#13;
```go&#13;
&#13;
var SUCCESS = []byte('HTTP/1.1 200 Connection Established\r\n\r\n')&#13;
&#13;
const (&#13;
	CONNECT  = 'CONNECT'&#13;
	LF       = '\r\n'&#13;
	PORT     = '80'&#13;
	HEADLEN  = 5&#13;
	HEADSIZE = 512&#13;
)&#13;
&#13;
type Req struct {&#13;
	Method string&#13;
	Host   string&#13;
	Port   string&#13;
}&#13;
&#13;
func newReq(line []string) *Req {&#13;
	req := new(Req)&#13;
	req.Port = PORT&#13;
	// first&#13;
	{&#13;
		// CONNECT www.google.com:443 HTTP/1.1\r\n&#13;
		// GET http://www.google.com/ HTTP/1.1\r\n&#13;
		tmps := strings.Split(line[0], ' ')&#13;
		req.Method = tmps[0]&#13;
	}&#13;
&#13;
	// second&#13;
	{&#13;
&#13;
		// Host: www.google.com:443&#13;
		// Host: www.google.com&#13;
		tmps := strings.Split(line[1], ':')&#13;
		req.Host = strings.TrimSpace(tmps[1])&#13;
		if len(tmps) == 3 {&#13;
			req.Port = strings.TrimSpace(tmps[2])&#13;
		}&#13;
	}&#13;
	return req&#13;
}&#13;
&#13;
func serveHTTP(stream *Stream) {&#13;
	headers := make([]string, 0, HEADLEN)&#13;
	for {&#13;
		line, err := stream.Line()&#13;
		if err != nil {&#13;
			log.Error().Err(err).Msg('read line error')&#13;
			return&#13;
		}&#13;
&#13;
		if line == LF || len(line) == 0 {&#13;
			break&#13;
		}&#13;
		headers = append(headers, line)&#13;
	}&#13;
&#13;
	req := newReq(headers)&#13;
	remoteAddr := net.JoinHostPort(req.Host, req.Port)&#13;
&#13;
	remote, err := net.Dial('tcp', remoteAddr)&#13;
	if err != nil {&#13;
		log.Error().Err(err).Str('to', remoteAddr).Msg('connect error')&#13;
		return&#13;
	}&#13;
&#13;
	if req.Method == CONNECT {&#13;
		_, _ = stream.Write(SUCCESS)&#13;
	} else {&#13;
		buf := bytes.Buffer{}&#13;
		buf.Grow(HEADSIZE)&#13;
		for _, line := range headers {&#13;
			if strings.HasPrefix(line, 'Proxy') {&#13;
				continue&#13;
			}&#13;
			buf.WriteString(line)&#13;
			buf.WriteString(LF)&#13;
		}&#13;
		buf.WriteString(LF)&#13;
		_, _ = remote.Write(buf.Bytes())&#13;
	}&#13;
	relay(stream, remote)&#13;
}&#13;
&#13;
```&#13;
&#13;
# socks5&#13;
&#13;
```go&#13;
&#13;
var (&#13;
	SUC    = []byte{0x05, 0x00}&#13;
	SusRep = []byte{0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}&#13;
	errRep = []byte{0x05, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}&#13;
)&#13;
&#13;
func serveSocks(stream *Stream) {&#13;
	header := make([]byte, 2)&#13;
	_ = readBe(stream, &amp;header)&#13;
&#13;
	nmeth := header[1]&#13;
&#13;
	methods := make([]byte, int(nmeth))&#13;
	_ = readBe(stream, &amp;methods)&#13;
&#13;
	_ = writeBe(stream, SUC)&#13;
&#13;
	// read request&#13;
&#13;
	request := make([]byte, 4)&#13;
	_ = readBe(stream, &amp;request)&#13;
&#13;
	adtp := request[3]&#13;
&#13;
	var host string&#13;
&#13;
	switch adtp {&#13;
	case 1:&#13;
		hostBuf := make([]byte, net.IPv4len)&#13;
		_ = readBe(stream, &amp;hostBuf)&#13;
		host = net.IP(hostBuf).String()&#13;
	case 3:&#13;
		hostBuf := make([]byte, net.IPv6len)&#13;
		_ = readBe(stream, &amp;hostBuf)&#13;
		host = net.IP(hostBuf).String()&#13;
	default:&#13;
		var length uint8&#13;
		_ = readBe(stream, &amp;length)&#13;
		buf := make([]byte, length)&#13;
		_ = readBe(stream, &amp;buf)&#13;
		host = string(buf)&#13;
	}&#13;
&#13;
	portBuf := make([]byte, 2)&#13;
	_ = readBe(stream, &amp;portBuf)&#13;
	port := binary.BigEndian.Uint16(portBuf)&#13;
&#13;
	targetAddr := net.JoinHostPort(host, strconv.FormatInt(int64(port), 10))&#13;
&#13;
	remote, err := net.Dial('tcp', targetAddr)&#13;
	if err != nil {&#13;
		log.Error().Err(err).Str('remote', targetAddr).Msg('connect error')&#13;
		_, _ = stream.Write(errRep)&#13;
		return&#13;
	}&#13;
	_, _ = stream.Write(SusRep)&#13;
	relay(stream, remote)&#13;
}&#13;
&#13;
```&#13;
&#13;
# relay&#13;
&#13;
```go&#13;
type Resp struct {&#13;
	len  int64&#13;
	err  error&#13;
	from net.Addr&#13;
	to   net.Addr&#13;
}&#13;
&#13;
func relay(from, to net.Conn) {&#13;
	defer func(from, to net.Conn) {&#13;
		_ = from.Close()&#13;
		_ = to.Close()&#13;
	}(from, to)&#13;
&#13;
	channel := make(chan Resp, 2)&#13;
&#13;
	go func(dst, src net.Conn) {&#13;
		size, err := io.Copy(dst, src)&#13;
		channel &lt;- Resp{len: size, err: err, from: src.RemoteAddr(), to: dst.RemoteAddr()}&#13;
	}(from, to)&#13;
&#13;
	go func(dst, src net.Conn) {&#13;
		size, err := io.Copy(dst, src)&#13;
		channel &lt;- Resp{len: size, err: err, from: src.RemoteAddr(), to: dst.RemoteAddr()}&#13;
	}(to, from)&#13;
&#13;
	for resp := range channel {&#13;
		if resp.err != nil &amp;&amp; resp.err != io.EOF {&#13;
			log.Error().Err(resp.err).Str('from', resp.from.String()).Str('to', resp.to.String()).Msg('relay error')&#13;
		} else {&#13;
			log.Info().Str('from', resp.from.String()).Str('to', resp.to.String()).Int64('transfer', resp.len).Msg('relay success')&#13;
		}&#13;
	}&#13;
}&#13;
&#13;
```&#13;
。</description><guid isPermaLink="true">https://0x1042.github.io//post/28.html</guid><pubDate>Sat, 13 Jul 2024 16:29:46 +0000</pubDate></item><item><title>sock5 &amp;&amp; http proxy in rust</title><link>https://0x1042.github.io//post/27.html</link><description># listen&#13;
&#13;
```rust&#13;
pub async fn listen(addr: &amp;str) -&gt; anyhow::Result&lt;()&gt; {&#13;
    let mut endpoint = addr.to_owned();&#13;
    let info: Vec&lt;_&gt; = addr.split(':').collect();&#13;
    if info[0].is_empty() {&#13;
        endpoint = format!('0.0.0.0:{}', info[1]);&#13;
    }&#13;
    let ln = tokio::net::TcpListener::bind(&amp;endpoint).await?;&#13;
    info!('server start. auto://{}', &amp;endpoint);&#13;
    loop {&#13;
        let (incoming, peer) = ln.accept().await?;&#13;
        info!('incoming request {:?}', peer);&#13;
        tokio::spawn(async move {&#13;
            if let Err(err) = proxy(incoming).await {&#13;
                error!('proxy error. {err}');&#13;
            }&#13;
        });&#13;
    }&#13;
}&#13;
&#13;
async fn proxy(incoming: tokio::net::TcpStream) -&gt; anyhow::Result&lt;()&gt; {&#13;
    incoming.set_nodelay(true)?;&#13;
    let mut ver = vec![0; 1];&#13;
    let _ = incoming.peek(&amp;mut ver).await?;&#13;
&#13;
    if ver[0] == 0x05 {&#13;
        return socks::handle(incoming).await;&#13;
    }&#13;
    return http::handle(incoming).await;&#13;
}&#13;
&#13;
```&#13;
&#13;
# http&#13;
&#13;
```rust &#13;
const CONNECT: &amp;str = 'CONNECT';&#13;
const LF: &amp;str = '\r\n';&#13;
const SUC: &amp;str = 'HTTP/1.1 200 Connection Established\r\n\r\n';&#13;
&#13;
pub async fn handle(incoming: tokio::net::TcpStream) -&gt; anyhow::Result&lt;()&gt; {&#13;
    let start = Instant::now();&#13;
    let from = incoming.peer_addr()?;&#13;
&#13;
    let mut stream = BufReader::new(incoming);&#13;
    let mut lines = Vec::with_capacity(4);&#13;
    loop {&#13;
        let mut buf = String::new();&#13;
        stream.read_line(&amp;mut buf).await?;&#13;
        if buf.eq(LF) || buf.is_empty() {&#13;
            break;&#13;
        }&#13;
        lines.push(buf);&#13;
    }&#13;
&#13;
    let reqlines = lines.join('');&#13;
    let mut headers = [httparse::EMPTY_HEADER; 4];&#13;
    let mut req = httparse::Request::new(&amp;mut headers);&#13;
    req.parse(reqlines.as_bytes())?;&#13;
&#13;
    let mut host = String::new();&#13;
    for ele in req.headers.iter() {&#13;
        if ele.name == 'Host' {&#13;
            host = String::from_utf8(ele.value.to_vec()).unwrap();&#13;
            break;&#13;
        }&#13;
    }&#13;
&#13;
    let mut endpoint = host;&#13;
&#13;
    if !endpoint.contains(':') {&#13;
        endpoint = format!('{}:80', endpoint);&#13;
    }&#13;
&#13;
    let mut remote = tokio::net::TcpStream::connect(&amp;endpoint).await?;&#13;
&#13;
    info!('connect to {} succsss. ', &amp;endpoint);&#13;
&#13;
    if req.method.unwrap() == CONNECT {&#13;
        stream.write(SUC.as_bytes()).await?;&#13;
    } else {&#13;
        let mut reqlines = String::new();&#13;
        reqlines.reserve(256);&#13;
        for line in lines.iter() {&#13;
            if line.starts_with('Proxy-Connection') {&#13;
                continue;&#13;
            }&#13;
            reqlines.push_str(line);&#13;
        }&#13;
        reqlines.push_str(LF);&#13;
        remote.write(reqlines.as_bytes()).await?;&#13;
    }&#13;
&#13;
    let (rl, wl) = tokio::io::copy_bidirectional(&amp;mut stream, &amp;mut remote).await?;&#13;
    info!(&#13;
        'http tunnel {} &lt;-&gt; {} write {} read {} cost {:?}',&#13;
        from,&#13;
        &amp;endpoint,&#13;
        rl,&#13;
        wl,&#13;
        start.elapsed()&#13;
    );&#13;
    Ok(())&#13;
}&#13;
```&#13;
&#13;
# socks5  &#13;
&#13;
```rust &#13;
#[derive(Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]&#13;
pub enum Addr {&#13;
    /// Socket address (IP Address)&#13;
    SocketAddress(SocketAddr),&#13;
    /// Domain name address&#13;
    DomainNameAddress(String, u16),&#13;
}&#13;
&#13;
impl Addr {&#13;
    async fn from_reader&lt;R&gt;(adtype: u8, reader: &amp;mut R) -&gt; anyhow::Result&lt;Addr&gt;&#13;
    where&#13;
        R: AsyncRead + Unpin,&#13;
    {&#13;
        if adtype == 0x01 {&#13;
            let mut buf = [0u8; 6];&#13;
            let _ = reader.read_exact(&amp;mut buf).await?;&#13;
&#13;
            let v4addr = Ipv4Addr::new(buf[0], buf[1], buf[2], buf[3]);&#13;
            let port = u16::from_be_bytes([buf[4], buf[5]]);&#13;
            return Ok(Addr::SocketAddress(SocketAddr::V4(SocketAddrV4::new(&#13;
                v4addr, port,&#13;
            ))));&#13;
        }&#13;
&#13;
        if adtype == 0x04 {&#13;
            let mut buf = [0u16; 9];&#13;
&#13;
            let bytes_buf = unsafe { slice::from_raw_parts_mut(buf.as_mut_ptr() as *mut _, 18) };&#13;
            let _ = reader.read_exact(bytes_buf).await?;&#13;
&#13;
            let v6addr = Ipv6Addr::new(&#13;
                u16::from_be(buf[0]),&#13;
                u16::from_be(buf[1]),&#13;
                u16::from_be(buf[2]),&#13;
                u16::from_be(buf[3]),&#13;
                u16::from_be(buf[4]),&#13;
                u16::from_be(buf[5]),&#13;
                u16::from_be(buf[6]),&#13;
                u16::from_be(buf[7]),&#13;
            );&#13;
            let port = u16::from_be(buf[8]);&#13;
&#13;
            return Ok(Addr::SocketAddress(SocketAddr::V6(SocketAddrV6::new(&#13;
                v6addr, port, 0, 0,&#13;
            ))));&#13;
        }&#13;
        let mut length_buf = [0u8; 1];&#13;
        let _ = reader.read_exact(&amp;mut length_buf).await?;&#13;
        let length = length_buf[0] as usize;&#13;
&#13;
        // Len(Domain) + Len(Port)&#13;
        let buf_length = length + 2;&#13;
&#13;
        let mut raw_addr = vec![0u8; buf_length];&#13;
        let _ = reader.read_exact(&amp;mut raw_addr).await?;&#13;
&#13;
        let raw_port = &amp;raw_addr[length..];&#13;
        let port = u16::from_be_bytes([raw_port[0], raw_port[1]]);&#13;
&#13;
        raw_addr.truncate(length);&#13;
&#13;
        let addr = String::from_utf8(raw_addr).unwrap();&#13;
&#13;
        Ok(Addr::DomainNameAddress(addr, port))&#13;
    }&#13;
}&#13;
&#13;
// https://datatracker.ietf.org/doc/html/rfc1928&#13;
// https://datatracker.ietf.org/doc/html/rfc1929&#13;
pub async fn handle(mut incoming: tokio::net::TcpStream) -&gt; anyhow::Result&lt;()&gt; {&#13;
    let start = Instant::now();&#13;
&#13;
    // step1 handshake&#13;
&#13;
    //    +----+----------+----------+&#13;
    //    |VER | NMETHODS | METHODS  |&#13;
    //    +----+----------+----------+&#13;
    //    | 1  |    1     | 1 to 255 |&#13;
    //    +----+----------+----------+&#13;
&#13;
    {&#13;
        let mut buf = vec![0; 2];&#13;
        let _ = incoming.read_exact(&amp;mut buf).await?;&#13;
        let ver = buf[0];&#13;
        let nmet = buf[1];&#13;
        if ver != 0x05 {&#13;
            return Err(anyhow::anyhow!('unsupport version'));&#13;
        }&#13;
&#13;
        let mut methods = vec![0u8; nmet as usize];&#13;
        let _ = incoming.read_exact(&amp;mut methods).await?;&#13;
&#13;
        for method in methods.iter() {&#13;
            debug!('method is {:?}', *method);&#13;
&#13;
            // if *method == 0x00 {&#13;
            //     let mut buffer = vec![0x05, 0x00];&#13;
            //     incoming.write(&amp;mut buffer).await?;&#13;
            // }&#13;
&#13;
            if *method == 0x02 {&#13;
                let mut buffer = vec![0x05, 0x02];&#13;
                incoming.write(&amp;mut buffer).await?;&#13;
                let ver = incoming.read_u8().await?;&#13;
&#13;
                debug!('ver is {}', ver);&#13;
&#13;
                // assert ver = 1&#13;
&#13;
                let ulen = incoming.read_u8().await?;&#13;
                let mut namebuf = vec![0u8; ulen as usize];&#13;
                let _ = incoming.read_exact(&amp;mut namebuf).await?;&#13;
&#13;
                let plen = incoming.read_u8().await?;&#13;
                let mut pbuf = vec![0u8; plen as usize];&#13;
                let _ = incoming.read_exact(&amp;mut pbuf).await?;&#13;
&#13;
                // todo check&#13;
&#13;
                info!(&#13;
                    'user is {} passwd is {}',&#13;
                    String::from_utf8(namebuf).unwrap(),&#13;
                    String::from_utf8(pbuf).unwrap()&#13;
                );&#13;
                let mut authreply = vec![0x01, 0x00];&#13;
                incoming.write(&amp;mut authreply).await?;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    // step2 read request&#13;
&#13;
    // +----+-----+-------+------+----------+----------+&#13;
    // |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |&#13;
    // +----+-----+-------+------+----------+----------+&#13;
    // | 1  |  1  | X'00' |  1   | Variable |    2     |&#13;
    // +----+-----+-------+------+----------+----------+&#13;
    //  o  IP V4 address: X'01'&#13;
    //  o  DOMAINNAME: X'03'&#13;
    //  o  IP V6 address: X'04'&#13;
    let mut buf: Vec&lt;u8&gt; = vec![0; 4];&#13;
    incoming.read_exact(&amp;mut buf).await?;&#13;
&#13;
    // todo check ver and cmd&#13;
    let adtype = buf[3];&#13;
    let addr = Addr::from_reader(adtype, &amp;mut incoming).await?;&#13;
&#13;
    let mut remote = match addr {&#13;
        Addr::SocketAddress(sock) =&gt; tokio::net::TcpStream::connect(sock).await?,&#13;
        Addr::DomainNameAddress(domain, port) =&gt; {&#13;
            tokio::net::TcpStream::connect((domain, port)).await?&#13;
        }&#13;
    };&#13;
&#13;
    let mut reply = vec![0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];&#13;
    incoming.write(&amp;mut reply).await?;&#13;
&#13;
    let from = incoming.peer_addr()?;&#13;
    // let tunnel = incoming.local_addr()?;&#13;
    let target = remote.peer_addr()?;&#13;
&#13;
    let (rl, wl) = tokio::io::copy_bidirectional(&amp;mut incoming, &amp;mut remote).await?;&#13;
&#13;
    info!(&#13;
        'TCP tunnel {} &lt;-&gt; {} write {} read {} cost {:?}',&#13;
        from,&#13;
        target,&#13;
        rl,&#13;
        wl,&#13;
        start.elapsed()&#13;
    );&#13;
    Ok(())&#13;
}&#13;
&#13;
```。</description><guid isPermaLink="true">https://0x1042.github.io//post/27.html</guid><pubDate>Sat, 13 Jul 2024 16:25:58 +0000</pubDate></item><item><title>sock5 &amp;&amp; http proxy in asio</title><link>https://0x1042.github.io//post/26.html</link><description># listen&#13;
&#13;
```c++&#13;
asio::awaitable&lt;void&gt; listener(asio::io_context &amp;io_context,&#13;
                               unsigned short port) {&#13;
  auto endpoint = asio::ip::tcp::endpoint(asio::ip::tcp::v4(), port);&#13;
  spdlog::info('server listen at {}:{}', endpoint.address().to_string(),&#13;
               endpoint.port());&#13;
&#13;
  asio::ip::tcp::acceptor acceptor(io_context, endpoint);&#13;
  for (;;) {&#13;
    asio::ip::tcp::socket socket =&#13;
        co_await acceptor.async_accept(asio::use_awaitable);&#13;
&#13;
    std::array&lt;std::byte, 1&gt; data{};&#13;
    socket.receive(asio::buffer(data), asio::socket_base::message_peek);&#13;
    const auto &amp;endpoint = socket.remote_endpoint();&#13;
    spdlog::info('incoming request. {}:{}', endpoint.address().to_string(),&#13;
                 endpoint.port());&#13;
&#13;
    if (std::to_integer&lt;uint8_t&gt;(data.at(0)) == 0x05) {&#13;
      asio::co_spawn(io_context, socks::handle(std::move(socket)),&#13;
                     asio::detached);&#13;
    } else {&#13;
      asio::co_spawn(io_context, http::handle(std::move(socket)),&#13;
                     asio::detached);&#13;
    }&#13;
  }&#13;
```&#13;
&#13;
# http&#13;
&#13;
```c++&#13;
asio::awaitable&lt;void&gt; handle(asio::ip::tcp::socket socket) {&#13;
  try {&#13;
    asio::streambuf buffer;&#13;
&#13;
    std::vector&lt;std::string&gt; lines;&#13;
    for (;;) {&#13;
      std::size_t n = co_await asio::async_read_until(socket, buffer, '\r\n',&#13;
                                                      asio::use_awaitable);&#13;
      auto bufs = buffer.data();&#13;
      std::string line(asio::buffers_begin(bufs),&#13;
                       asio::buffers_begin(bufs) + n);&#13;
&#13;
      if (line == '\r\n') {&#13;
        break;&#13;
      }&#13;
&#13;
      lines.push_back(std::move(line));&#13;
      buffer.consume(n);&#13;
    }&#13;
&#13;
    std::string line = replace_all(lines.at(1), '\r\n', '');&#13;
    line = replace_all(line, 'Host: ', '');&#13;
&#13;
    std::string port = '80';&#13;
&#13;
    std::vector&lt;std::string&gt; hostport = absl::StrSplit(line, ':');&#13;
    std::string host = hostport[0];&#13;
    if (hostport.size() == 2) {&#13;
      port = hostport[1];&#13;
    }&#13;
&#13;
    asio::ip::tcp::resolver resolver(socket.get_executor());&#13;
    asio::ip::tcp::resolver::results_type endpoints =&#13;
        co_await resolver.async_resolve(host, port, asio::use_awaitable);&#13;
&#13;
    asio::ip::tcp::socket remote_socket(socket.get_executor());&#13;
&#13;
    // todo http&#13;
&#13;
    co_await asio::async_connect(remote_socket, endpoints, asio::use_awaitable);&#13;
&#13;
    spdlog::info('connect to {}:{} success. ',&#13;
                 endpoints-&gt;endpoint().address().to_string(),&#13;
                 endpoints-&gt;endpoint().port());&#13;
&#13;
    const std::string &amp;response = 'HTTP/1.1 200 Connection Established\r\n\r\n';&#13;
    co_await asio::async_write(socket, asio::buffer(response),&#13;
                               asio::use_awaitable);&#13;
    co_await relay(socket, remote_socket);&#13;
&#13;
  } catch (const std::exception &amp;ex) {&#13;
    spdlog::error('run exception :{}', ex.what());&#13;
  }&#13;
}&#13;
```&#13;
&#13;
# socks5&#13;
&#13;
```c++&#13;
asio::awaitable&lt;void&gt; handle(asio::ip::tcp::socket socket) {&#13;
  try {&#13;
    // Perform SOCKS5 handshake&#13;
    std::array&lt;uint8_t, 4&gt; handshake_request{};&#13;
    co_await asio::async_read(socket, asio::buffer(handshake_request),&#13;
                              asio::use_awaitable);&#13;
&#13;
    if (handshake_request[0] != 0x05) {&#13;
      co_return; // Not SOCKS5&#13;
    }&#13;
    std::array&lt;uint8_t, 2&gt; handshake_response = {0x05, 0x00};&#13;
    co_await asio::async_write(socket, asio::buffer(handshake_response),&#13;
                               asio::use_awaitable);&#13;
&#13;
    // Read SOCKS5 request&#13;
    std::array&lt;uint8_t, 4&gt; request{};&#13;
    co_await asio::async_read(socket, asio::buffer(request),&#13;
                              asio::use_awaitable);&#13;
&#13;
    if (request[1] != 0x01) {&#13;
      co_return; // Only support CONNECT command&#13;
    }&#13;
&#13;
    // Read address and port&#13;
    std::array&lt;uint8_t, 4&gt; address{};&#13;
    co_await asio::async_read(socket, asio::buffer(address),&#13;
                              asio::use_awaitable);&#13;
&#13;
    std::array&lt;uint8_t, 2&gt; port{};&#13;
    co_await asio::async_read(socket, asio::buffer(port), asio::use_awaitable);&#13;
&#13;
    asio::ip::tcp::endpoint remote_endpoint(asio::ip::make_address_v4(address),&#13;
                                            (port[0] &lt;&lt; 8) | port[1]);&#13;
&#13;
    spdlog::info('connect to {}:{} success. ',&#13;
                 remote_endpoint.address().to_string(), remote_endpoint.port());&#13;
&#13;
    asio::ip::tcp::socket remote_socket(socket.get_executor());&#13;
&#13;
    // Connect to the remote server&#13;
    co_await remote_socket.async_connect(remote_endpoint, asio::use_awaitable);&#13;
&#13;
    // Send success response to the client&#13;
    std::array&lt;uint8_t, 10&gt; response = {&#13;
        0x05,       0x00,       0x00,       0x01,    address[0],&#13;
        address[1], address[2], address[3], port[0], port[1]};&#13;
    co_await asio::async_write(socket, asio::buffer(response),&#13;
                               asio::use_awaitable);&#13;
&#13;
    // Relay traffic between client and remote server&#13;
    co_await relay(socket, remote_socket);&#13;
  } catch (const std::exception &amp;ex) {&#13;
    spdlog::error('run exception :{}', ex.what());&#13;
  }&#13;
}&#13;
```&#13;
&#13;
# relay&#13;
&#13;
```c++&#13;
asio::awaitable&lt;void&gt; relay(asio::ip::tcp::socket &amp;from,&#13;
                            asio::ip::tcp::socket &amp;to) {&#13;
&#13;
  auto relay = [](asio::ip::tcp::socket &amp;from,&#13;
                  asio::ip::tcp::socket &amp;to) -&gt; asio::awaitable&lt;void&gt; {&#13;
    const auto &amp;from_addr = from.remote_endpoint();&#13;
    const auto &amp;to_addr = to.remote_endpoint();&#13;
    size_t cnt = 0;&#13;
    try {&#13;
      std::array&lt;std::byte, bufsize&gt; data{};&#13;
      for (;;) {&#13;
        std::size_t n = co_await from.async_read_some(asio::buffer(data),&#13;
                                                      asio::use_awaitable);&#13;
        co_await asio::async_write(to, asio::buffer(data, n),&#13;
                                   asio::use_awaitable);&#13;
        cnt += n;&#13;
      }&#13;
    } catch (...) {&#13;
      from.close();&#13;
      to.close();&#13;
    }&#13;
&#13;
    spdlog::info('{}:{} -&gt; {}:{} transfer {} bytes success. ',&#13;
                 from_addr.address().to_string(), from_addr.port(),&#13;
                 to_addr.address().to_string(), to_addr.port(), cnt);&#13;
  };&#13;
&#13;
  co_await (relay(from, to) &amp;&amp; relay(to, from));&#13;
}&#13;
```&#13;
&#13;
# main&#13;
&#13;
```c++&#13;
ABSL_FLAG(uint16_t, port, 10010, 'server listen port');&#13;
ABSL_FLAG(size_t, worker, 4, 'worker num');&#13;
&#13;
int main(int argc, char **argv) {&#13;
&#13;
  absl::ParseCommandLine(argc, argv);&#13;
&#13;
  auto console = spdlog::stdout_color_mt('console');&#13;
  spdlog::set_default_logger(console);&#13;
  spdlog::set_pattern('%^[%H:%M:%S %e] %l thread-%t %v %$');&#13;
&#13;
  try {&#13;
    asio::io_context io_context;&#13;
&#13;
    // Run listener coroutine&#13;
    asio::co_spawn(io_context, listener(io_context, absl::GetFlag(FLAGS_port)),&#13;
                   asio::detached);&#13;
&#13;
    std::vector&lt;std::thread&gt; threads;&#13;
    size_t worker_num = absl::GetFlag(FLAGS_worker);&#13;
&#13;
    threads.resize(worker_num);&#13;
    for (size_t i = 0; i &lt; worker_num; ++i) {&#13;
      threads.emplace_back([&amp;io_context]() { io_context.run(); });&#13;
    }&#13;
&#13;
    io_context.run();&#13;
&#13;
    // Join all threads&#13;
    for (auto &amp;t : threads) {&#13;
      t.join();&#13;
    }&#13;
  } catch (const std::exception &amp;ex) {&#13;
    spdlog::error('run exception :{}', ex.what());&#13;
  }&#13;
  return 0;&#13;
}&#13;
```&#13;
。</description><guid isPermaLink="true">https://0x1042.github.io//post/26.html</guid><pubDate>Mon, 01 Jul 2024 17:10:21 +0000</pubDate></item><item><title>asio基本使用</title><link>https://0x1042.github.io//post/25.html</link><description># 解析域名&#13;
&#13;
```c++&#13;
    std::string domain = 'www.toutiao.com';&#13;
    std::string port = '443';&#13;
&#13;
    asio::ip::tcp::resolver resolver(socket.get_executor());&#13;
    asio::ip::tcp::resolver::results_type endpoints =&#13;
        co_await resolver.async_resolve(host, port, asio::use_awaitable);&#13;
```&#13;
&#13;
# tcp连接 &#13;
&#13;
```c++&#13;
&#13;
// 连接解析后的结果 &#13;
&#13;
asio::ip::tcp::socket remote_socket(socket.get_executor());&#13;
co_await asio::async_connect(remote_socket, endpoints, asio::use_awaitable);&#13;
&#13;
// 连接host port&#13;
asio::ip::tcp::endpoint remote_endpoint(asio::ip::make_address_v4(address),&#13;
                                            (port[0] &lt;&lt; 8) | port[1]);&#13;
asio::ip::tcp::socket remote_socket(socket.get_executor());&#13;
co_await remote_socket.async_connect(remote_endpoint, asio::use_awaitable);&#13;
```&#13;
&#13;
# copy 两个socket &#13;
&#13;
```c++&#13;
using namespace asio::experimental::awaitable_operators;&#13;
&#13;
constexpr size_t bufsize = 16 * 1024;&#13;
&#13;
asio::awaitable&lt;void&gt; relay(asio::ip::tcp::socket &amp;from,&#13;
                            asio::ip::tcp::socket &amp;to) {&#13;
&#13;
  auto relay = [](asio::ip::tcp::socket &amp;from,&#13;
                  asio::ip::tcp::socket &amp;to) -&gt; asio::awaitable&lt;void&gt; {&#13;
    try {&#13;
      std::array&lt;uint8_t, bufsize&gt; data{};&#13;
      for (;;) {&#13;
        std::size_t n = co_await from.async_read_some(asio::buffer(data),&#13;
                                                      asio::use_awaitable);&#13;
        co_await asio::async_write(to, asio::buffer(data, n),&#13;
                                   asio::use_awaitable);&#13;
      }&#13;
    } catch (...) {&#13;
      from.close();&#13;
      to.close();&#13;
    }&#13;
  };&#13;
&#13;
  co_await (relay(from, to) &amp;&amp; relay(to, from));&#13;
}&#13;
&#13;
&#13;
// 使用 &#13;
co_await relay(socket, remote_socket);&#13;
&#13;
```&#13;
&#13;
# 读取指定长度数据 &#13;
&#13;
```c++&#13;
std::array&lt;uint8_t, 4&gt; handshake_request{};&#13;
co_await asio::async_read(socket, asio::buffer(handshake_request), asio::use_awaitable);&#13;
```&#13;
&#13;
# 按行读取 &#13;
&#13;
```c++&#13;
    asio::streambuf buffer;&#13;
    std::vector&lt;std::string&gt; lines;&#13;
    for (;;) {&#13;
      std::size_t n = co_await asio::async_read_until(socket, buffer, '\r\n',&#13;
                                                      asio::use_awaitable);&#13;
      auto bufs = buffer.data();&#13;
      std::string line(asio::buffers_begin(bufs),&#13;
                       asio::buffers_begin(bufs) + n);&#13;
&#13;
      if (line == '\r\n') {&#13;
        break;&#13;
      }&#13;
&#13;
      lines.push_back(std::move(line));&#13;
      buffer.consume(n);&#13;
    }&#13;
```&#13;
&#13;
# peek &#13;
&#13;
```c++&#13;
std::array&lt;uint8_t, 1&gt; data{};&#13;
socket.receive(asio::buffer(data), asio::socket_base::message_peek);&#13;
std::clog &lt;&lt; 'message_peek:' &lt;&lt; fmt::to_string(data) &lt;&lt; '\n';&#13;
```&#13;
&#13;
&#13;
# 写入数据&#13;
&#13;
- 写入string&#13;
&#13;
```c++&#13;
const std::string &amp;response = 'HTTP/1.1 200 Connection Established\r\n\r\n';&#13;
co_await asio::async_write(socket, asio::buffer(response),&#13;
                               asio::use_awaitable);&#13;
```&#13;
&#13;
- 写入bytes&#13;
&#13;
```c++&#13;
std::array&lt;uint8_t, 10&gt; response = {&#13;
        0x05,       0x00,       0x00,       0x01,    address[0],&#13;
        address[1], address[2], address[3], port[0], port[1]};&#13;
co_await asio::async_write(socket, asio::buffer(response),&#13;
                               asio::use_awaitable);&#13;
```&#13;
&#13;
# listen&#13;
&#13;
```c++&#13;
auto endpoint = asio::ip::tcp::endpoint(asio::ip::tcp::v4(), port);&#13;
asio::ip::tcp::acceptor acceptor(io_context, endpoint);&#13;
&#13;
  for (;;) {&#13;
    asio::ip::tcp::socket socket = co_await acceptor.async_accept(asio::use_awaitable);&#13;
  }&#13;
&#13;
```&#13;
&#13;
&#13;
&#13;
。</description><guid isPermaLink="true">https://0x1042.github.io//post/25.html</guid><pubDate>Sun, 30 Jun 2024 18:45:30 +0000</pubDate></item><item><title>parallel</title><link>https://0x1042.github.io//post/24.html</link><description># parallel&#13;
&#13;
## fetch &#13;
&#13;
```c++&#13;
auto fetch(const std::string &amp; url) -&gt; int {&#13;
    Timer start;&#13;
    cpr::Response r = cpr::Get(cpr::Url{url}, cpr::Timeout{std::chrono::milliseconds(200)});&#13;
    LOG(INFO) &lt;&lt; 'thread-' &lt;&lt; std::this_thread::get_id() &lt;&lt; ' fetch [' &lt;&lt; url &lt;&lt; '] cost:' &lt;&lt; start.get_elapsed_ms()&#13;
              &lt;&lt; ' ms. status_code: ' &lt;&lt; r.status_code &lt;&lt; ' text:' &lt;&lt; r.text.size() &lt;&lt; '\n';&#13;
    return 0;&#13;
}&#13;
```&#13;
&#13;
## folly&#13;
 &#13;
```c++&#13;
    Timer start;&#13;
&#13;
    std::vector&lt;std::string&gt; urls = {&#13;
        'https://www.cnblogs.com/',&#13;
        'https://www.alipan.com/',&#13;
        'https://www.toutiao.com/',&#13;
    };&#13;
&#13;
    std::vector&lt;folly::Future&lt;int&gt;&gt; futures;&#13;
    futures.reserve(urls.size());&#13;
&#13;
    for (const auto &amp; url : urls) {&#13;
        auto fn = folly::via(infra::global().get(), [url]() { return infra::fetch(url); });&#13;
        futures.push_back(std::move(fn));&#13;
    }&#13;
&#13;
    folly::collectAll(futures).get();&#13;
&#13;
    LOG(INFO) &lt;&lt; 'folly fetch ' &lt;&lt; urls.size() &lt;&lt; ' total cost:' &lt;&lt; start.get_elapsed_ms() &lt;&lt; ' ms\n';&#13;
```&#13;
&#13;
## omp &#13;
&#13;
```c++&#13;
    Timer start;&#13;
&#13;
    std::vector&lt;std::string&gt; urls = {&#13;
        'https://www.cnblogs.com/',&#13;
        'https://www.alipan.com/',&#13;
        'https://www.toutiao.com/',&#13;
    };&#13;
&#13;
#pragma omp parallel for num_threads(urls.size())&#13;
    for (size_t i = 0; i &lt; urls.size(); i++) {&#13;
        int status = infra::fetch(urls[i]);&#13;
        LOG(INFO) &lt;&lt; 'status:' &lt;&lt; status;&#13;
    }&#13;
    LOG(INFO) &lt;&lt; 'omp fetch ' &lt;&lt; urls.size() &lt;&lt; ' total cost:' &lt;&lt; start.get_elapsed_ms() &lt;&lt; ' ms\n';&#13;
```。</description><guid isPermaLink="true">https://0x1042.github.io//post/24.html</guid><pubDate>Sun, 19 May 2024 16:20:10 +0000</pubDate></item><item><title>highway hash  </title><link>https://0x1042.github.io//post/23.html</link><description># highway hash &#13;
&#13;
- c [https://github.com/google/highwayhash](https://github.com/google/highwayhash) &#13;
- go [https://github.com/minio/highwayhash](https://github.com/minio/highwayhash)&#13;
&#13;
# go &#13;
&#13;
## 64bit &#13;
&#13;
```go&#13;
&#13;
var (&#13;
	key [32]byte&#13;
)&#13;
&#13;
func HighHash(input string) string {&#13;
	hash, _ := highwayhash.New64(key[:])&#13;
	hash.Write([]byte(input))&#13;
	checksum := hash.Sum(nil)&#13;
	return hex.EncodeToString(checksum)&#13;
}&#13;
&#13;
func HighHashFile(path string) string {&#13;
	hash, _ := highwayhash.New64(key[:])&#13;
	file, _ := os.Open(path)&#13;
	io.Copy(hash, file)&#13;
	return hex.EncodeToString(hash.Sum(nil))&#13;
}&#13;
```&#13;
&#13;
&#13;
## 128 bit&#13;
&#13;
```go&#13;
func HighHash128(input string) string {&#13;
	hash, _ := highwayhash.New128(key[:])&#13;
	hash.Write([]byte(input))&#13;
	checksum := hash.Sum(nil)&#13;
	return hex.EncodeToString(checksum)&#13;
}&#13;
```&#13;
&#13;
# c++&#13;
&#13;
## 64bit &#13;
&#13;
```c++&#13;
&#13;
void put_uint64_le(uint8_t *buf, uint64_t value) {&#13;
  buf[0] = static_cast&lt;uint8_t&gt;(value &amp; 0xFF);&#13;
  buf[1] = static_cast&lt;uint8_t&gt;((value &gt;&gt; 8) &amp; 0xFF);&#13;
  buf[2] = static_cast&lt;uint8_t&gt;((value &gt;&gt; 16) &amp; 0xFF);&#13;
  buf[3] = static_cast&lt;uint8_t&gt;((value &gt;&gt; 24) &amp; 0xFF);&#13;
  buf[4] = static_cast&lt;uint8_t&gt;((value &gt;&gt; 32) &amp; 0xFF);&#13;
  buf[5] = static_cast&lt;uint8_t&gt;((value &gt;&gt; 40) &amp; 0xFF);&#13;
  buf[6] = static_cast&lt;uint8_t&gt;((value &gt;&gt; 48) &amp; 0xFF);&#13;
  buf[7] = static_cast&lt;uint8_t&gt;((value &gt;&gt; 56) &amp; 0xFF);&#13;
}&#13;
&#13;
const static uint64_t EMPTY_KEY[4] = {0, 0, 0, 0};&#13;
&#13;
std::string high_hash(const std::string &amp;input) {&#13;
  uint64_t hash = HighwayHash64(reinterpret_cast&lt;const uint8_t *&gt;(input.data()),&#13;
                                input.size(), EMPTY_KEY);&#13;
  uint8_t bytes[8];&#13;
  put_uint64_le(bytes, hash);&#13;
  std::string rsp;&#13;
  for (int i = 0; i &lt; 8; i++) {&#13;
    rsp += fmt::format('{0:02x}', bytes[i]);&#13;
  }&#13;
  return rsp;&#13;
}&#13;
```&#13;
&#13;
## 128 bit&#13;
&#13;
```c++&#13;
&#13;
std::string high_hash128(const std::string &amp;input) {&#13;
  uint64_t hash[2];&#13;
  HighwayHash128(reinterpret_cast&lt;const uint8_t *&gt;(input.data()), input.size(),&#13;
                 EMPTY_KEY, hash);&#13;
  uint8_t bytes1[8];&#13;
  put_uint64_le(bytes1, hash[0]);&#13;
&#13;
  uint8_t bytes2[8];&#13;
  put_uint64_le(bytes2, hash[1]);&#13;
  std::string rsp;&#13;
  for (int i = 0; i &lt; 8; i++) {&#13;
    rsp += fmt::format('{0:02x}', bytes1[i]);&#13;
  }&#13;
  for (int i = 0; i &lt; 8; i++) {&#13;
    rsp += fmt::format('{0:02x}', bytes2[i]);&#13;
  }&#13;
  return rsp;&#13;
}&#13;
```&#13;
&#13;
## 优化版本&#13;
&#13;
```c++&#13;
auto high_hash128_v2(const std::string &amp; input) -&gt; std::string {&#13;
    uint64_t hash[2];&#13;
    HighwayHash128(reinterpret_cast&lt;const uint8_t *&gt;(input.data()), input.size(), EMPTY_KEY, hash);&#13;
&#13;
    std::array&lt;uint8_t, 16&gt; buffer{};&#13;
    std::memcpy(buffer.data(), &amp;hash, sizeof(hash));&#13;
&#13;
    std::string rsp;&#13;
    for (unsigned char &amp; b : buffer) {&#13;
        rsp += fmt::format('{0:02x}', b);&#13;
    }&#13;
    return rsp;&#13;
}&#13;
```&#13;
。</description><guid isPermaLink="true">https://0x1042.github.io//post/23.html</guid><pubDate>Thu, 16 May 2024 16:54:53 +0000</pubDate></item><item><title>absl time基本使用</title><link>https://0x1042.github.io//post/22.html</link><description>&#13;
# 时间基本使用 &#13;
&#13;
## 获取指定时区的时间 &#13;
&#13;
```c++&#13;
        absl::TimeZone local;&#13;
        absl::LoadTimeZone('Asia/Shanghai', &amp;local);&#13;
        auto now_in_second = absl::ToCivilSecond(absl::Now(), local);&#13;
        std::clog &lt;&lt; 'now_in_second:' &lt;&lt; now_in_second &lt;&lt; '\n';&#13;
```&#13;
&#13;
&#13;
## 获取指定时区当前小时&#13;
&#13;
```c++&#13;
        absl::TimeZone local;&#13;
        absl::LoadTimeZone('Asia/Shanghai', &amp;local);&#13;
        auto now_in_hour = absl::ToCivilHour(absl::Now(), local);&#13;
        std::clog &lt;&lt; 'now_in_hour:' &lt;&lt; now_in_hour.hour() &lt;&lt; '\n';&#13;
```&#13;
&#13;
## 获取日期 &#13;
&#13;
```c++&#13;
    absl::Duration one_day = absl::Hours(24) * offset;&#13;
    absl::Time tt = absl::Now() + one_day;&#13;
    absl::TimeZone local;&#13;
    absl::LoadTimeZone('Asia/Shanghai', &amp;local);&#13;
    auto today = absl::ToCivilDay(tt, local);&#13;
    return absl::FormatCivilTime(today);&#13;
```&#13;
&#13;
## 解析字符串到时间 &#13;
&#13;
```c++&#13;
auto str2time(const std::string &amp; str, absl::Time &amp; dst, absl::TimeZone tz) -&gt; bool {&#13;
    std::string err;&#13;
    bool status = absl::ParseTime('%Y-%m-%d', str, tz, &amp;dst, &amp;err);&#13;
    return status;&#13;
}&#13;
&#13;
auto parse_time(const std::string &amp; str) -&gt; absl::CivilDay {&#13;
    absl::CivilDay day;&#13;
&#13;
    bool status = absl::ParseCivilTime(str, &amp;day);&#13;
    std::clog &lt;&lt; 'status:' &lt;&lt; status &lt;&lt; '\n';&#13;
    return day;&#13;
}&#13;
```&#13;
&#13;
## 时间计算&#13;
&#13;
```c++&#13;
        const std::string &amp; start_str = '2024-05-10';&#13;
        auto start = parse_time(start_str);&#13;
&#13;
        const std::string &amp; end_str = '2024-05-18';&#13;
        auto end = parse_time(end_str);&#13;
&#13;
        std::clog &lt;&lt; '(end - start) = ' &lt;&lt; end - start &lt;&lt; '\n';&#13;
        ASSERT_EQ(end - start, 8);&#13;
```。</description><guid isPermaLink="true">https://0x1042.github.io//post/22.html</guid><pubDate>Fri, 10 May 2024 16:54:33 +0000</pubDate></item><item><title>cmake 开启sanitize</title><link>https://0x1042.github.io//post/21.html</link><description>&#13;
- [配置](#配置)&#13;
- [测试](#测试)&#13;
- [编译运行](#编译运行)&#13;
  - [`-fsanitize=thread`](#-fsanitizethread)&#13;
  - [`-fsanitize=address`](#-fsanitizeaddress)&#13;
- [`sanitier`](#sanitier)&#13;
&#13;
# 配置 &#13;
&#13;
```cmake&#13;
option(ENABLE_SANITIZE 'Enable feature' ON)&#13;
&#13;
if(ENABLE_SANITIZE) &#13;
  add_compile_options('-fno-omit-frame-pointer') &#13;
  add_compile_options('-fno-optimize-sibling-calls')&#13;
  # add_compile_options('-fsanitize=address')&#13;
  add_compile_options('-fsanitize=thread')&#13;
  add_compile_options('-fsanitize-address-use-after-scope')&#13;
  # set(CMAKE_EXE_LINKER_FLAGS '-fno-omit-frame-pointer -fno-optimize-sibling-calls -fsanitize=address' ) &#13;
  set(CMAKE_EXE_LINKER_FLAGS '-fno-omit-frame-pointer -fno-optimize-sibling-calls -fsanitize=thread' ) &#13;
endif()&#13;
```&#13;
&#13;
# 测试&#13;
&#13;
```c++&#13;
#include &lt;functional&gt;&#13;
#include &lt;string&gt;&#13;
#include &lt;thread&gt;&#13;
#include &lt;vector&gt;&#13;
&#13;
#include &lt;fmt/ranges.h&gt;&#13;
#include &lt;gtest/gtest.h&gt;&#13;
&#13;
void add_to_vec(std::vector&lt;std::string&gt; &amp;target, const std::string &amp;name) {&#13;
	for (int i = 0; i &lt; 10; i++) {&#13;
		target.push_back(fmt::format('{}:{}', name, i));&#13;
	}&#13;
}&#13;
&#13;
TEST(race, addtovec) {&#13;
	std::vector&lt;std::string&gt; dst;&#13;
	std::string hello = 'hello';&#13;
	std::string world = 'world';&#13;
	std::thread t1(add_to_vec, std::ref(dst), std::cref(hello));&#13;
	std::thread t2(add_to_vec, std::ref(dst), std::cref(world));&#13;
	t1.join();&#13;
	t2.join();&#13;
	std::cerr &lt;&lt; ' res: ' &lt;&lt; fmt::format('{}', dst) &lt;&lt; '\n';&#13;
}&#13;
```&#13;
&#13;
# 编译运行 &#13;
&#13;
## `-fsanitize=thread`&#13;
&#13;
```shell&#13;
WARNING: ThreadSanitizer: data race (pid=77881)&#13;
  Read of size 8 at 0x7ff7ba7ae880 by thread T4:&#13;
    #0 add_to_vec(std::__1::vector&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;, std::__1::allocator&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&gt;&gt;&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt; const&amp;) race.cc:14 (singleton:x86_64+0x100021ba9)&#13;
    #1 void* std::__1::__thread_proxy[abi:ue170006]&lt;std::__1::tuple&lt;std::__1::unique_ptr&lt;std::__1::__thread_struct, std::__1::default_delete&lt;std::__1::__thread_struct&gt;&gt;, void (*)(std::__1::vector&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;, std::__1::allocator&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&gt;&gt;&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt; const&amp;), std::__1::reference_wrapper&lt;std::__1::vector&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;, std::__1::allocator&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&gt;&gt;&gt;, std::__1::reference_wrapper&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt; const&gt;&gt;&gt;(void*) thread.h:232 (singleton:x86_64+0x100022437)&#13;
&#13;
  Previous write of size 8 at 0x7ff7ba7ae880 by thread T3:&#13;
    #0 add_to_vec(std::__1::vector&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;, std::__1::allocator&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&gt;&gt;&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt; const&amp;) race.cc:14 (singleton:x86_64+0x100021b0b)&#13;
    #1 void* std::__1::__thread_proxy[abi:ue170006]&lt;std::__1::tuple&lt;std::__1::unique_ptr&lt;std::__1::__thread_struct, std::__1::default_delete&lt;std::__1::__thread_struct&gt;&gt;, void (*)(std::__1::vector&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;, std::__1::allocator&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&gt;&gt;&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt; const&amp;), std::__1::reference_wrapper&lt;std::__1::vector&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;, std::__1::allocator&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&gt;&gt;&gt;, std::__1::reference_wrapper&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt; const&gt;&gt;&gt;(void*) thread.h:232 (singleton:x86_64+0x100022437)&#13;
```&#13;
&#13;
## `-fsanitize=address`&#13;
&#13;
```shell&#13;
==84486==ERROR: AddressSanitizer: attempting free on address which was not malloc()-ed: 0x603000003058 in thread T4&#13;
    #0 0x10f6dd4ad in _ZdlPv (/usr/local/Cellar/llvm/17.0.6_1/lib/clang/17/lib/darwin/libclang_rt.asan_osx_dynamic.dylib:x86_64h+0xf14ad)&#13;
    #1 0x10eb5162e in add_to_vec(std::__1::vector&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;, std::__1::allocator&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&gt;&gt;&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt; const&amp;) (/Users/weixuan/code/ccode/singleton/_build/singleton:x86_64+0x10004162e)&#13;
    #2 0x10eb52fab in void* std::__1::__thread_proxy[abi:ue170006]&lt;std::__1::tuple&lt;std::__1::unique_ptr&lt;std::__1::__thread_struct, std::__1::default_delete&lt;std::__1::__thread_struct&gt;&gt;, void (*)(std::__1::vector&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;, std::__1::allocator&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&gt;&gt;&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt; const&amp;), std::__1::reference_wrapper&lt;std::__1::vector&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;, std::__1::allocator&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&gt;&gt;&gt;, std::__1::reference_wrapper&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt; const&gt;&gt;&gt;(void*) (/Users/weixuan/code/ccode/singleton/_build/singleton:x86_64+0x100042fab)&#13;
    #3 0x10f6c59dd in asan_thread_start(void*) (/usr/local/Cellar/llvm/17.0.6_1/lib/clang/17/lib/darwin/libclang_rt.asan_osx_dynamic.dylib:x86_64h+0xd99dd)&#13;
    #4 0x7ff819cf818a in _pthread_start (/usr/lib/system/libsystem_pthread.dylib:x86_64+0x618a)&#13;
    #5 0x7ff819cf3ae2 in thread_start (/usr/lib/system/libsystem_pthread.dylib:x86_64+0x1ae2)&#13;
&#13;
0x603000003058 is located 40 bytes after 32-byte region [0x603000003010,0x603000003030)&#13;
freed by thread T0 here:&#13;
    #0 0x10f6dd4ad in _ZdlPv (/usr/local/Cellar/llvm/17.0.6_1/lib/clang/17/lib/darwin/libclang_rt.asan_osx_dynamic.dylib:x86_64h+0xf14ad)&#13;
    #1 0x10eb4e399 in tf::Executor::~Executor() (/Users/weixuan/code/ccode/singleton/_build/singleton:x86_64+0x10003e399)&#13;
    #2 0x10eb142b9 in test_task_flow() (/Users/weixuan/code/ccode/singleton/_build/singleton:x86_64+0x1000042b9)&#13;
    #3 0x10eb17228 in taskflow_dag_Test::TestBody() (/Users/weixuan/code/ccode/singleton/_build/singleton:x86_64+0x100007228)&#13;
    #4 0x10eba18ea in void testing::internal::HandleExceptionsInMethodIfSupported&lt;testing::Test, void&gt;(testing::Test*, void (testing::Test::*)(), char const*) (/Users/weixuan/code/ccode/singleton/_build/singleton:x86_64+0x1000918ea)&#13;
    #5 0x10eba183f in testing::Test::Run() (/Users/weixuan/code/ccode/singleton/_build/singleton:x86_64+0x10009183f)&#13;
    #6 0x10eba2b9f in testing::TestInfo::Run() (/Users/weixuan/code/ccode/singleton/_build/singleton:x86_64+0x100092b9f)&#13;
    #7 0x10eba3bc6 in testing::TestSuite::Run() (/Users/weixuan/code/ccode/singleton/_build/singleton:x86_64+0x100093bc6)&#13;
    #8 0x10ebb40ed in testing::internal::UnitTestImpl::RunAllTests() (/Users/weixuan/code/ccode/singleton/_build/singleton:x86_64+0x1000a40ed)&#13;
    #9 0x10ebb391a in bool testing::internal::HandleExceptionsInMethodIfSupported&lt;testing::internal::UnitTestImpl, bool&gt;(testing::internal::UnitTestImpl*, bool (testing::internal::UnitTestImpl::*)(), char const*) (/Users/weixuan/code/ccode/singleton/_build/singleton:x86_64+0x1000a391a)&#13;
    #10 0x10ebb389c in testing::UnitTest::Run() (/Users/weixuan/code/ccode/singleton/_build/singleton:x86_64+0x1000a389c)&#13;
    #11 0x10eb57c2f in main (/Users/weixuan/code/ccode/singleton/_build/singleton:x86_64+0x100047c2f)&#13;
    #12 0x7ff81996c365  (/usr/lib/dyld:x86_64+0xfffffffffff5c365)&#13;
&#13;
previously allocated by thread T1 here:&#13;
    #0 0x10f6dd08d in _Znwm (/usr/local/Cellar/llvm/17.0.6_1/lib/clang/17/lib/darwin/libclang_rt.asan_osx_dynamic.dylib:x86_64h+0xf108d)&#13;
    #1 0x10eb1efc9 in std::__1::pair&lt;std::__1::__hash_iterator&lt;std::__1::__hash_node&lt;std::__1::__hash_value_type&lt;std::__1::__thread_id, unsigned long&gt;, void*&gt;*&gt;, bool&gt; std::__1::__hash_table&lt;std::__1::__hash_value_type&lt;std::__1::__thread_id, unsigned long&gt;, std::__1::__unordered_map_hasher&lt;std::__1::__thread_id, std::__1::__hash_value_type&lt;std::__1::__thread_id, unsigned long&gt;, std::__1::hash&lt;std::__1::__thread_id&gt;, std::__1::equal_to&lt;std::__1::__thread_id&gt;, true&gt;, std::__1::__unordered_map_equal&lt;std::__1::__thread_id, std::__1::__hash_value_type&lt;std::__1::__thread_id, unsigned long&gt;, std::__1::equal_to&lt;std::__1::__thread_id&gt;, std::__1::hash&lt;std::__1::__thread_id&gt;, true&gt;, std::__1::allocator&lt;std::__1::__hash_value_type&lt;std::__1::__thread_id, unsigned long&gt;&gt;&gt;::__emplace_unique_key_args&lt;std::__1::__thread_id, std::__1::piecewise_construct_t const&amp;, std::__1::tuple&lt;std::__1::__thread_id&amp;&amp;&gt;, std::__1::tuple&lt;&gt;&gt;(std::__1::__thread_id const&amp;, std::__1::piecewise_construct_t const&amp;, std::__1::tuple&lt;std::__1::__thread_id&amp;&amp;&gt;&amp;&amp;, std::__1::tuple&lt;&gt;&amp;&amp;) (/Users/weixuan/code/ccode/singleton/_build/singleton:x86_64+0x10000efc9)&#13;
    #2 0x10eb1dfa2 in tf::Executor::_spawn(unsigned long)::'lambda'(tf::Worker&amp;, std::__1::mutex&amp;, std::__1::condition_variable&amp;, unsigned long&amp;)::operator()(tf::Worker&amp;, std::__1::mutex&amp;, std::__1::condition_variable&amp;, unsigned long&amp;) const (/Users/weixuan/code/ccode/singleton/_build/singleton:x86_64+0x10000dfa2)&#13;
    #3 0x10eb1db2c in void* std::__1::__thread_proxy[abi:ue170006]&lt;std::__1::tuple&lt;std::__1::unique_ptr&lt;std::__1::__thread_struct, std::__1::default_delete&lt;std::__1::__thread_struct&gt;&gt;, tf::Executor::_spawn(unsigned long)::'lambda'(tf::Worker&amp;, std::__1::mutex&amp;, std::__1::condition_variable&amp;, unsigned long&amp;), std::__1::reference_wrapper&lt;tf::Worker&gt;, std::__1::reference_wrapper&lt;std::__1::mutex&gt;, std::__1::reference_wrapper&lt;std::__1::condition_variable&gt;, std::__1::reference_wrapper&lt;unsigned long&gt;&gt;&gt;(void*) (/Users/weixuan/code/ccode/singleton/_build/singleton:x86_64+0x10000db2c)&#13;
    #4 0x10f6c59dd in asan_thread_start(void*) (/usr/local/Cellar/llvm/17.0.6_1/lib/clang/17/lib/darwin/libclang_rt.asan_osx_dynamic.dylib:x86_64h+0xd99dd)&#13;
    #5 0x7ff819cf818a in _pthread_start (/usr/lib/system/libsystem_pthread.dylib:x86_64+0x618a)&#13;
    #6 0x7ff819cf3ae2 in thread_start (/usr/lib/system/libsystem_pthread.dylib:x86_64+0x1ae2)&#13;
```&#13;
&#13;
&#13;
# `sanitier`&#13;
&#13;
| sanitizer   | 官方地址                                                    | 开启方式                | 说明             |&#13;
| ----------- | ----------------------------------------------------------- | ----------------------- | ---------------- |&#13;
| `thread`    | https://clang.llvm.org/docs/ThreadSanitizer.html.           | `-fsanitize=thread`     | 检测datarace     |&#13;
| `address`   | https://clang.llvm.org/docs/AddressSanitizer.html           | `-fsanitize=address`    | 内存错误         |&#13;
| `memory`    | https://clang.llvm.org/docs/MemorySanitizer.html            | `-fsanitize=memory`     | 检测未初始化读取 |&#13;
| `undefined` | https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html | ` -fsanitize=undefined` | 检测为定义行为   |&#13;
&#13;
。</description><guid isPermaLink="true">https://0x1042.github.io//post/21.html</guid><pubDate>Sun, 24 Mar 2024 07:40:15 +0000</pubDate></item><item><title>the rule of five</title><link>https://0x1042.github.io//post/20.html</link><description>&#13;
- [定义](#定义)&#13;
- [`copy constructor`](#copy-constructor)&#13;
  - [问题](#问题)&#13;
  - [解决方案](#解决方案)&#13;
- [`operator=`](#operator)&#13;
  - [问题](#问题-1)&#13;
  - [解决方案](#解决方案-1)&#13;
- [`move constructor`](#move-constructor)&#13;
  - [问题](#问题-2)&#13;
  - [解决方案](#解决方案-2)&#13;
- [`move operator`](#move-operator)&#13;
  - [问题](#问题-3)&#13;
  - [解决方案](#解决方案-3)&#13;
&#13;
# 定义 &#13;
&#13;
```cpp&#13;
class SString {&#13;
public:&#13;
    explicit SString(const char * cp);&#13;
&#13;
    virtual ~SString();&#13;
&#13;
private:&#13;
    char * data_;&#13;
};&#13;
&#13;
// impl &#13;
// 确保长度&#13;
SString::SString(const char * cp) : data_(new char[strlen(cp) + 1]) {&#13;
    strcpy(data_, cp);&#13;
}&#13;
&#13;
SString::~SString() {&#13;
    delete[] data_;&#13;
}&#13;
```&#13;
&#13;
&gt; the rule of five &#13;
&gt; - Destructor&#13;
&gt; - Copy Constructor&#13;
&gt; - Copy Assignment Operator&#13;
&gt; - Move Constructor&#13;
&gt; - Move Assignment Operator&#13;
&#13;
&#13;
# `copy constructor`&#13;
&#13;
&gt; 考虑一下使用方式 ，这个代码有两个问题 &#13;
&#13;
```cpp&#13;
&#13;
void foo(rof::SString val) {&#13;
    spdlog::info('size is {}', val.size());&#13;
}&#13;
&#13;
TEST_CASE('case1', 'copy') {&#13;
    rof::SString s{'hello world'};&#13;
    { foo(s); }&#13;
    { foo(s); }&#13;
}&#13;
```&#13;
&#13;
```&#13;
==23702==ERROR: AddressSanitizer: heap-use-after-free on address 0x6020000037f0 at pc 0x000104cd721d bp 0x7ff7bc0ea590 sp 0x7ff7bc0e9d58&#13;
READ of size 3 at 0x6020000037f0 thread T0&#13;
    #0 0x104cd721c in strlen+0x80c (libclang_rt.asan_osx_dynamic.dylib:x86_64h+0x1b21c)&#13;
    #1 0x103fc4869 in tests::foo(rof::SString)+0x181 (c20:x86_64+0x1001b1869)&#13;
    #2 0x103fc4c64 in tests::CATCH2_INTERNAL_TEST_0()+0x2fc (c20:x86_64+0x1001b1c64)&#13;
    #3 0x103eadd03 in Catch::RunContext::runCurrentTest(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&amp;)+0x203 (c20:x86_64+0x10009ad03)&#13;
    #4 0x103ead79a in Catch::RunContext::runTest(Catch::TestCaseHandle const&amp;)+0x1ea (c20:x86_64+0x10009a79a)&#13;
    #5 0x103e8f870 in Catch::Session::runInternal()+0xe20 (c20:x86_64+0x10007c870)&#13;
    #6 0x103e8e9e4 in Catch::Session::run()+0x44 (c20:x86_64+0x10007b9e4)&#13;
    #7 0x103f6702c in main+0x624 (c20:x86_64+0x10015402c)&#13;
    #8 0x7ff811187365 in start+0x795 (dyld:x86_64+0xfffffffffff5c365)&#13;
&#13;
0x6020000037f0 is located 0 bytes inside of 12-byte region [0x6020000037f0,0x6020000037fc)&#13;
freed by thread T0 here:&#13;
    #0 0x104dad5ad in _ZdaPv+0x7d (libclang_rt.asan_osx_dynamic.dylib:x86_64h+0xf15ad)&#13;
    #1 0x103fc4bfc in tests::CATCH2_INTERNAL_TEST_0()+0x294 (c20:x86_64+0x1001b1bfc)&#13;
    #2 0x103eadd03 in Catch::RunContext::runCurrentTest(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&amp;)+0x203 (c20:x86_64+0x10009ad03)&#13;
    #3 0x103ead79a in Catch::RunContext::runTest(Catch::TestCaseHandle const&amp;)+0x1ea (c20:x86_64+0x10009a79a)&#13;
    #4 0x103e8f870 in Catch::Session::runInternal()+0xe20 (c20:x86_64+0x10007c870)&#13;
    #5 0x103e8e9e4 in Catch::Session::run()+0x44 (c20:x86_64+0x10007b9e4)&#13;
    #6 0x103f6702c in main+0x624 (c20:x86_64+0x10015402c)&#13;
    #7 0x7ff811187365 in start+0x795 (dyld:x86_64+0xfffffffffff5c365)&#13;
&#13;
previously allocated by thread T0 here:&#13;
    #0 0x104dad19d in _Znam+0x7d (libclang_rt.asan_osx_dynamic.dylib:x86_64h+0xf119d)&#13;
    #1 0x103fc4a6d in tests::CATCH2_INTERNAL_TEST_0()+0x105 (c20:x86_64+0x1001b1a6d)&#13;
    #2 0x103eadd03 in Catch::RunContext::runCurrentTest(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&amp;)+0x203 (c20:x86_64+0x10009ad03)&#13;
    #3 0x103ead79a in Catch::RunContext::runTest(Catch::TestCaseHandle const&amp;)+0x1ea (c20:x86_64+0x10009a79a)&#13;
    #4 0x103e8f870 in Catch::Session::runInternal()+0xe20 (c20:x86_64+0x10007c870)&#13;
    #5 0x103e8e9e4 in Catch::Session::run()+0x44 (c20:x86_64+0x10007b9e4)&#13;
    #6 0x103f6702c in main+0x624 (c20:x86_64+0x10015402c)&#13;
    #7 0x7ff811187365 in start+0x795 (dyld:x86_64+0xfffffffffff5c365)&#13;
&#13;
SUMMARY: AddressSanitizer: heap-use-after-free (libclang_rt.asan_osx_dynamic.dylib:x86_64h+0x1b21c) in strlen+0x80c&#13;
```&#13;
&#13;
## 问题&#13;
1. use after free&#13;
2. double free &#13;
&#13;
## 解决方案 &#13;
&gt; 实现copy constructor，避免两个指针指向一块内存地址&#13;
&#13;
```cpp &#13;
&#13;
SString(const SString &amp; other);&#13;
&#13;
// impl&#13;
SString::SString(const SString &amp; other) : data_(new char[strlen(other.data_) + 1]) {&#13;
    strcpy(data_, other.data_);&#13;
}&#13;
&#13;
```&#13;
&#13;
# `operator=`&#13;
&#13;
&gt; 考虑一下使用方式&#13;
&#13;
```cpp&#13;
TEST_CASE('sstring2', 'operator') {&#13;
    rof::SString hello{'hello'};&#13;
    rof::SString world{'world'};&#13;
&#13;
    world = hello;&#13;
}&#13;
```&#13;
&#13;
```&#13;
==24524==ERROR: AddressSanitizer: attempting double-free on 0x602000003830 in thread T0:&#13;
    #0 0x1061ad5ad in _ZdaPv+0x7d (libclang_rt.asan_osx_dynamic.dylib:x86_64h+0xf15ad)&#13;
    #1 0x105424859 in tests::CATCH2_INTERNAL_TEST_2()+0x2b1 (c20:x86_64+0x1001b1859)&#13;
    #2 0x10530d303 in Catch::RunContext::runCurrentTest(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&amp;)+0x203 (c20:x86_64+0x10009a303)&#13;
    #3 0x10530cd9a in Catch::RunContext::runTest(Catch::TestCaseHandle const&amp;)+0x1ea (c20:x86_64+0x100099d9a)&#13;
    #4 0x1052eee70 in Catch::Session::runInternal()+0xe20 (c20:x86_64+0x10007be70)&#13;
    #5 0x1052edfe4 in Catch::Session::run()+0x44 (c20:x86_64+0x10007afe4)&#13;
    #6 0x1053c662c in main+0x624 (c20:x86_64+0x10015362c)&#13;
    #7 0x7ff811187365 in start+0x795 (dyld:x86_64+0xfffffffffff5c365)&#13;
&#13;
0x602000003830 is located 0 bytes inside of 6-byte region [0x602000003830,0x602000003836)&#13;
freed by thread T0 here:&#13;
    #0 0x1061ad5ad in _ZdaPv+0x7d (libclang_rt.asan_osx_dynamic.dylib:x86_64h+0xf15ad)&#13;
    #1 0x1054247f2 in tests::CATCH2_INTERNAL_TEST_2()+0x24a (c20:x86_64+0x1001b17f2)&#13;
    #2 0x10530d303 in Catch::RunContext::runCurrentTest(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&amp;)+0x203 (c20:x86_64+0x10009a303)&#13;
    #3 0x10530cd9a in Catch::RunContext::runTest(Catch::TestCaseHandle const&amp;)+0x1ea (c20:x86_64+0x100099d9a)&#13;
    #4 0x1052eee70 in Catch::Session::runInternal()+0xe20 (c20:x86_64+0x10007be70)&#13;
    #5 0x1052edfe4 in Catch::Session::run()+0x44 (c20:x86_64+0x10007afe4)&#13;
    #6 0x1053c662c in main+0x624 (c20:x86_64+0x10015362c)&#13;
    #7 0x7ff811187365 in start+0x795 (dyld:x86_64+0xfffffffffff5c365)&#13;
&#13;
previously allocated by thread T0 here:&#13;
    #0 0x1061ad19d in _Znam+0x7d (libclang_rt.asan_osx_dynamic.dylib:x86_64h+0xf119d)&#13;
    #1 0x105423d2f in rof::SString::SString(char const*)+0x4f (c20:x86_64+0x1001b0d2f)&#13;
    #2 0x10542467a in tests::CATCH2_INTERNAL_TEST_2()+0xd2 (c20:x86_64+0x1001b167a)&#13;
    #3 0x10530d303 in Catch::RunContext::runCurrentTest(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&amp;)+0x203 (c20:x86_64+0x10009a303)&#13;
    #4 0x10530cd9a in Catch::RunContext::runTest(Catch::TestCaseHandle const&amp;)+0x1ea (c20:x86_64+0x100099d9a)&#13;
    #5 0x1052eee70 in Catch::Session::runInternal()+0xe20 (c20:x86_64+0x10007be70)&#13;
    #6 0x1052edfe4 in Catch::Session::run()+0x44 (c20:x86_64+0x10007afe4)&#13;
    #7 0x1053c662c in main+0x624 (c20:x86_64+0x10015362c)&#13;
    #8 0x7ff811187365 in start+0x795 (dyld:x86_64+0xfffffffffff5c365)&#13;
&#13;
SUMMARY: AddressSanitizer: double-free (libclang_rt.asan_osx_dynamic.dylib:x86_64h+0xf15ad) in _ZdaPv+0x7d&#13;
```&#13;
&#13;
## 问题 &#13;
- double free&#13;
&#13;
&gt; 赋值之后，world 和 hello 的指针都指向了 hello的指针的内存地址&#13;
&gt; 析构的时候，会析构两次&#13;
 &#13;
## 解决方案 &#13;
&#13;
&gt; 实现自定义的 operator= (copy assignment operator)&#13;
&#13;
```cpp&#13;
&#13;
auto operator=(const SString &amp; other) -&gt; SString &amp;;&#13;
&#13;
auto SString::operator=(const SString &amp; other) -&gt; SString &amp; {&#13;
    // bugprone-unhandled-self-assignment&#13;
    if (this == &amp;other) {&#13;
        return *this;&#13;
    }&#13;
&#13;
    char * newdata = new char[strlen(other.data_) + 1];&#13;
    strcpy(newdata, other.data_);&#13;
    std::swap(newdata, this-&gt;data_);&#13;
    delete[] newdata;&#13;
    return *this;&#13;
}&#13;
```&#13;
&#13;
# `move constructor`&#13;
&#13;
&gt; 用法 &#13;
&#13;
```cpp &#13;
TEST_CASE('sstring3', 'move1') {&#13;
    rof::SString hello{'hello'};&#13;
&#13;
    foo(std::move(hello));&#13;
}&#13;
```&#13;
&#13;
## 问题&#13;
&#13;
```&#13;
Passing result of std::move() as a const reference argument; no move will actually happen (fix available)clang-tidyperformance-move-const-arg&#13;
ruleoffive.h(6, 7): 'SString' is not move assignable/constructible&#13;
```&#13;
&#13;
## 解决方案&#13;
&#13;
```cpp&#13;
SString(SString &amp;&amp; other) noexcept;&#13;
&#13;
// impl&#13;
SString::SString(SString &amp;&amp; other) noexcept : data_(other.data_) {&#13;
    other.data_ = nullptr;&#13;
}&#13;
```&#13;
&#13;
# `move operator` &#13;
&#13;
&gt; 用法 &#13;
&#13;
```cpp &#13;
TEST_CASE('sstring4', 'move2') {&#13;
    rof::SString hello{'hello'};&#13;
    rof::SString world{'world'};&#13;
&#13;
    world = std::move(hello);&#13;
}&#13;
```&#13;
&#13;
## 问题&#13;
&#13;
```&#13;
no move will actually happen (fix available)clang-tidyperformance-move-const-arg&#13;
ruleoffive.h(6, 7): 'SString' is not move assignable&#13;
```&#13;
&#13;
## 解决方案&#13;
&#13;
```cpp&#13;
auto operator=(SString &amp;&amp; other) noexcept -&gt; SString &amp;;&#13;
&#13;
auto SString::operator=(SString &amp;&amp; other) noexcept -&gt; SString &amp; {&#13;
    delete[] data_;&#13;
    data_ = other.data_;&#13;
    other.data_ = nullptr;&#13;
    return *this;&#13;
}&#13;
```。</description><guid isPermaLink="true">https://0x1042.github.io//post/20.html</guid><pubDate>Tue, 19 Mar 2024 08:05:32 +0000</pubDate></item><item><title>proc_macro_derive hello world</title><link>https://0x1042.github.io//post/19.html</link><description>- [builder](#builder)&#13;
  - [cargo.toml](#cargotoml)&#13;
  - [struct](#struct)&#13;
  - [lib.rs](#librs)&#13;
  - [验证结果](#验证结果)&#13;
&#13;
# builder &#13;
&#13;
&gt; 给定 `struct` 生成`builder`相关的结构&#13;
&#13;
## cargo.toml&#13;
&#13;
```toml&#13;
[package]&#13;
name = 'builder'&#13;
version = '0.1.0'&#13;
edition = '2021'&#13;
&#13;
[lib]&#13;
proc-macro = true&#13;
&#13;
[dependencies]&#13;
proc-macro2 = '1.0'&#13;
quote = '1.0'&#13;
syn = { version = '2.0', features = ['full'] }&#13;
```&#13;
&#13;
## struct&#13;
&#13;
```rust&#13;
#[derive(builder::Builder)]&#13;
pub struct Ad {&#13;
	id: u64,&#13;
	cids: Vec&lt;u64&gt;,&#13;
	title: String,&#13;
	bid: f32,&#13;
}&#13;
```&#13;
&#13;
## lib.rs&#13;
&#13;
- `quote!`: 将`Rust`代码转换为`TokenStream`&#13;
- `parse_macro_input!` 输入的 `TokenStream` 解析成 `Rust` 代码的数据结构&#13;
&#13;
&#13;
```rust&#13;
#[proc_macro_derive(Builder)]&#13;
pub fn derive(input: proc_macro::TokenStream) -&gt; proc_macro::TokenStream {&#13;
    let ast = syn::parse_macro_input!(input as syn::DeriveInput);&#13;
&#13;
    let ident = ast.ident;&#13;
&#13;
    let builder_ident = quote::format_ident!('{ident}Builder');&#13;
&#13;
    // 获取所有的field &#13;
    let fields = match ast.data.clone() {&#13;
        syn::Data::Struct(data) =&gt; data.fields,&#13;
        _ =&gt; panic!('only support struct'),&#13;
    };&#13;
&#13;
    // 定义builder 的字段&#13;
    // id: std::option::Option&lt;u64&gt;&#13;
    let builder_fields = fields.iter().map(|field| {&#13;
        let field = field.clone();&#13;
        let id = field.ident.unwrap();&#13;
        let ty = field.ty;&#13;
&#13;
        quote::quote! {&#13;
            #id: std::option::Option&lt;#ty&gt;&#13;
        }&#13;
    });&#13;
&#13;
    // 初始化为None &#13;
    // id: std::option::Option::None &#13;
    let builder_defaults = fields.iter().map(|field| {&#13;
        let field = field.clone();&#13;
        let id = field.ident.unwrap();&#13;
&#13;
        quote::quote! { #id: std::option::Option::None }&#13;
    });&#13;
&#13;
    // 定义setter 函数&#13;
    //     pub fn id(&amp;mut self, value: u64) -&gt; &amp;mut Self {&#13;
    //     self.id = std::option::Option::Some(value);&#13;
    //     self&#13;
    // }&#13;
    let setters = fields.iter().map(|field| {&#13;
        let field = field.clone();&#13;
        let ty = field.ty;&#13;
        let id = field.ident.unwrap();&#13;
&#13;
        quote::quote! {&#13;
            pub fn #id(&amp;mut self,value:#ty) -&gt; &amp;mut Self {&#13;
                self.#id = std::option::Option::Some(value);&#13;
                self&#13;
            }&#13;
        }&#13;
    });&#13;
&#13;
    // 字段赋值&#13;
    //  id: self.id.clone().unwrap()&#13;
    let build_fields = fields.iter().map(|field| {&#13;
        let field = field.clone();&#13;
        let id = field.ident.unwrap();&#13;
&#13;
        quote::quote! {&#13;
            #id: self.#id.clone().unwrap()&#13;
        }&#13;
    });&#13;
&#13;
    let output = quote::quote! {&#13;
        // 定义builder struct &#13;
        pub struct #builder_ident {&#13;
            #(#builder_fields),*&#13;
        }&#13;
&#13;
        impl #builder_ident {&#13;
            #(#setters)*&#13;
        }&#13;
&#13;
        impl #builder_ident {&#13;
            pub fn build(&amp;mut self) -&gt; std::result::Result&lt;#ident, std::boxed::Box&lt;dyn std::error::Error&gt;&gt; {&#13;
                std::result::Result::Ok(#ident {&#13;
                    #(#build_fields),*&#13;
                })&#13;
            }&#13;
&#13;
        }&#13;
&#13;
        impl #ident {&#13;
            pub fn builder() -&gt; #builder_ident {&#13;
                #builder_ident {&#13;
                    #(#builder_defaults),*&#13;
                }&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    proc_macro::TokenStream::from(output)&#13;
}&#13;
```&#13;
&#13;
## 验证结果 &#13;
&#13;
```rust&#13;
&#13;
#[derive(builder::Builder)]&#13;
pub struct Ad {&#13;
    id: u64,&#13;
    cids: Vec&lt;u64&gt;,&#13;
    title: String,&#13;
    bid: f32,&#13;
}&#13;
&#13;
fn main() {&#13;
    let mut builder = Ad::builder();&#13;
&#13;
    let ad = builder&#13;
        .bid(1.23)&#13;
        .id(193987829387)&#13;
        .cids(vec![1, 2, 3])&#13;
        .title('推广'.to_string())&#13;
        .build();&#13;
}&#13;
```&#13;
&#13;
&gt; cargo expand &#13;
&#13;
```rust&#13;
#![feature(prelude_import)]&#13;
#[prelude_import]&#13;
use std::prelude::rust_2021::*;&#13;
#[macro_use]&#13;
extern crate std;&#13;
pub struct Ad {&#13;
    id: u64,&#13;
    cids: Vec&lt;u64&gt;,&#13;
    title: String,&#13;
    bid: f32,&#13;
}&#13;
pub struct AdBuilder {&#13;
    id: std::option::Option&lt;u64&gt;,&#13;
    cids: std::option::Option&lt;Vec&lt;u64&gt;&gt;,&#13;
    title: std::option::Option&lt;String&gt;,&#13;
    bid: std::option::Option&lt;f32&gt;,&#13;
}&#13;
impl AdBuilder {&#13;
    pub fn id(&amp;mut self, value: u64) -&gt; &amp;mut Self {&#13;
        self.id = std::option::Option::Some(value);&#13;
        self&#13;
    }&#13;
    pub fn cids(&amp;mut self, value: Vec&lt;u64&gt;) -&gt; &amp;mut Self {&#13;
        self.cids = std::option::Option::Some(value);&#13;
        self&#13;
    }&#13;
    pub fn title(&amp;mut self, value: String) -&gt; &amp;mut Self {&#13;
        self.title = std::option::Option::Some(value);&#13;
        self&#13;
    }&#13;
    pub fn bid(&amp;mut self, value: f32) -&gt; &amp;mut Self {&#13;
        self.bid = std::option::Option::Some(value);&#13;
        self&#13;
    }&#13;
}&#13;
impl AdBuilder {&#13;
    pub fn build(&#13;
        &amp;mut self,&#13;
    ) -&gt; std::result::Result&lt;Ad, std::boxed::Box&lt;dyn std::error::Error&gt;&gt; {&#13;
        std::result::Result::Ok(Ad {&#13;
            id: self.id.clone().unwrap(),&#13;
            cids: self.cids.clone().unwrap(),&#13;
            title: self.title.clone().unwrap(),&#13;
            bid: self.bid.clone().unwrap(),&#13;
        })&#13;
    }&#13;
}&#13;
impl Ad {&#13;
    pub fn builder() -&gt; AdBuilder {&#13;
        AdBuilder {&#13;
            id: std::option::Option::None,&#13;
            cids: std::option::Option::None,&#13;
            title: std::option::Option::None,&#13;
            bid: std::option::Option::None,&#13;
        }&#13;
    }&#13;
}&#13;
fn main() {&#13;
    let mut builder = Ad::builder();&#13;
    let ad = builder&#13;
        .bid(1.23)&#13;
        .id(193987829387)&#13;
        .cids(&lt;[_]&gt;::into_vec(#[rustc_box] ::alloc::boxed::Box::new([1, 2, 3])))&#13;
        .title('推广'.to_string())&#13;
        .build();&#13;
}&#13;
```。</description><guid isPermaLink="true">https://0x1042.github.io//post/19.html</guid><pubDate>Mon, 19 Feb 2024 16:19:05 +0000</pubDate></item><item><title>macro基本使用</title><link>https://0x1042.github.io//post/18.html</link><description># macro&#13;
&#13;
- [macro](#macro)&#13;
  - [字符串化](#字符串化)&#13;
  - [连接](#连接)&#13;
  - [变参宏](#变参宏)&#13;
  - [条件编译](#条件编译)&#13;
- [macro vs function](#macro-vs-function)&#13;
  - [宏优点](#宏优点)&#13;
  - [宏缺点](#宏缺点)&#13;
&#13;
&#13;
&gt; 一般我们在CR中不建议宏，因为无法做到类型安全以及可读性上比较差&#13;
&gt; 但是在一些业务无关的代码上，比如配置解析，可以有效减少重复代码 &#13;
&gt; 下面收集一些宏的常见使用 &#13;
&#13;
## 字符串化&#13;
&#13;
&gt; 简单说就是在符号的前后加上双引号。</description><guid isPermaLink="true">https://0x1042.github.io//post/18.html</guid><pubDate>Sat, 06 Jan 2024 07:38:15 +0000</pubDate></item><item><title>ml 扫盲二</title><link>https://0x1042.github.io//post/17.html</link><description># ML扫盲二&#13;
&#13;
- [ML扫盲二](#ml扫盲二)&#13;
- [环境搭建](#环境搭建)&#13;
- [机器学习的分类](#机器学习的分类)&#13;
  - [监督学习  `supervised learning`](#监督学习--supervised-learning)&#13;
  - [无监督学习 `unsupervised learning`](#无监督学习-unsupervised-learning)&#13;
  - [半监督学习 `semi-supervised learning`](#半监督学习-semi-supervised-learning)&#13;
  - [强化学习 `reinforcement learning`](#强化学习-reinforcement-learning)&#13;
- [回归  regression](#回归--regression)&#13;
- [线性回归 linear regression](#线性回归-linear-regression)&#13;
  - [什么是线性回归](#什么是线性回归)&#13;
  - [损失函数 loss function](#损失函数-loss-function)&#13;
  - [随机梯度下降](#随机梯度下降)&#13;
  - [from zero](#from-zero)&#13;
  - [use tf](#use-tf)&#13;
- [非线性回归 Non-linear Regression](#非线性回归-non-linear-regression)&#13;
- [逻辑回归 logistic regression](#逻辑回归-logistic-regression)&#13;
  - [分类问题](#分类问题)&#13;
  - [网络结构](#网络结构)&#13;
  - [损失函数](#损失函数)&#13;
  - [use tf](#use-tf-1)&#13;
- [学习资料](#学习资料)&#13;
&#13;
#  环境搭建 &#13;
&#13;
```shell&#13;
&#13;
# 开发机启动jupyter notebook &#13;
&#13;
nohup jupyter notebook --no-browser --port=8889 &amp;&#13;
&#13;
# 本地端口转发 &#13;
ssh -N -f -L localhost:8888:localhost:8889 ubuntu&#13;
```&#13;
&#13;
# 机器学习的分类&#13;
&#13;
## 监督学习  `supervised learning`&#13;
&#13;
&gt; **训练数据包含正确的结果（label），即希望学习或者预估的目标.**&#13;
&#13;
- 监督学习建立一个学习过程，将预测结果与 “训练数据”（即输入数据）的实际结果进行比较，不断的调整预测模型，直到模型的预测结果达到一个预期的准确率，比如分类和回归问题等。</description><guid isPermaLink="true">https://0x1042.github.io//post/17.html</guid><pubDate>Sat, 23 Dec 2023 10:37:27 +0000</pubDate></item><item><title>C++打印环境变量</title><link>https://0x1042.github.io//post/16.html</link><description># 获取所有的环境变量 &#13;
&#13;
- [获取所有的环境变量](#获取所有的环境变量)&#13;
  - [`main` 函数方式获取](#main-函数方式获取)&#13;
  - [`environ`读取](#environ读取)&#13;
&#13;
## `main` 函数方式获取 &#13;
&#13;
```cpp&#13;
&#13;
auto main(int argc, char ** argv, char ** envp) -&gt; int {&#13;
    logEnv(envp);&#13;
}&#13;
&#13;
void logEnv(char ** envp) {&#13;
    LOG(INFO) &lt;&lt; 'current pid is ' &lt;&lt; getpid();&#13;
    for (char ** this_env = envp; *this_env != nullptr; ++this_env) {&#13;
        LOG(INFO) &lt;&lt; 'env:' &lt;&lt; std::string(*this_env);&#13;
    }&#13;
}&#13;
```&#13;
&#13;
&#13;
## `environ`读取 &#13;
&#13;
&gt; 等同 `cat /proc/${PID}/environ | tr '\0' '\n'`&#13;
&#13;
```cpp&#13;
&#13;
auto main() -&gt; int {&#13;
    logEnv2();&#13;
}&#13;
&#13;
void logEnv2() {&#13;
    pid_t pid = getpid();&#13;
    std::clog &lt;&lt; 'current pid is ' &lt;&lt; pid &lt;&lt; '\n';&#13;
    std::string envfile = '/proc/' + std::to_string(pid) + '/environ';&#13;
&#13;
    std::ifstream input(envfile);&#13;
&#13;
    std::string envkv;&#13;
    while (!input.eof()) {&#13;
        std::getline(input, envkv, '\0');&#13;
        std::clog &lt;&lt; envkv &lt;&lt; '\n';&#13;
    }&#13;
&#13;
    input.close();&#13;
}&#13;
```&#13;
。</description><guid isPermaLink="true">https://0x1042.github.io//post/16.html</guid><pubDate>Sun, 17 Dec 2023 15:11:33 +0000</pubDate></item><item><title>ML hello world</title><link>https://0x1042.github.io//post/15.html</link><description># 神经网络简介&#13;
&#13;
- [神经网络简介](#神经网络简介)&#13;
  - [训练过程](#训练过程)&#13;
  - [传播](#传播)&#13;
  - [如何计算损失](#如何计算损失)&#13;
  - [如何优化](#如何优化)&#13;
  - [梯度下降](#梯度下降)&#13;
  - [学习率](#学习率)&#13;
  - [激活函数](#激活函数)&#13;
  - [tensor](#tensor)&#13;
- [操作过程](#操作过程)&#13;
- [单变量线性回归](#单变量线性回归)&#13;
  - [构建模型](#构建模型)&#13;
  - [训练](#训练)&#13;
  - [测试](#测试)&#13;
  - [多变量线性回归模型](#多变量线性回归模型)&#13;
    - [模型训练](#模型训练)&#13;
    - [验证](#验证)&#13;
- [参考](#参考)&#13;
&#13;
![神经网络](https://github.com/0x1042/0x1042.github.io/assets/7525242/86419435-239d-424d-afd2-021096a0c932)&#13;
&#13;
&#13;
给定1000个相亲对象的数据**特征**(**feature**),和对应的满意程度**标签**(**label**)，训练完成后，给定新的相亲对象数据来预测满意程度，即预估(**predict**)&#13;
&#13;
## 训练过程 &#13;
&#13;
&gt; 训练模型的目标是从所有样本中找到一组平均损失“较小”的权重（w）和偏差（b）。</description><guid isPermaLink="true">https://0x1042.github.io//post/15.html</guid><pubDate>Sun, 10 Dec 2023 14:15:07 +0000</pubDate></item><item><title>智能指针以及new</title><link>https://0x1042.github.io//post/14.html</link><description># 智能指针自定义deleter&#13;
&#13;
- [智能指针自定义deleter](#智能指针自定义deleter)&#13;
  - [函数指针](#函数指针)&#13;
  - [函数对象](#函数对象)&#13;
  - [`lambda`函数](#lambda函数)&#13;
- [对象池](#对象池)&#13;
- [`new`](#new)&#13;
  - [`new operator` 是关键字](#new-operator-是关键字)&#13;
  - [`operator new` 是一个函数](#operator-new-是一个函数)&#13;
  - [`placement new` 是`operator new`的重载](#placement-new-是operator-new的重载)&#13;
&#13;
## 函数指针 &#13;
&#13;
```cpp&#13;
void deleteVec(int * ptr) {&#13;
    delete[] ptr;&#13;
}&#13;
&#13;
TEST_CASE('test deleter', '[fb_pointer]') {&#13;
    std::unique_ptr&lt;int, decltype(&amp;deleteVec)&gt; my_ptr(new int[5], deleteVec);&#13;
}&#13;
```&#13;
## 函数对象 &#13;
&#13;
```cpp&#13;
template &lt;typename T&gt;&#13;
struct CustomDeleter {&#13;
    void operator()(T * t) const {&#13;
        delete t;&#13;
        std::clog &lt;&lt; 'CustomDeleter run... delete type is ' &lt;&lt; infra::Name&lt;T&gt;().name &lt;&lt; '\n';&#13;
    }&#13;
};&#13;
&#13;
TEST_CASE('test deleter', '[fb_obj]') {&#13;
    std::unique_ptr&lt;int, CustomDeleter&lt;int&gt;&gt; int_ptr(new int);&#13;
    std::unique_ptr&lt;double, CustomDeleter&lt;double&gt;&gt; double_ptr(new double);&#13;
}&#13;
```&#13;
&#13;
## `lambda`函数&#13;
&#13;
```cpp&#13;
TEST_CASE('test deleter', '[lambda]') {&#13;
    auto deleter = [](int * ptr) {&#13;
        delete[] ptr;&#13;
        std::clog &lt;&lt; ' delete by lambda ...' &lt;&lt; '\n';&#13;
    };&#13;
    std::unique_ptr&lt;int, decltype(deleter)&gt; arr(new int[5], deleter);&#13;
}&#13;
```&#13;
&#13;
# 对象池&#13;
&#13;
&#13;
- 要缓存的对象&#13;
&#13;
```cpp&#13;
class Object {&#13;
public:&#13;
    Object(const Object &amp;) = default;&#13;
    Object(Object &amp;&amp;) = delete;&#13;
    auto operator=(const Object &amp;) -&gt; Object &amp; = default;&#13;
    auto operator=(Object &amp;&amp;) -&gt; Object &amp; = delete;&#13;
    explicit Object(int id) : id(id) { std::clog &lt;&lt; 'Object ' &lt;&lt; id &lt;&lt; ' is created.\n'; }&#13;
&#13;
    ~Object() { std::cout &lt;&lt; 'Object ' &lt;&lt; id &lt;&lt; ' is destroyed.\n'; }&#13;
&#13;
    void doSomething() const;&#13;
&#13;
    [[nodiscard]] auto getId() const -&gt; int;&#13;
    void setId(int id_);&#13;
&#13;
private:&#13;
    int id;&#13;
};&#13;
```&#13;
&#13;
- 定义对象池 &#13;
&#13;
```cpp&#13;
&#13;
// pool.h &#13;
class ObjectPool {&#13;
public:&#13;
    struct ObjectDeleter {&#13;
        void operator()(Object * obj) {&#13;
            std::clog &lt;&lt; 'fake delete ' &lt;&lt; obj-&gt;getId() &lt;&lt; '\n';&#13;
            obj-&gt;setId(0);&#13;
            pool.push_back(obj);&#13;
        }&#13;
    };&#13;
&#13;
    static auto acquire() -&gt; std::unique_ptr&lt;Object, ObjectDeleter&gt;;&#13;
&#13;
    static auto size() -&gt; size_t;&#13;
&#13;
private:&#13;
    inline static std::vector&lt;Object *&gt; pool; // 对象池&#13;
};&#13;
&#13;
// pool.cpp&#13;
auto ObjectPool::acquire() -&gt; std::unique_ptr&lt;Object, ObjectDeleter&gt; {&#13;
    if (pool.empty()) {&#13;
        // return std::unique_ptr&lt;Object, ObjectDeleter&gt;(new Object(0), ObjectDeleter());&#13;
        return {new Object(0), ObjectDeleter()};&#13;
    }&#13;
    Object * obj = pool.back();&#13;
    pool.pop_back();&#13;
    // return std::unique_ptr&lt;Object, ObjectDeleter&gt;(obj, ObjectDeleter());&#13;
    return {obj, ObjectDeleter()};&#13;
}&#13;
&#13;
auto ObjectPool::size() -&gt; size_t {&#13;
    return pool.size();&#13;
}&#13;
```&#13;
&#13;
&#13;
# `new`&#13;
&#13;
## `new operator` 是关键字 &#13;
&#13;
就是`new` 关键字 `T *t = new T();` 背后包含两个动作&#13;
&#13;
1. 调用 `operator new` 分配内存 ,并返回指向该对象的指针 &#13;
2. 调用`T`的构造函数 &#13;
3. 不可被重载 &#13;
&#13;
&#13;
## `operator new` 是一个函数 &#13;
&#13;
是一个动态内存分配的函数 &#13;
&#13;
```cpp&#13;
void* operator new(std::size_t size);&#13;
```&#13;
&#13;
- 只分配所要求的空间，不调用相关对象的构造函数&#13;
- 当无法满足所要求分配的空间时&#13;
  - 如果有`new_handler`，则调用`new_handler`&#13;
  - 否则如果没要求不抛出异常（以nothrow参数表达），则执行bad_alloc异常，否则&#13;
  - 否则返回0&#13;
- 可以被重载，重载时，返回类型必须声明为`void*`&#13;
- 第一个参数类型必须为表达要求分配空间的大小（字节），类型为size_t,可以有其他参数&#13;
&#13;
&#13;
## `placement new` 是`operator new`的重载&#13;
&#13;
&gt; 原型&#13;
&#13;
```cpp&#13;
void *operator new( size_t, void * p ) throw() { return p; }&#13;
```&#13;
&#13;
1. 是重载`operator new`的一个标准、全局的版本，它不能够被自定义的版本代替(不像普通版本的operator new和operator delete能够被替换)&#13;
2. 执行忽略`size_t`参数，只返回第二个参数。</description><guid isPermaLink="true">https://0x1042.github.io//post/14.html</guid><pubDate>Fri, 01 Dec 2023 14:56:01 +0000</pubDate></item><item><title>c++中获取类定义的完整名字</title><link>https://0x1042.github.io//post/13.html</link><description># 说明&#13;
&#13;
&gt; 仅限于读取类定义&#13;
&#13;
```cpp&#13;
&#13;
#include &lt;memory&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
#include &lt;cxxabi.h&gt;&#13;
&#13;
template &lt;typename T&gt;&#13;
struct Name {&#13;
    Name() {&#13;
        std::unique_ptr&lt;char, decltype(free) *&gt; real_name(abi::__cxa_demangle(typeid(T).name(), nullptr, nullptr, nullptr), free);&#13;
        this-&gt;name = std::string(real_name.get());&#13;
    }&#13;
&#13;
    std::string name{};&#13;
};&#13;
&#13;
```&#13;
&#13;
测试 &#13;
&#13;
```cpp&#13;
namespace tests {&#13;
&#13;
namespace a::b::c {&#13;
    class A {};&#13;
} // namespace a::b::c&#13;
&#13;
namespace na {&#13;
    class B {};&#13;
} // namespace na&#13;
&#13;
namespace a::b::d {&#13;
    struct C {};&#13;
} // namespace a::b::d&#13;
&#13;
TEST_CASE('test name', '[name]') {&#13;
    // tests::a::b::c::A&#13;
    LOG(INFO) &lt;&lt; 'infra::Name&lt;a::b::c::A&gt;().name:' &lt;&lt; infra::Name&lt;a::b::c::A&gt;().name;&#13;
    // tests::na::B&#13;
    LOG(INFO) &lt;&lt; 'infra::Name&lt;na::B&gt;().name:' &lt;&lt; infra::Name&lt;na::B&gt;().name;&#13;
    // tests::a::b::d::C&#13;
    LOG(INFO) &lt;&lt; 'infra::Name&lt;a::b::d::C&gt;().name:' &lt;&lt; infra::Name&lt;a::b::d::C&gt;().name;&#13;
}&#13;
} // namespace tests&#13;
```&#13;
。</description><guid isPermaLink="true">https://0x1042.github.io//post/13.html</guid><pubDate>Mon, 27 Nov 2023 15:28:20 +0000</pubDate></item><item><title>七、`constexpr` </title><link>https://0x1042.github.io//post/12.html</link><description># constexpr 元编程&#13;
&#13;
- [constexpr 元编程](#constexpr-元编程)&#13;
  - [`constexpr` 变量](#constexpr-变量)&#13;
  - [`constinit` 初始化](#constinit-初始化)&#13;
  - [`constexpr` 函数](#constexpr-函数)&#13;
  - [`consteval` 函数](#consteval-函数)&#13;
- [`if constexpr`](#if-constexpr)&#13;
- [折叠表达式](#折叠表达式)&#13;
  - [右折叠](#右折叠)&#13;
  - [左折叠](#左折叠)&#13;
- [令人头大的`const`](#令人头大的const)&#13;
  - [`int const* ptr`](#int-const-ptr)&#13;
  - [`int * const ptr`](#int--const-ptr)&#13;
  - [终极CASE](#终极case)&#13;
&#13;
## `constexpr` 变量&#13;
&#13;
**与`const`变量的区别？**&#13;
&#13;
- `constexpr` 需要保证表达式可在编译时求值，否则会出现编译错误 &#13;
- `const` 表达式拥有常量性。</description><guid isPermaLink="true">https://0x1042.github.io//post/12.html</guid><pubDate>Sun, 26 Nov 2023 10:44:29 +0000</pubDate></item><item><title>六、协程实现细节</title><link>https://0x1042.github.io//post/11.html</link><description># 协程实现细节&#13;
&#13;
- [协程实现细节](#协程实现细节)&#13;
- [协程的生命周期](#协程的生命周期)&#13;
  - [`promise_type`](#promise_type)&#13;
  - [协程类](#协程类)&#13;
  - [`coroutine_handle`](#coroutine_handle)&#13;
- [协程的调度](#协程的调度)&#13;
  - [`co_await`](#co_await)&#13;
  - [`co_yield`](#co_yield)&#13;
&#13;
&#13;
# 协程的生命周期 &#13;
&#13;
![call_routine](https://github.com/0x1042/0x1042.github.io/assets/7525242/f155fdff-fff4-49eb-88cb-500b55bd63ea)&#13;
&#13;
&#13;
1. 调用函数在**堆**上，创建协程帧(`coroutine_frame`)，里面包含了协程的`promise_type`,协程的实参，当前保存的局部变量，协程内部状态如挂起点. 由编译器实现&#13;
2. 创建协程帧之后，会返回给调用者`coroutine_handle`,也叫协程句柄，是控制协程的唯一入口，可以被传递到其他地方&#13;
3. 调用被调用协程，协程开始执行&#13;
4. 被调用协程执行到某个特定点，通过`co_await/co_yield` 将当前协程休眠，调用者恢复原本的执行流程继续执行剩余代码&#13;
5. 协程恢复者（比如另一个线程）通过`coroutine_handle`的恢复函数`resume` 恢复协程执行&#13;
6. 协程在恢复者上继续执行，结束后通过 `coroutine_handle` 销毁协程帧。</description><guid isPermaLink="true">https://0x1042.github.io//post/11.html</guid><pubDate>Sat, 18 Nov 2023 19:03:14 +0000</pubDate></item><item><title>五、协程基本使用</title><link>https://0x1042.github.io//post/10.html</link><description># 协程 ~~入门~~&#13;
&#13;
- [协程 ~~入门~~](#协程-入门)&#13;
  - [定义](#定义)&#13;
  - [基本原理](#基本原理)&#13;
    - [一、协程栈帧(编译器生成)](#一协程栈帧编译器生成)&#13;
    - [二、创建协程](#二创建协程)&#13;
    - [三、协程恢复(\_\_fibonacciResume)](#三协程恢复__fibonacciresume)&#13;
    - [四、销毁](#四销毁)&#13;
- [实现一个协程](#实现一个协程)&#13;
  - [定义 `Generator`](#定义-generator)&#13;
  - [定义 `promise_type`](#定义-promise_type)&#13;
  - [定义协程函数](#定义协程函数)&#13;
- [参考](#参考)&#13;
&#13;
&#13;
## 定义 &#13;
&#13;
c++20的协程定义是一个**可暂停、可恢复**的函数，具体到实现上，如果函数包含`co_await、co_yield、co_return` 关键字之一，就会被认为是协程&#13;
&#13;
![coroutine](https://github.com/0x1042/0x1042.github.io/assets/7525242/c2954b77-82a6-4a8f-b3a8-740adb8a9852)&#13;
&#13;
&#13;
- 暂停，即意味着需要保存函数执行过程中产生的上下文&#13;
- 恢复，调用方可以获取到这个协程在堆上的控制入口&#13;
&#13;
| 关键字      | 说明         |&#13;
| ----------- | ------------ |&#13;
| `co_await`  | 挂起         |&#13;
| `co_yield`  | 挂起并返回值 |&#13;
| `co_return` | 结束协程     |&#13;
&#13;
## 基本原理 &#13;
&#13;
参考 [C++20 Coroutine][1],[C++20协程][2].  核心是有编译器针对协程函数做patch，生成新的代码，区别于有栈协程，需要有对应的runtime来调度.&#13;
&#13;
可以在 [cppinsights.io](https://cppinsights.io) 上打开 `Show coroutine transformation` 选项，查看详细的细节，生成的结果中有注释，是一个近似的结果&#13;
&#13;
### 一、协程栈帧(编译器生成)&#13;
&#13;
```cpp&#13;
struct __fibonacciFrame&#13;
{&#13;
  void (*resume_fn)(__fibonacciFrame *);  // 协程恢复函数 &#13;
  void (*destroy_fn)(__fibonacciFrame *); // 协程销毁函数 &#13;
  std::coroutine_traits&lt;std::coroutine_handle&lt;promise&gt;, int&gt;::promise_type __promise; // 协程的promise_type&#13;
  int __suspend_index;&#13;
  bool __initial_await_suspend_called;&#13;
  int a;&#13;
  int i;&#13;
  int j;&#13;
  std::suspend_never __suspend_47_27;&#13;
  std::suspend_always __suspend_51_9;&#13;
  std::suspend_always __suspend_47_27_1;&#13;
};&#13;
```&#13;
&#13;
### 二、创建协程&#13;
&#13;
&gt; 调用方调用协程函数时(`fibonacci()`)，编译器会生成类似下面的代码, 这个函数的返回值时 `std::coroutine_handle&lt;promise&gt;`,也就是上面说的 协程的控制点(句柄)&#13;
&gt; 而这个返回值是通过 协程的 promise_type 对应的 get_return_object 函数获取&#13;
&#13;
```cpp&#13;
std::coroutine_handle&lt;promise&gt; fibonacci(int a)&#13;
{&#13;
  /* Allocate the frame including the promise */&#13;
  /* Note: The actual parameter new is __builtin_coro_size */&#13;
  __fibonacciFrame * __f = reinterpret_cast&lt;__fibonacciFrame *&gt;(operator new(sizeof(__fibonacciFrame)));&#13;
  __f-&gt;__suspend_index = 0;&#13;
  __f-&gt;__initial_await_suspend_called = false;&#13;
  __f-&gt;a = std::forward&lt;int&gt;(a);&#13;
  &#13;
  /* Construct the promise. */&#13;
  new (&amp;__f-&gt;__promise)std::coroutine_traits&lt;std::coroutine_handle&lt;promise&gt;, int&gt;::promise_type{__f-&gt;a};&#13;
  &#13;
  /* Forward declare the resume and destroy function. */&#13;
  void __fibonacciResume(__fibonacciFrame * __f);&#13;
  void __fibonacciDestroy(__fibonacciFrame * __f);&#13;
  &#13;
  /* Assign the resume and destroy function pointers. */&#13;
  __f-&gt;resume_fn = &amp;__fibonacciResume;&#13;
  __f-&gt;destroy_fn = &amp;__fibonacciDestroy;&#13;
  &#13;
  /* Call the made up function with the coroutine body for initial suspend.&#13;
     This function will be called subsequently by coroutine_handle&lt;&gt;::resume()&#13;
     which calls __builtin_coro_resume(__handle_) */&#13;
  __fibonacciResume(__f);&#13;
  &#13;
  &#13;
  return __f-&gt;__promise.get_return_object();&#13;
}&#13;
```&#13;
&#13;
&#13;
### 三、协程恢复(__fibonacciResume)&#13;
&#13;
&gt; 这个是协程的核心执行逻辑，也就是编译器patch后的结果 &#13;
&gt; 核心是 调用协程的promise_type相关的方法  &#13;
&#13;
```cpp&#13;
/* This function invoked by coroutine_handle&lt;&gt;::resume() */&#13;
void __fibonacciResume(__fibonacciFrame * __f)&#13;
{&#13;
  try &#13;
  {&#13;
    /* Create a switch to get to the correct resume point */&#13;
    switch(__f-&gt;__suspend_index) {&#13;
      case 0: break;&#13;
      case 1: goto __resume_fibonacci_1;&#13;
      case 2: goto __resume_fibonacci_2;&#13;
    }&#13;
    &#13;
    /* co_await insights.cpp:47 */&#13;
    __f-&gt;__suspend_47_27 = __f-&gt;__promise.initial_suspend();&#13;
    if(!__f-&gt;__suspend_47_27.await_ready()) {&#13;
      __f-&gt;__suspend_47_27.await_suspend(std::coroutine_handle&lt;promise&gt;::from_address(static_cast&lt;void *&gt;(__f)).operator std::coroutine_handle&lt;void&gt;());&#13;
      __f-&gt;__suspend_index = 1;&#13;
      __f-&gt;__initial_await_suspend_called = true;&#13;
      return;&#13;
    } &#13;
    &#13;
    __resume_fibonacci_1:&#13;
    __f-&gt;__suspend_47_27.await_resume();&#13;
    __f-&gt;i = 1;&#13;
    __f-&gt;j = __f-&gt;a;&#13;
    while(1) {&#13;
      std::tie(__f-&gt;i, __f-&gt;j).operator=(std::make_pair(__f-&gt;j, __f-&gt;i + __f-&gt;j));&#13;
      &#13;
      /* co_yield insights.cpp:51 */&#13;
      __f-&gt;__suspend_51_9 = __f-&gt;__promise.yield_value(__f-&gt;j);&#13;
      if(!__f-&gt;__suspend_51_9.await_ready()) {&#13;
        __f-&gt;__suspend_51_9.await_suspend(std::coroutine_handle&lt;promise&gt;::from_address(static_cast&lt;void *&gt;(__f)).operator std::coroutine_handle&lt;void&gt;());&#13;
        __f-&gt;__suspend_index = 2;&#13;
        return;&#13;
      } &#13;
      &#13;
      __resume_fibonacci_2:&#13;
      __f-&gt;__suspend_51_9.await_resume();&#13;
    }&#13;
    &#13;
    goto __final_suspend;&#13;
  } catch(...) {&#13;
    if(!__f-&gt;__initial_await_suspend_called) {&#13;
      throw ;&#13;
    } &#13;
    &#13;
    __f-&gt;__promise.unhandled_exception();&#13;
  }&#13;
  &#13;
  __final_suspend:&#13;
  &#13;
  /* co_await insights.cpp:47 */&#13;
  __f-&gt;__suspend_47_27_1 = __f-&gt;__promise.final_suspend();&#13;
  if(!__f-&gt;__suspend_47_27_1.await_ready()) {&#13;
    __f-&gt;__suspend_47_27_1.await_suspend(std::coroutine_handle&lt;promise&gt;::from_address(static_cast&lt;void *&gt;(__f)).operator std::coroutine_handle&lt;void&gt;());&#13;
  } &#13;
  &#13;
  ;&#13;
}&#13;
```&#13;
&#13;
### 四、销毁 &#13;
&#13;
```cpp&#13;
/* This function invoked by coroutine_handle&lt;&gt;::destroy() */&#13;
void __fibonacciDestroy(__fibonacciFrame * __f)&#13;
{&#13;
  /* destroy all variables with dtors */&#13;
  __f-&gt;~__fibonacciFrame();&#13;
  /* Deallocating the coroutine frame */&#13;
  /* Note: The actual argument to delete is __builtin_coro_frame with the promise as parameter */&#13;
  operator delete(static_cast&lt;void *&gt;(__f));&#13;
}&#13;
```&#13;
&#13;
**从编译器生成的代码看，如果要自己实现协程，就需要自定义这个协程的promise_type**&#13;
&#13;
`promise_type 必须包含一下成员函数`&#13;
&#13;
```cpp&#13;
SOME_TYPE get_return_object();//用于得到协程函数开始执行的返回值&#13;
SOME_TYPE initial_suspend();//用于协程函数开始执行时执行暂停操作&#13;
void return_void();//协程函数内部co_return终止返回void时执行的操作（和下面return_value同时只能有一个存在）&#13;
void return_value(SOME_TYPE);//协程函数内部co_return终止返回非void值时执行的操作&#13;
SOME_TYPE final_suspend()noexcept;//用于协程函数结束执行时执行暂停操作&#13;
void unhandled_exception();//用于协程函数内部有未接住的异常时执行&#13;
auto ield_value();&#13;
```&#13;
&#13;
&#13;
# 实现一个协程 &#13;
&#13;
## 定义 `Generator`&#13;
&#13;
**约束范型的类型约束是无符号整数**&#13;
&#13;
```cpp&#13;
template &lt;typename T&gt;&#13;
concept integral = std::is_integral_v&lt;T&gt; &amp;&amp; !std::is_signed_v&lt;T&gt;;&#13;
&#13;
template &lt;integral T&gt;&#13;
struct FibPromise;&#13;
&#13;
template &lt;integral T&gt;&#13;
struct FibGenerator {&#13;
    using promise_type = FibPromise&lt;T&gt;;&#13;
&#13;
    std::coroutine_handle&lt;promise_type&gt; handler;&#13;
&#13;
    auto next() -&gt; int {&#13;
        handler.resume();&#13;
        return handler.promise().value;&#13;
    }&#13;
&#13;
    explicit FibGenerator(promise_type * p)&#13;
        : handler{std::coroutine_handle&lt;promise_type&gt;::from_promise(*p)} {&#13;
    }&#13;
&#13;
    ~FibGenerator() {&#13;
        handler.destroy();&#13;
    }&#13;
};&#13;
```&#13;
&#13;
## 定义 `promise_type`&#13;
&#13;
```cpp&#13;
template &lt;integral T&gt;&#13;
struct FibPromise {&#13;
    std::exception_ptr exception;&#13;
&#13;
    FibPromise() = default;&#13;
&#13;
    FibPromise(T val)&#13;
        : value(val) {&#13;
    }&#13;
&#13;
    FibGenerator&lt;T&gt; get_return_object() { return FibGenerator{this}; }&#13;
&#13;
    auto initial_suspend() noexcept -&gt; std::suspend_always { return {}; }&#13;
&#13;
    auto final_suspend() noexcept -&gt; std::suspend_always { return {}; }&#13;
&#13;
    auto yield_value(T val) -&gt; std::suspend_always {&#13;
        value = val;&#13;
        return {};&#13;
    }&#13;
&#13;
    auto return_value(T val) -&gt; std::suspend_always {&#13;
        value = val;&#13;
        return {};&#13;
    }&#13;
    // void return_void() {}&#13;
&#13;
    void unhandled_exception() { exception = std::current_exception(); }&#13;
&#13;
    T value;&#13;
};&#13;
```&#13;
&#13;
## 定义协程函数&#13;
&#13;
```cpp&#13;
inline FibGenerator&lt;uint32_t&gt; fib(uint32_t n) {&#13;
    uint32_t first = 0;&#13;
    uint32_t second = 1;&#13;
    while (n--) {&#13;
        co_yield second;&#13;
        const auto tmp = first;&#13;
        first = second;&#13;
        second += tmp;&#13;
    }&#13;
}&#13;
&#13;
&#13;
// 测试 &#13;
void test_fib() {&#13;
    auto gen = fib(10);&#13;
    for (int i = 0; i &lt; 10; i++) {&#13;
        std::clog &lt;&lt; gen.next() &lt;&lt; '\n';&#13;
    }&#13;
}&#13;
```&#13;
&#13;
# 参考 &#13;
&#13;
[1]: https://owent.net/2019/1904.html  'C++20 Coroutine'&#13;
[2]: https://z3475.work/post/c20-xie-cheng-mai-xiang-yi-bu-part1-zui-jian-dan-de-xie-cheng/  '[C++20协程]迈向异步 Part1-最简单的协程'&#13;
&#13;
&#13;
。</description><guid isPermaLink="true">https://0x1042.github.io//post/10.html</guid><pubDate>Sat, 18 Nov 2023 14:20:07 +0000</pubDate></item><item><title>四、concept</title><link>https://0x1042.github.io//post/9.html</link><description># concept&#13;
&#13;
- [concept](#concept)&#13;
  - [基本定义和使用](#基本定义和使用)&#13;
  - [约束表达式](#约束表达式)&#13;
  - [`requires` 表达式](#requires-表达式)&#13;
  - [`requires` 子句](#requires-子句)&#13;
  - [`concepts` header](#concepts-header)&#13;
&#13;
## 基本定义和使用&#13;
&#13;
- 基本定义&#13;
```cpp&#13;
// 语法格式&#13;
// template&lt;typename T&gt;&#13;
// concept concept_name = constraint-expression(约束表达式);&#13;
&#13;
template &lt;typename T&gt;&#13;
concept integral = std::is_integral_v&lt;T&gt;;&#13;
&#13;
template &lt;typename T&gt;&#13;
concept floating_point = std::is_floating_point_v&lt;T&gt;;&#13;
&#13;
template &lt;typename T&gt;&#13;
concept C = std::is_integral_v&lt;T&gt; || (sizeof(T) &gt; 1);&#13;
&#13;
template &lt;typename T, typename U&gt;&#13;
concept Derived = std::is_base_of_v&lt;U, T&gt;;&#13;
&#13;
```&#13;
&#13;
- 基本使用 **使用`concept_name` 替换 `typename`**&#13;
&#13;
```cpp&#13;
&#13;
// 定义 &#13;
class Base {&#13;
public:&#13;
    [[nodiscard]] auto getValue() const -&gt; int32_t { return value; }&#13;
&#13;
    explicit Base(const int32_t value)&#13;
        : value(value) {&#13;
    }&#13;
&#13;
private:&#13;
    int32_t value;&#13;
};&#13;
&#13;
template &lt;typename T&gt;&#13;
concept DerivedBase = std::is_base_of_v&lt;Base, T&gt;;&#13;
&#13;
// 使用concept_name 替换 typename&#13;
template &lt;DerivedBase T&gt;&#13;
auto doGetValue(const T &amp; t) -&gt; int32_t {&#13;
    return t.getValue();&#13;
}&#13;
&#13;
class DerivedClass : public Base {&#13;
public:&#13;
    explicit DerivedClass(int32_t value)&#13;
        : Base(value) {&#13;
    }&#13;
&#13;
    [[nodiscard]] auto getValue() const -&gt; int32_t { return 1024; }&#13;
};&#13;
```&#13;
&#13;
## 约束表达式&#13;
&#13;
- 合取式 conjunctions，逻辑与 &#13;
```cpp&#13;
template &lt;typename T&gt;&#13;
concept integral = std::is_integral_v&lt;T&gt;;&#13;
&#13;
template &lt;typename T&gt;&#13;
concept signed_int = integral&lt;T&gt; &amp;&amp; std::is_signed_v&lt;T&gt;;&#13;
&#13;
```&#13;
- 析取式 disjunctions，逻辑或&#13;
&#13;
```cpp&#13;
template &lt;typename T&gt;&#13;
concept integral = std::is_integral_v&lt;T&gt;;&#13;
&#13;
template &lt;typename T&gt;&#13;
concept floating_point = std::is_floating_point_v&lt;T&gt;;&#13;
&#13;
template &lt;typename T&gt;&#13;
concept number = integral&lt;T&gt; || floating_point&lt;T&gt;;&#13;
&#13;
```&#13;
- 原子约束 atomic constraints &#13;
&#13;
```cpp&#13;
```&#13;
&#13;
## `requires` 表达式&#13;
&#13;
&gt; 除了使用`type traits` 定义概念之外，也可以使用 `requires` 表达式来表达对模板参数及其对象的特征要求&#13;
&gt; 成员函数、自由函数、关联类型等&#13;
&#13;
- 基本语法 &#13;
&#13;
```cpp&#13;
&#13;
requires(可选参数列表) {&#13;
    表达式1&#13;
    表达式2&#13;
}&#13;
&#13;
```&#13;
&#13;
- 基本约束 &#13;
```cpp&#13;
template &lt;typename T&gt;&#13;
concept Machine = requires(T t)&#13;
{&#13;
    // 要求存在同名的成员函数&#13;
    t.powerup();&#13;
&#13;
    t.powerDown();&#13;
    // 要求存在成员变量name&#13;
    t.name;&#13;
    // 要求存在静态成员count&#13;
    T::count;&#13;
};&#13;
&#13;
template &lt;typename T&gt;&#13;
concept Animal = requires(T t1, T t2, T t3)&#13;
{&#13;
    // 要求存在 name 成员变量&#13;
    t1.name;&#13;
&#13;
    // 要求能够进行判等操作&#13;
    t1 == t2;&#13;
&#13;
    // 要求能够进行 加、乘操作&#13;
    t1 + t2 * t3;&#13;
};&#13;
&#13;
```&#13;
&#13;
- 类型约束 &#13;
```cpp&#13;
template &lt;typename T&gt;&#13;
concept C2 = requires&#13;
{&#13;
    // 要求存在类型成员 type&#13;
    typename T::type;&#13;
&#13;
    // 要求能够与vector 组合，实现模板实例化&#13;
    typename std::vector&lt;T&gt;;&#13;
};&#13;
```&#13;
&#13;
- 组合约束 **需要大括号括起来**&#13;
```cpp&#13;
template &lt;typename T&gt;&#13;
concept C3 = requires(T t1, T t2) {&#13;
    // 表达式不能有异常&#13;
    { t1 = std::move(t2) } noexcept;&#13;
&#13;
    // 要求接口返回类型与T一致&#13;
    { t1.get_info() } -&gt; std::same_as&lt;T&gt;;&#13;
&#13;
    // 要求接口返回类型能够转换成float&#13;
    { t1.get_unit() } -&gt; std::convertible_to&lt;float&gt;;&#13;
};&#13;
&#13;
```&#13;
&#13;
- 嵌套约束 &#13;
```cpp&#13;
template &lt;typename T&gt;&#13;
concept C3 = requires {&#13;
    requires sizeof(T) &gt; 4;&#13;
};&#13;
```&#13;
&#13;
## `requires` 子句&#13;
&#13;
&gt; 用于判断所约束的类型在上下文中 是否可行&#13;
&#13;
**上下文** 感觉是废话，concept 不就是为了简化模板编程么，肯定只能在模板编程中存在 &#13;
&#13;
1. 函数模板&#13;
2. 模板类 &#13;
3. 模板类的成员函数 &#13;
&#13;
```cpp&#13;
// 这里是 require 子句(区别与require 表达式)&#13;
template &lt;typename T&gt;&#13;
    requires std::is_integral_v&lt;T&gt;&#13;
auto add(T t1, T t2) -&gt; T {&#13;
    return t1 + t2;&#13;
}&#13;
&#13;
// 编译成功&#13;
add(1, 2);&#13;
//  note: candidate template ignored: constraints not satisfied [with T = double]&#13;
//  note: because 'std::is_integral_v&lt;double&gt;' evaluated to false&#13;
// add(1.2, 2.2);&#13;
```&#13;
&#13;
## `concepts` header&#13;
&#13;
```cpp&#13;
&#13;
// 想同类&#13;
template &lt;typename T, typename U&gt;&#13;
concept same_as = std::is_same_v&lt;T, U&gt;;&#13;
&#13;
// 是否是派生关系 &#13;
template &lt;typename Base, typename Derived&gt;&#13;
concept derived_from = std::is_base_of_v&lt;Base, Derived&gt; &amp;&amp; std::is_convertible_v&lt;std::add_cv_t&lt;Derived *&gt;, std::add_cv_t&lt;Base *&gt;&gt;;&#13;
&#13;
// 是否可转换&#13;
template &lt;typename F, typename T&gt;&#13;
concept convertible_to = std::is_convertible_v&lt;F, T&gt; &amp;&amp; requires(std::add_rvalue_reference_t&lt;F&gt; (&amp;f)()) { static_cast&lt;T&gt;(f()); };&#13;
&#13;
```。</description><guid isPermaLink="true">https://0x1042.github.io//post/9.html</guid><pubDate>Sat, 18 Nov 2023 11:51:47 +0000</pubDate></item><item><title>虚拟机使用宿主机代理</title><link>https://0x1042.github.io//post/8.html</link><description># mac 虚拟机使用代理 &#13;
&#13;
- [mac 虚拟机使用代理](#mac-虚拟机使用代理)&#13;
  - [安装`gost`](#安装gost)&#13;
  - [执行gost](#执行gost)&#13;
  - [虚拟机配置](#虚拟机配置)&#13;
&#13;
## 安装`gost`&#13;
&#13;
```shell&#13;
# 安装gost &#13;
&#13;
git clone https://github.com/go-gost/gost.git&#13;
cd gost/cmd/gost&#13;
go build&#13;
```&#13;
&#13;
## 执行gost&#13;
&#13;
```shell&#13;
# 宿主机侧在8080端口的HTTP代理服务，使用本地的1087端口做为上级代理进行转发&#13;
./gost -L http://:8080 -F http://127.0.0.1:1087&#13;
```&#13;
&#13;
## 虚拟机配置&#13;
&#13;
```shell&#13;
&#13;
# shell&#13;
export https_proxy=http://10.0.0.67:8080 http_proxy=http://10.0.0.67:8080&#13;
# git &#13;
git config --global http.proxy 'http://10.0.0.67:8080'&#13;
```。</description><guid isPermaLink="true">https://0x1042.github.io//post/8.html</guid><pubDate>Sat, 18 Nov 2023 08:46:24 +0000</pubDate></item><item><title>GDB 使用 </title><link>https://0x1042.github.io//post/7.html</link><description>&#13;
- [GDB 使用](#gdb-使用)&#13;
  - [背景](#背景)&#13;
  - [GDB dump线程栈](#gdb-dump线程栈)&#13;
  - [找到负载高的线程](#找到负载高的线程)&#13;
  - [寻找对应的行号](#寻找对应的行号)&#13;
&#13;
&#13;
## 背景&#13;
&#13;
&gt; 线上流量没变，但是出现瞬时负载呈直线上涨，1～2分钟整个服务不可用。</description><guid isPermaLink="true">https://0x1042.github.io//post/7.html</guid><pubDate>Fri, 17 Nov 2023 12:57:31 +0000</pubDate></item><item><title>三、编译时多态</title><link>https://0x1042.github.io//post/6.html</link><description># 编译时多态&#13;
&#13;
- [编译时多态](#编译时多态)&#13;
- [type traits 类型萃取](#type-traits-类型萃取)&#13;
  - [获取类型属性](#获取类型属性)&#13;
  - [类型变换](#类型变换)&#13;
  - [标签分发](#标签分发)&#13;
  - [迭代器](#迭代器)&#13;
  - [`if constexpr`](#if-constexpr)&#13;
  - [`void_t` 元函数](#void_t-元函数)&#13;
- [CTRTP 奇异递归模版模式](#ctrtp-奇异递归模版模式)&#13;
  - [代码复用](#代码复用)&#13;
  - [静态绑定](#静态绑定)&#13;
  - [`enable_shared_from_this`](#enable_shared_from_this)&#13;
&#13;
&#13;
# type traits 类型萃取&#13;
&#13;
&gt; c++ 通过模版实现泛型编程，从而减轻运行时开销。</description><guid isPermaLink="true">https://0x1042.github.io//post/6.html</guid><pubDate>Sun, 12 Nov 2023 08:40:02 +0000</pubDate></item><item><title>二、c++中的类型推导</title><link>https://0x1042.github.io//post/5.html</link><description>- [类型推导](#类型推导)&#13;
- [`auto`](#auto)&#13;
- [`decltype`](#decltype)&#13;
  - [不带括号(获取的是标识符 定义时的类型)](#不带括号获取的是标识符-定义时的类型)&#13;
  - [带括号 获取表达式的值类别](#带括号-获取表达式的值类别)&#13;
- [`decltype(auto)`](#decltypeauto)&#13;
- [`CTAD` 类模板参数推导](#ctad-类模板参数推导)&#13;
&#13;
# 类型推导 &#13;
&#13;
# `auto`&#13;
&#13;
**auto 是值语义，即通过移动/拷贝构造，不会保留cv属性，如果需要保留cv属性，需要显式指定**&#13;
&#13;
```cpp&#13;
class Cat {};&#13;
&#13;
auto get_cat() -&gt; Cat *;&#13;
&#13;
auto get_const_cat() -&gt; const Cat *;&#13;
&#13;
&#13;
Cat cat{};&#13;
Cat * cat1 = &amp;cat;&#13;
const Cat * cat2 = &amp;cat;&#13;
&#13;
Cat &amp; lr_cat = cat;&#13;
const Cat &amp; ltc_cat = cat;&#13;
Cat&amp;&amp; rr_cat = Cat{};&#13;
```&#13;
&#13;
| 表达式                         | auto推导的类型 |&#13;
| ------------------------------ | -------------- |&#13;
| `auto ccat1 = cat`             | `Cat`          |&#13;
| `auto ccat2 = cat1`            | `Cat*`         |&#13;
| `auto ccat3 = cat2`            | `const Cat*`   |&#13;
| `auto ccat4 = get_cat()`       | `Cat*`         |&#13;
| `auto ccat5 = get_const_cat()` | `const Cat*`   |&#13;
| `auto ccat6 = lr_cat`          | `Cat`          |&#13;
| `auto ccat7 = ltc_cat`         | `Cat`          |&#13;
| `auto ccat8 = rr_cat`          | `Cat`          |&#13;
| `auto &amp; ccat9 = lr_cat`        | `Cat&amp;`         |&#13;
| `const auto &amp; ccat10 = lr_cat` | `const Cat&amp;`   |&#13;
| `auto &amp; ccat11 = ltc_cat`      | `const Cat&amp;`   |&#13;
| `auto &amp;&amp; ccat12 = cat`         | `Cat&amp;`         |&#13;
| `auto &amp;&amp; ccat13 = Cat{}`       | `Cat&amp;&amp;`        |&#13;
&#13;
&#13;
# `decltype`&#13;
&#13;
&gt; 作用：获取 标识符被定义时的类型或者 整体作为 表达式 时的值类别&#13;
&#13;
- 参数带括号 decltype((T))，获取作为表达式时的 值类别&#13;
- 参数不带括号 decltype(T), 获取标识符 定义时的类型 &#13;
&#13;
```cpp&#13;
class Student {&#13;
public:&#13;
    uint32_t id{0};&#13;
    std::string name;&#13;
};&#13;
&#13;
inline void test_decltype() {&#13;
    Student student;&#13;
    Student * st_ptr = &amp;student;&#13;
    const Student * st_cptr = &amp;student;&#13;
    Student &amp; st_ref = student;&#13;
    Student &amp;&amp; st_tmp = {};&#13;
}&#13;
```&#13;
&#13;
## 不带括号(获取的是标识符 定义时的类型)&#13;
&#13;
| 表达式                                            | 类型             |&#13;
| ------------------------------------------------- | ---------------- |&#13;
| `using T1 = decltype(student)`                    | `Student`        |&#13;
| `using T2 = decltype(st_ptr)`                     | `Student*`       |&#13;
| `using T3 = decltype(st_cptr)`                    | `const Student*` |&#13;
| `using T4 = decltype(st_ref)`                     | `Student&amp;`       |&#13;
| `using T5 = decltype(st_tmp)`                     | `Student&amp;&amp;`      |&#13;
| `using T6 = decltype(student.id)`                 | `uint32_t`       |&#13;
| `using T7 = decltype(Student{1024, '张三'}.name)` | `std::string`    |&#13;
&#13;
## 带括号 获取表达式的值类别&#13;
&#13;
| 表达式                                              | 类型               |&#13;
| --------------------------------------------------- | ------------------ |&#13;
| `using T1 = decltype((student))`                    | `Student&amp;`         |&#13;
| `using T2 = decltype((st_ptr))`                     | `Student* &amp;`       |&#13;
| `using T3 = decltype((st_cptr))`                    | `const Student* &amp;` |&#13;
| `using T4 = decltype((st_ref))`                     | `Student&amp;`         |&#13;
| `using T5 = decltype((st_tmp))`                     | `Student&amp;`         |&#13;
| `using T6 = decltype((student.id))`                 | `uint32_t&amp;`        |&#13;
| `using T7 = decltype((Student{1024, '张三'}))`      | `Student`          |&#13;
| `using T8 = decltype((Student{1024, '张三'}.name))` | `std::string&amp;&amp;`    |&#13;
| `using T9 = decltype((++student.id))`               | `uint32_t&amp;`        |&#13;
| `using T10 = decltype((student.id++))`              | `uint32_t`         |&#13;
&#13;
- 如果表达式是左值，那么 `decltype((exp))` 就是左值引用（T1-&gt;T6）&#13;
- `st_tmp`的类型是 右值引用，但是作为表达式，可以被取地址，所以是左值引用&#13;
- `T7` 原始表达式是一个纯右值，`decltype((exp))` 是右值（不带引用）&#13;
- `T8` 是一个将亡值&#13;
- `T9` ++x作为表达式是左值&#13;
- `T10` x++作为表达式是右值&#13;
&#13;
# `decltype(auto)`&#13;
&#13;
&gt; 默认使用`auto`时，丢失了引用性和`cv`属性，若指明了 `const`属性，则导致结果始终为`const`，若采用引用，则需要显示指定`auto&amp;` 或者 `auto&amp;&amp;`,这又会导致只能表现为 引用语义。</description><guid isPermaLink="true">https://0x1042.github.io//post/5.html</guid><pubDate>Sat, 11 Nov 2023 14:48:08 +0000</pubDate></item><item><title>一、c++中的值类型</title><link>https://0x1042.github.io//post/4.html</link><description># 值类别 &#13;
&#13;
- [值类别](#值类别)&#13;
  - [如何区分左值和右值](#如何区分左值和右值)&#13;
  - [函数参数匹配](#函数参数匹配)&#13;
  - [值类型](#值类型)&#13;
  - [万能引用 **universal reference**](#万能引用-universal-reference)&#13;
  - [引用折叠 **reference collapsing**](#引用折叠-reference-collapsing)&#13;
  - [完美转发 **perfect forward**](#完美转发-perfect-forward)&#13;
&#13;
## 如何区分左值和右值&#13;
&#13;
```c++&#13;
void log(std::string_view message, std::source_location location) {&#13;
    std::clog &lt;&lt; 'file: ' &lt;&lt; location.file_name() &lt;&lt; '(' &lt;&lt; location.line() &lt;&lt; ':' &lt;&lt; location.column() &lt;&lt; ') `' &lt;&lt; location.function_name()&#13;
              &lt;&lt; '`: ' &lt;&lt; message &lt;&lt; '\n';&#13;
}&#13;
&#13;
void foo(int &amp; /*val*/) {&#13;
    log('foo1');&#13;
}&#13;
&#13;
void foo(int &amp;&amp; /*val*/) {&#13;
    log('foo2');&#13;
}&#13;
```&#13;
&#13;
```cpp&#13;
int &amp;&amp; value = 1024;&#13;
foo(value); // 调用的是 void foo(int &amp;)&#13;
```&#13;
&#13;
- 匿名的临时对象是右值，具名的右值引用对象是左值 &#13;
- 如果表达式可以取地址，则为左值表达式，否则，为右值表达式&#13;
- 表达式 value 是具名的右值引用对象，value 也可以取地址，所以 表达式value 是一个左值，匹配第一个函数&#13;
&#13;
## 函数参数匹配&#13;
&#13;
| 参数类型      | 说明                                     |&#13;
| ------------- | ---------------------------------------- |&#13;
| Value&amp;        | 只能匹配左值表达式                       |&#13;
| Value&amp;&amp;       | 只能绑定右值表达式（模板函数下单独讨论） |&#13;
| const Value&amp;  | 可以匹配左值和右值表达式                 |&#13;
| const Value&amp;&amp; | 实际不使用                               |&#13;
&#13;
&#13;
## 值类型 &#13;
&#13;
- 泛左值： 左值 和 将亡值&#13;
- 右值：纯右值 和 将亡值&#13;
- `static_cast&lt;Value&amp;&amp;&gt;(value)` 是将亡值，常见的将亡值是 函数的返回值 &#13;
![types](https://github.com/0x1042/0x1042.github.io/assets/7525242/0fae6f7f-bce8-41b6-ad2d-45cc312ec7b4)&#13;
&#13;
&#13;
## 万能引用 **universal reference** &#13;
&#13;
&gt; 如何区分 Arg&amp;&amp; 是右值引用还是万能引用？&#13;
&#13;
- **如果 Arg&amp;&amp; 是模板参数或者 auto，则是万能引用，「既可以接受左值，也可以接受右值」，否则为右值引用**&#13;
- **万能引用在类型推导语境下，可以保留类型的cv限定符「const和volatile」和值类别**&#13;
&#13;
## 引用折叠 **reference collapsing**&#13;
&#13;
&gt; 为了解决 reference to reference 的问题&#13;
&#13;
c++ 中不允许指向引用的引用，对于指向引用的引用会被简化，推导规则如下 &#13;
&#13;
```cpp&#13;
template &lt;typename T&gt;&#13;
void Example(T &amp;&amp; input) {}&#13;
```&#13;
&#13;
- 函数形参是左值，T&amp;，传入的实参是左值，即input 是 `T&amp; &amp;`&#13;
- 函数形参是左值，T&amp;，传入的实参是右值，即input 是 `T&amp; &amp;&amp;`&#13;
- 函数形参是右值，T&amp;&amp;，传入的实参是左值，即input 是 `T&amp;&amp; &amp;`&#13;
- 函数形参是右值，T&amp;&amp;，传入的实参是右值，即input 是 `T&amp;&amp; &amp;&amp;`&#13;
&#13;
推导规则是： **仅当两个都是右值引用时，推导为右值，其余情况为左值**，也就是 `T&amp;&amp; &amp;&amp;`为右值，其他情况为左值 &#13;
&#13;
&#13;
## 完美转发 **perfect forward** &#13;
&#13;
&gt; 在传参的过程中，保留参数的原始类型 &#13;
&#13;
```cpp&#13;
void foo(int &amp; val);&#13;
void foo(int &amp;&amp; val);&#13;
&#13;
template &lt;typename T&gt; void call_foo(T &amp;&amp; t) {&#13;
    foo(std::forward&lt;T&gt;(t));&#13;
}&#13;
```&#13;
&#13;
如何实现的？&#13;
&#13;
```cpp&#13;
template &lt;class _Tp&gt;&#13;
_LIBCPP_NODISCARD_EXT inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR _Tp&amp;&amp;&#13;
forward(_LIBCPP_LIFETIMEBOUND __libcpp_remove_reference_t&lt;_Tp&gt;&amp; __t) _NOEXCEPT {&#13;
  return static_cast&lt;_Tp&amp;&amp;&gt;(__t);&#13;
}&#13;
&#13;
template &lt;class _Tp&gt;&#13;
_LIBCPP_NODISCARD_EXT inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR _Tp&amp;&amp;&#13;
forward(_LIBCPP_LIFETIMEBOUND __libcpp_remove_reference_t&lt;_Tp&gt;&amp;&amp; __t) _NOEXCEPT {&#13;
  static_assert(!is_lvalue_reference&lt;_Tp&gt;::value, 'cannot forward an rvalue as an lvalue');&#13;
  return static_cast&lt;_Tp&amp;&amp;&gt;(__t);&#13;
}&#13;
```&#13;
&#13;
- Tp 是左值， `static_cast&lt;_Tp&amp;&amp;&gt;(__t)` 后是 T&amp; &amp;&amp;，按照引用折叠规则，`T&amp; &amp;&amp; -&gt; T&amp;`, Tp是左值 &#13;
- Tp 是右值， `static_cast&lt;_Tp&amp;&amp;&gt;(__t)` 后是 T&amp;&amp; &amp;&amp;，按照引用折叠规则，`T&amp;&amp; &amp;&amp; -&gt; T&amp;&amp;`, Tp是右值 。</description><guid isPermaLink="true">https://0x1042.github.io//post/4.html</guid><pubDate>Sat, 11 Nov 2023 08:48:15 +0000</pubDate></item><item><title>struct 使用生命周期标注</title><link>https://0x1042.github.io//post/3.html</link><description>```rust&#13;
#[derive(Debug)]&#13;
struct Sheep&lt;'c, 'd&gt; {&#13;
    age: &amp;'c u32,&#13;
    name: &amp;'d str,&#13;
}&#13;
&#13;
impl&lt;'c, 'd&gt; Sheep&lt;'c, 'd&gt; {&#13;
    /// Returns the get age of this [`Sheep`].&#13;
    pub fn get_age(&amp;self) -&gt; u32 {&#13;
        *self.age&#13;
    }&#13;
&#13;
    /// Returns the get name of this [`Sheep`].&#13;
    pub fn get_name(&amp;self) -&gt; String {&#13;
        self.name.to_owned()&#13;
    }&#13;
}&#13;
&#13;
#[cfg(test)]&#13;
mod tests {&#13;
    use super::Sheep;&#13;
    #[test]&#13;
    fn test_lt() {&#13;
        let age = 5;&#13;
        let name = 'dollor';&#13;
&#13;
        let sheep = Sheep {&#13;
            age: &amp;age,&#13;
            name: name,&#13;
        };&#13;
&#13;
        println!('name is {:?}', sheep.get_name());&#13;
        println!('age is {:?}', sheep.get_age());&#13;
&#13;
        println!('sheep :{:?}', sheep);&#13;
    }&#13;
}&#13;
```。</description><guid isPermaLink="true">https://0x1042.github.io//post/3.html</guid><pubDate>Wed, 01 Nov 2023 16:55:48 +0000</pubDate></item><item><title>golang中protobuf 反序列化性能优化</title><link>https://0x1042.github.io//post/2.html</link><description># 背景&#13;
&#13;
线上有一些公共使用的超大`protobuf`，部分单**message的field大于10000**。</description><guid isPermaLink="true">https://0x1042.github.io//post/2.html</guid><pubDate>Sat, 28 Oct 2023 09:07:59 +0000</pubDate></item><item><title>c++中实现golang中的defer功能</title><link>https://0x1042.github.io//post/1.html</link><description># 使用`folly`&#13;
&#13;
```c++&#13;
#include &lt;folly/ScopeGuard.h&gt;&#13;
&#13;
auto main() -&gt; int {&#13;
    std::string msg = 'exit...';&#13;
&#13;
    auto guard1 = folly::makeGuard([&amp;] { std::cerr &lt;&lt; 'from folly::makeGuard:' &lt;&lt; msg &lt;&lt; '\n'; });&#13;
&#13;
    std::cout &lt;&lt; 'Hello, World!' &lt;&lt; '\n';&#13;
    return 0;&#13;
}&#13;
&#13;
```&#13;
&#13;
# 自定义实现&#13;
&#13;
```c++&#13;
template &lt;typename Lambda&gt; &#13;
struct Defer : Lambda {&#13;
    ~Defer() { Lambda::operator()(); }&#13;
};&#13;
&#13;
template &lt;typename Lambda&gt; &#13;
Defer(Lambda) -&gt; Defer&lt;Lambda&gt;;&#13;
&#13;
auto main() -&gt; int {&#13;
    std::string msg = 'exit...';&#13;
&#13;
    Defer guard{[&amp;] { std::cerr &lt;&lt; msg &lt;&lt; '\n'; }};&#13;
&#13;
    std::cout &lt;&lt; 'Hello, World!' &lt;&lt; '\n';&#13;
    return 0;&#13;
}&#13;
```&#13;
。</description><guid isPermaLink="true">https://0x1042.github.io//post/1.html</guid><pubDate>Wed, 25 Oct 2023 15:57:21 +0000</pubDate></item></channel></rss>