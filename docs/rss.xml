<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Daily</title><link>https://0x1042.github.io/</link><description>æˆ‘è‡ªå€¾æ€€ï¼Œå›ä¸”éšæ„ã€‚</description><copyright>Daily</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://raw.githubusercontent.com/0x1042/0x1042.github.io/master/synthwave_option_4.png</url><title>avatar</title><link>https://0x1042.github.io/</link></image><lastBuildDate>Sat, 27 Sep 2025 09:37:53 +0000</lastBuildDate><managingEditor>Daily</managingEditor><ttl>60</ttl><webMaster>Daily</webMaster><item><title>bazel åŸºæœ¬ä½¿ç”¨</title><link>https://0x1042.github.io//post/54.html</link><description># bazel samples

## `use protobuf`

- `MODULE.bazel`

```bazel{highlight=1 .line-numbers}
bazel_dep(name = 'protobuf', version = '32.1')
bazel_dep(name = 'rules_proto', version = '7.1.0')
```

- `app/BUILD.bazel`

```bazel{highlight=1 .line-numbers}
load('@protobuf//bazel:cc_proto_library.bzl', 'cc_proto_library')
load('@rules_cc//cc:defs.bzl', 'cc_binary', 'cc_library')
load('@rules_proto//proto:defs.bzl', 'proto_library')

proto_library(
    name = 'graph_proto',
    srcs = [
        'idls/graph.proto',
    ],
    visibility = ['//visibility:public'],
)

cc_proto_library(
    name = 'graph_cc_proto',
    visibility = ['//visibility:public'],
    deps = [':graph_proto'],
)
```

## `replace malloc`

```starlark{highlight=1 .line-numbers}
bazel_dep(name = 'mimalloc', version = '2.2.4')

cc_binary(
    name = 'unittest2',
    srcs = [
        'main.cc',
    ],
    copts = DEFAULT_COPTS,
    linkopts = DEFAULT_LINKOPTS,
    malloc = '@mimalloc',
    deps = [
        '@mimalloc//:mimalloc-api'
    ],
)
```

```CPP{highlight=1 .line-numbers}
#include &lt;mimalloc.h&gt;

auto main(int argc, char ** argv) -&gt; int {
    LOG(INFO) &lt;&lt; 'mimalloc version ' &lt;&lt; mi_version();
    return RUN_ALL_TESTS();
}
```
ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/54.html</guid><pubDate>Sat, 27 Sep 2025 09:37:32 +0000</pubDate></item><item><title>google colab cuda ç¼–ç¨‹</title><link>https://0x1042.github.io//post/53.html</link><description># ç¯å¢ƒæ­å»º 

## è¿æ¥åˆ°GPUå®ä¾‹

&gt; change runtime type -&gt; GPU

&lt;img width='1098' height='992' alt='Image' src='https://github.com/user-attachments/assets/d4ad2c85-d936-496d-bbe4-fcfef1c7ee2e' /&gt;

## æ£€æŸ¥çŠ¶æ€ 

```python
!nvcc --version
!nvidia-smi
```

```
nvcc: NVIDIA (R) Cuda compiler driver
Copyright (c) 2005-2024 NVIDIA Corporation
Built on Thu_Jun__6_02:18:23_PDT_2024
Cuda compilation tools, release 12.5, V12.5.82
Build cuda_12.5.r12.5/compiler.34385749_0
Sun Sep 21 07:02:16 2025       
+-----------------------------------------------------------------------------------------+
| NVIDIA-SMI 550.54.15              Driver Version: 550.54.15      CUDA Version: 12.4     |
|-----------------------------------------+------------------------+----------------------+
| GPU  Name                 Persistence-M | Bus-Id          Disp.A | Volatile Uncorr. ECC |
| Fan  Temp   Perf          Pwr:Usage/Cap |           Memory-Usage | GPU-Util  Compute M. |
|                                         |                        |               MIG M. |
|=========================================+========================+======================|
|   0  Tesla T4                       Off |   00000000:00:04.0 Off |                    0 |
| N/A   60C    P8             10W /   70W |       0MiB /  15360MiB |      0%      Default |
|                                         |                        |                  N/A |
+-----------------------------------------+------------------------+----------------------+
                                                                                         
+-----------------------------------------------------------------------------------------+
| Processes:                                                                              |
|  GPU   GI   CI        PID   Type   Process name                              GPU Memory |
|        ID   ID                                                               Usage      |
|=========================================================================================|
|  No running processes found                                                             |
+-----------------------------------------------------------------------------------------+
```

## å®‰è£…æ’ä»¶ 

```python
!pip install nvcc4jupyter
%load_ext nvcc4jupyter
```

## ä¿®å¤ç‰ˆæœ¬ 

from [learning-cuda-on-a-budget-on-google](https://leetarxiv.substack.com/p/learning-cuda-on-a-budget-on-google)

```
%%cuda -c '-I /does/not/exist -arch sm_75'
```

# hello world

```cuda
%%cuda -c '-I /does/not/exist -arch sm_75'
#include &lt;stdio.h&gt;

// This is a special function that runs on the GPU (device) instead of the CPU (host)
__global__ void kernel() {
  printf('Hello world!\n');
}

int main() {
  // Invoke the kernel function on the GPU with one block of one thread
  kernel&lt;&lt;&lt;1,1&gt;&gt;&gt;();

  // Check for error codes (remember to do this for _every_ CUDA function)
  if(cudaDeviceSynchronize() != cudaSuccess) {
    fprintf(stderr, 'CUDA Error: %s\n', cudaGetErrorString(cudaPeekAtLastError()));
  }
  return 0;
}
```

&lt;img width='2190' height='962' alt='Image' src='https://github.com/user-attachments/assets/7e5977be-514c-46df-a8fc-98587725b3d5' /&gt;


# åŸºæœ¬æœ¯è¯­


## å‡½æ•°ä¿®é¥°ç¬¦

| ä¿®é¥°ç¬¦                | å«ä¹‰                                    | å¤‡æ³¨                                                     |
| --------------------- | --------------------------------------- | -------------------------------------------------------- |
| `__global__`          | æ ‡è®°æ ¸å‡½æ•°                              | åœ¨`host`(CPU) ç«¯è°ƒç”¨ï¼Œç”±`device`ï¼ˆGPUï¼‰ç«¯æ‰§è¡Œ            |
| `__device__`          | æ ‡è®°è®¾å¤‡å‡½æ•°                            | åªèƒ½åœ¨ GPU ä¸Šè°ƒç”¨å’Œæ‰§è¡Œï¼Œä¸èƒ½ä» CPU ç«¯ç›´æ¥è°ƒç”¨           |
| `__host__`            | æ ‡è®°ä¸»æœºå‡½æ•°ï¼Œåœ¨CPUä¸Šæ‰§è¡Œï¼ˆé»˜è®¤ä¿®é¥°ç¬¦ï¼‰ | åªèƒ½åœ¨ CPU ä¸Šè°ƒç”¨å’Œæ‰§è¡Œï¼ˆå®é™…ä¸Š C++ æ™®é€šå‡½æ•°é»˜è®¤å°±hostï¼‰ |
| `__host__ __device__` |                                         | å¯ä»¥åŒæ—¶åœ¨CPUå’ŒGPUä¸Šç¼–è¯‘æ‰§è¡Œ                             |

## å˜é‡ä¿®é¥°ç¬¦

| ä¿®é¥°ç¬¦         | å«ä¹‰                                |
| -------------- | ----------------------------------- |
| `__shared__`   | å£°æ˜å…±äº«å†…å­˜å˜é‡ï¼Œ`block`å†…çº¿ç¨‹å…±äº« |
| `__constant__` | å£°æ˜å¸¸é‡å†…å­˜å˜é‡ï¼Œåªè¯»ä¸”æœ‰ç¼“å­˜      |
| `__device__`   | å£°æ˜å…¨å±€è®¾å¤‡å˜é‡                    |


## æ‰§è¡Œæ¨¡å‹

| æ¦‚å¿µ     | å«ä¹‰                                                                         |
| -------- | ---------------------------------------------------------------------------- |
| `Kernel` | åœ¨GPUä¸Šå¹¶è¡Œæ‰§è¡Œçš„å‡½æ•°ï¼Œç±»ä¼¼äºCPUçš„å‡½æ•°ä½†ä¼šè¢«æ•°åƒä¸ªçº¿ç¨‹åŒæ—¶æ‰§è¡Œ               |
| `Grid`   | block çš„é›†åˆï¼Œä¸€ä¸ª kernel å¯åŠ¨æ—¶ä¼šæŒ‡å®šä¸€ä¸ª gridï¼Œgrid å†…åŒ…å«å¤šä¸ª block       |
| `Block`  | çº¿ç¨‹çš„é›†åˆï¼Œä¸€ä¸ª kernel çš„æ‰§è¡Œå¯ä»¥åˆ†ä¸ºå¤šä¸ª blockï¼Œæ¯ä¸ª block å†…æœ‰å¤šä¸ª thread |
| `Thread` | GPU çš„æœ€å°æ‰§è¡Œå•å…ƒï¼Œæ¯ä¸ª kernel å¯åŠ¨åä¼šå¹¶è¡Œè¿è¡Œè®¸å¤šçº¿ç¨‹                     |


## å†…å­˜å±‚çº§ 

## å†…ç½®å˜é‡ 


| æ¦‚å¿µ              | å«ä¹‰                    |
| ----------------- | ----------------------- |
| `threadIdx.x/y/z` | å½“å‰çº¿ç¨‹åœ¨blockä¸­çš„ç´¢å¼• |
| `blockIdx.x/y/z`  | å½“å‰blockåœ¨gridä¸­çš„ç´¢å¼• |
| `blockDim.x/y/z`  | blockçš„ç»´åº¦å¤§å°         |
| `gridDim.x/y/z`   | gridçš„ç»´åº¦å¤§å°          |



# è¯­æ³•

```
&lt;&lt;&lt;Dg, Db, Ns, S&gt;&gt;&gt;(args)
- Dg. Gridç»´åº¦ 
- Db. Blockç»´åº¦
- Ns. åŠ¨æ€å…±äº«å†…å­˜å¤§å°
- S. Streamï¼Œç”¨äºå¼‚æ­¥æ‰§è¡Œ
```ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/53.html</guid><pubDate>Sun, 21 Sep 2025 07:15:22 +0000</pubDate></item><item><title>async</title><link>https://0x1042.github.io//post/52.html</link><description># å¼‚æ­¥

## çº¿ç¨‹

åŒæ­¥çš„å®ç°

```C++
auto get(const std::string &amp;url) -&gt; std::string {
  ScopedTimer timer(__PRETTY_FUNCTION__);
  cpr::Response rsp = cpr::Get(cpr::Url{url});
  return rsp.text;
}
```

### `std::async`

```C++
auto get_async(const std::string &amp;url) -&gt; std::future&lt;std::string&gt; {
  return std::async(std::launch::async, get, url);
}

TEST(get, get2) {
  const std::string url = 'https://www.bilibili.com';
  auto &amp;&amp;rsp = get_async(url);
  LOG(INFO) &lt;&lt; 'get async start ';
  const auto &amp;content = rsp.get();
  LOG(INFO) &lt;&lt; 'content is ' &lt;&lt; content;
}
```

### `std::packaged_task`

&gt; [!Tip]
&gt; &lt;ins&gt;**1. packaged_task å‚æ•°æ˜¯ä¸€ä¸ªæ— å‚çš„å¯è°ƒç”¨å¯¹è±¡**&lt;/ins&gt;
&gt; &lt;ins&gt;**2. åœ¨ä»»åŠ¡è¢«æ‰§è¡Œå‰ï¼Œå…ˆè·å–å®ƒçš„ future**&lt;/ins&gt;
&gt; &lt;ins&gt;**3. å°†ä»»åŠ¡æäº¤åˆ°çº¿ç¨‹æ± **&lt;/ins&gt;

```c++
auto get_async2(const std::string &amp;url) -&gt; std::future&lt;std::string&gt; {
  auto fn = [url]() { return get(url); };

  std::packaged_task&lt;std::string()&gt; task(std::move(fn));
  std::future&lt;std::string&gt; future = task.get_future();
  thread_pool()-&gt;add([t = std::move(task)]() mutable { t(); });

  return future;
}
```

### `folly::via`

```C++
auto get_async3(const std::string &amp;url) -&gt; folly::Future&lt;std::string&gt; {
  return folly::via(thread_pool().get(), [url]() { return get(url); });
}
```

## åç¨‹

&gt; todoã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/52.html</guid><pubDate>Sat, 14 Jun 2025 06:48:12 +0000</pubDate></item><item><title>iterator</title><link>https://0x1042.github.io//post/51.html</link><description># è¿­ä»£å™¨

## åŸç†

&lt;ins&gt;**å½“ç¼–è¯‘å™¨çœ‹åˆ° `for (auto&amp; element : container)` æ—¶ï¼Œå®ƒä¼šå¤§è‡´å°†å…¶è½¬æ¢ä¸ºå¦‚ä¸‹çš„ç­‰ä»·ä»£ç :**&lt;/ins&gt;

```C++
auto&amp;&amp; __range = container; // è·å–å®¹å™¨å¼•ç”¨
auto __begin = std::begin(__range); // è·å–èµ·å§‹è¿­ä»£å™¨
auto __end = std::end(__range);     // è·å–ç»“æŸè¿­ä»£å™¨
for (; __begin != __end; ++__begin) { // å¾ªç¯ç›´åˆ°ç»“æŸ
    auto&amp; element = *__begin;        // è§£å¼•ç”¨è¿­ä»£å™¨è·å–å…ƒç´ 
    // ... å¾ªç¯ä½“ ...
}
```

## åˆ†ç±» 

```mermaid
graph LR
    A[type] --&gt; B[å®¹å™¨çš„å°è£…ç±»å‹]
    A[type] --&gt; C[variant]
    A[type] --&gt; D[æ™®é€šç±»å‹]
```

## å®¹å™¨çš„å°è£…ç±»å‹

&gt; [!IMPORTANT]
&gt; &lt;ins&gt;**å®ç°`begin/end` ç­‰å‡½æ•°å³å¯**&lt;/ins&gt;


```c++
class VecWrap {
public:
    VecWrap(std::initializer_list&lt;int64_t&gt; list)
        : data_(list) {}

    auto begin() -&gt; std::vector&lt;int64_t&gt;::iterator { return data_.begin(); }

    auto end() -&gt; std::vector&lt;int64_t&gt;::iterator { return data_.end(); }

    [[nodiscard]] auto begin() const -&gt; std::vector&lt;int64_t&gt;::const_iterator { return data_.begin(); }

    [[nodiscard]] auto end() const -&gt; std::vector&lt;int64_t&gt;::const_iterator { return data_.end(); }

    [[nodiscard]] auto size() const -&gt; size_t { return data_.size(); }

    [[nodiscard]] auto empty() const -&gt; bool { return data_.empty(); }

private:
    std::vector&lt;int64_t&gt; data_;
};
```

## `variant`

```C++
struct Items {
    using ItemVec = std::variant&lt;
        std::monostate,
        std::vector&lt;Item1Ptr&gt;,
        std::vector&lt;Item2Ptr&gt;,
        std::vector&lt;Item3Ptr&gt;,
        std::vector&lt;Item4Ptr&gt;&gt;;

    ItemVec vec_;
};

void Items::range() {
    std::visit(
        [&amp;](const auto&amp; vec) {
            using VectorType = std::decay_t&lt;decltype(vec)&gt;;

            if constexpr (std::is_same_v&lt;std::vector&lt;Item1Ptr&gt;, VectorType&gt;)
            {
                LOG(INFO) &lt;&lt; 'Content of vector&lt;A&gt;:' &lt;&lt; std::endl;
                for (const Item1Ptr&amp; item : vec)
                {
                    LOG(INFO) &lt;&lt; 'is a. ' &lt;&lt; item-&gt;ida &lt;&lt; ' ' &lt;&lt; item-&gt;namea;
                }
            } else if constexpr (std::is_same_v&lt;std::vector&lt;Item2Ptr&gt;, VectorType&gt;)
            {
                LOG(INFO) &lt;&lt; 'Content of vector&lt;A&gt;:' &lt;&lt; std::endl;
                for (const Item2Ptr&amp; item : vec)
                {
                    LOG(INFO) &lt;&lt; 'is b. ' &lt;&lt; item-&gt;idb &lt;&lt; ' ' &lt;&lt; item-&gt;nameb;
                }
            } else if constexpr (std::is_same_v&lt;std::vector&lt;Item3Ptr&gt;, VectorType&gt;)
            {
                LOG(INFO) &lt;&lt; 'Content of vector&lt;A&gt;:' &lt;&lt; std::endl;
                for (const Item3Ptr&amp; item : vec)
                {
                    LOG(INFO) &lt;&lt; 'is c. ' &lt;&lt; item-&gt;idc &lt;&lt; ' ' &lt;&lt; item-&gt;namec;
                }
            } else if constexpr (std::is_same_v&lt;std::vector&lt;Item4Ptr&gt;, VectorType&gt;)
            {
                LOG(INFO) &lt;&lt; 'Content of vector&lt;A&gt;:' &lt;&lt; std::endl;
                for (const Item4Ptr&amp; item : vec)
                {
                    LOG(INFO) &lt;&lt; 'is d. ' &lt;&lt; item-&gt;idd &lt;&lt; ' ' &lt;&lt; item-&gt;named;
                }
            }
        },
        vec_);
}
```

## æ™®é€šç±»å‹

&gt; [!IMPORTANT]
&gt; &lt;ins&gt;**å®ç° å®¹å™¨ç±» (Container Class)ï¼šè´Ÿè´£å­˜å‚¨æ•°æ®å’ŒçŠ¶æ€**&lt;/ins&gt;
&gt; &lt;ins&gt;**è¿­ä»£å™¨ç±» (Iterator Class)ï¼šä¸€ä¸ªç‹¬ç«‹çš„ç±»ï¼ˆé€šå¸¸ä½œä¸ºå®¹å™¨çš„åµŒå¥—ç±»ï¼‰ï¼Œå®ƒçŸ¥é“å¦‚ä½•åœ¨å®¹å™¨ä¸­å¯¼èˆªï¼ˆç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªå…ƒç´ ï¼‰å¹¶è®¿é—®å½“å‰å…ƒç´ **&lt;/ins&gt;

### step1
&gt; [!IMPORTANT]
&gt; &lt;ins&gt;**å®šä¹‰å®¹å™¨å’Œè¿­ä»£å™¨çš„åŸºæœ¬ç»“æ„**&lt;/ins&gt;

```C++
template &lt;typename T, size_t N&gt;
class FixedArray {
private:
    T data_[N];
    size_t size_;

public:
    FixedArray()
        : size_(0) {}

    // å†…éƒ¨è¿­ä»£å™¨ç±»
    class iterator {
    public:
        using iterator_category = std::random_access_iterator_tag; // 1. ç±»åˆ«ï¼šè¿™æ˜¯æœ€å¼ºå¤§çš„ï¼Œæ”¯æŒéšæœºè®¿é—®
        using value_type = T; // 2. æ‰€æŒ‡å…ƒç´ çš„ç±»å‹
        using difference_type = std::ptrdiff_t; // 3. ä¸¤ä¸ªè¿­ä»£å™¨ç›¸å‡çš„ç»“æœç±»å‹
        using pointer = T*; // 4. æŒ‡å‘å…ƒç´ çš„æŒ‡é’ˆç±»å‹
        using reference = T&amp;; // 5. è§£å¼•ç”¨è¿”å›çš„å¼•ç”¨ç±»å‹
    };
};
```

### step2
&gt; [!IMPORTANT]
&gt; &lt;ins&gt;**å®ç°è¿­ä»£å™¨ç±» (iterator)**&lt;/ins&gt;

```C++
    class iterator {
    public:
        using iterator_category = std::random_access_iterator_tag; // 1. ç±»åˆ«ï¼šè¿™æ˜¯æœ€å¼ºå¤§çš„ï¼Œæ”¯æŒéšæœºè®¿é—®
        using value_type = T; // 2. æ‰€æŒ‡å…ƒç´ çš„ç±»å‹
        using difference_type = std::ptrdiff_t; // 3. ä¸¤ä¸ªè¿­ä»£å™¨ç›¸å‡çš„ç»“æœç±»å‹
        using pointer = T*; // 4. æŒ‡å‘å…ƒç´ çš„æŒ‡é’ˆç±»å‹
        using reference = T&amp;; // 5. è§£å¼•ç”¨è¿”å›çš„å¼•ç”¨ç±»å‹

    public:
        explicit iterator(pointer ptr)
            : ptr_(ptr) {}

        // --- æ ¸å¿ƒæ“ä½œç¬¦ ---
        // 1. è§£å¼•ç”¨ (Dereference) -&gt; è·å–å…ƒç´ 
        auto operator*() const -&gt; reference { return *ptr_; }
        auto operator-&gt;() const -&gt; pointer { return ptr_; }


        // 2. å‰ç½®é€’å¢ (Prefix Increment) -&gt; ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ª
        auto operator++() -&gt; iterator&amp; {
            ++ptr_;
            return *this;
        }
        // åç½®é€’å¢ (Postfix Increment)
        auto operator++(int) -&gt; iterator {
            iterator temp = *this;
            ++(*this);
            return temp;
        }


        // 3. æ¯”è¾ƒ (Comparison) -&gt; forå¾ªç¯çš„ç»ˆæ­¢æ¡ä»¶
        auto operator==(const iterator&amp; other) const -&gt; bool { return ptr_ == other.ptr_; }
        auto operator!=(const iterator&amp; other) const -&gt; bool { return ptr_ != other.ptr_; }

        // --- (å¯é€‰) ä¸º random_access_iterator_tag æä¾›æ›´å¤šæ“ä½œç¬¦ ---
        auto operator--() -&gt; iterator&amp; {
            --ptr_;
            return *this;
        }
        auto operator--(int) -&gt; iterator {
            iterator temp = *this;
            --(*this);
            return temp;
        }
        auto operator+=(difference_type offset) -&gt; iterator&amp; {
            ptr_ += offset;
            return *this;
        }
        auto operator+(difference_type offset) const -&gt; iterator {
            iterator temp = *this;
            temp += offset;
            return temp;
        }
        auto operator-=(difference_type offset) -&gt; iterator&amp; {
            ptr_ -= offset;
            return *this;
        }
        auto operator-(difference_type offset) const -&gt; iterator {
            iterator temp = *this;
            temp -= offset;
            return temp;
        }
        auto operator-(const iterator&amp; other) const -&gt; difference_type { return ptr_ - other.ptr_; }
        auto operator[](difference_type offset) const -&gt; reference { return ptr_[offset]; }
        auto operator&lt;(const iterator&amp; other) const -&gt; bool { return ptr_ &lt; other.ptr_; }

    private:
        pointer ptr_;
    };
```

### step3 

&gt; [!IMPORTANT]
&gt; &lt;ins&gt;**åœ¨å®¹å™¨ä¸­å®ç° begin() å’Œ end()**&lt;/ins&gt;

```C++
public:
    iterator begin() {
        return iterator(data_); // åˆ›å»ºä¸€ä¸ªæŒ‡å‘æ•°ç»„å¤´éƒ¨çš„è¿­ä»£å™¨
    }

    iterator end() {
        return iterator(data_ + N); // åˆ›å»ºä¸€ä¸ªæŒ‡å‘æ•°ç»„æœ«å°¾ä¹‹åä¸€ä¸ªä½ç½®çš„è¿­ä»£å™¨
    }
```

### step4 
&gt; [!IMPORTANT]
&gt; &lt;ins&gt;**const æ­£ç¡®æ€§ - å®ç° const_iterator**&lt;/ins&gt;

```C++
public:
    // (æ¥åœ¨ iterator ç±»å®šä¹‰ä¹‹å)
    class const_iterator {
        // å®ç°ä¸ iterator ç±»ä¼¼, ä½†æ‰€æœ‰è¿”å›çš„å¼•ç”¨å’ŒæŒ‡é’ˆéƒ½æ˜¯ const
    public:
        using iterator_category = std::random_access_iterator_tag;
        using value_type        = T;
        using difference_type   = std::ptrdiff_t;
        using pointer           = const T*; // æ³¨æ„è¿™é‡Œæ˜¯ const
        using reference         = const T&amp;; // æ³¨æ„è¿™é‡Œæ˜¯ const

    private:
        pointer ptr_;

    public:
        explicit const_iterator(pointer ptr) : ptr_(ptr) {}

        reference operator*() const { return *ptr_; }
        const_iterator&amp; operator++() { ++ptr_; return *this; }
        bool operator!=(const const_iterator&amp; other) const { return ptr_ != other.ptr_; }
    };


    // --- é const ç‰ˆæœ¬ï¼Œè¿”å›å¯ä¿®æ”¹çš„è¿­ä»£å™¨ ---
    iterator begin() { return iterator(data_); }
    iterator end()   { return iterator(data_ + N); }

    // --- const ç‰ˆæœ¬ï¼Œè¿”å›åªè¯»çš„è¿­ä»£å™¨ ---
    const_iterator begin() const { return const_iterator(data_); }
    const_iterator end() const   { return const_iterator(data_ + N); }

    // --- æ˜¾å¼çš„ const ç‰ˆæœ¬ (æœ€ä½³å®è·µ) ---
    const_iterator cbegin() const { return const_iterator(data_); }
    const_iterator cend() const   { return const_iterator(data_ + N); 
}
```
ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/51.html</guid><pubDate>Mon, 09 Jun 2025 17:52:57 +0000</pubDate></item><item><title>decltype &amp;&amp; declval</title><link>https://0x1042.github.io//post/50.html</link><description>
# decltype 

&lt;ins&gt;**decltypeæ˜¯ä¸€ä¸ªå…³é”®å­—,è€Œä¸æ˜¯å‡½æ•°,ç”¨äºåœ¨ç¼–è¯‘æœŸæ¨æ–­ä¸€ä¸ªè¡¨è¾¾å¼çš„ç±»å‹,ä¸ä¼šå®é™…è®¡ç®—è¡¨è¾¾å¼çš„å€¼**&lt;/ins&gt;


&gt; [!IMPORTANT]
&gt; decltype(expression): å¦‚æœ expression æ˜¯ä¸€ä¸ªæœªåŠ æ‹¬å·çš„ id-expression (æ ‡è¯†ç¬¦è¡¨è¾¾å¼ï¼Œå¦‚å˜é‡å) æˆ–è€…ä¸€ä¸ªæœªåŠ æ‹¬å·çš„ç±»æˆå‘˜è®¿é—®è¡¨è¾¾å¼ ( object.member æˆ– pointer-&gt;member ), è¿”å›è¯¥æ ‡è¯†ç¬¦æˆ–æˆå‘˜è¢«å£°æ˜æ—¶çš„ç±»å‹ (declared type)
&gt; - ä¾‹å¦‚ï¼Œå¦‚æœ int x = 0;ï¼Œé‚£ä¹ˆ decltype(x) å°±æ˜¯ intã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/50.html</guid><pubDate>Sat, 31 May 2025 15:44:17 +0000</pubDate></item><item><title>value</title><link>https://0x1042.github.io//post/49.html</link><description># value

## åˆ†ç±»

```mermaid
graph LR
    A[expression] --&gt; B[glvalue]
    A[expression] --&gt; C[rvalue]
    B --&gt; D[lvalue]
    B --&gt; E[xvalue]
    C --&gt; E[xvalue]
    C --&gt; F[prvalue]
```

- glvalue = lvalue + xvalue , æœ‰identity, å¯ä»¥è¢«å–åœ°å€
- rvalue = xvalue + prvalue , å¯ä»¥ç§»åŠ¨

## å¦‚ä½•åŒºåˆ†

&gt; [!Tip]
&gt; 1. æœ‰åå­—(`identity`)çš„éƒ½æ˜¯å·¦å€¼, å³ä¾¿æ˜¯å³å€¼å¼•ç”¨ å˜é‡æœ¬èº«,å½“å®ƒè¢«ç”¨ä½œè¡¨è¾¾å¼æ—¶,ä¹Ÿæ˜¯å·¦å€¼
&gt; 2. å¯ä»¥è¢«å–åœ°å€çš„,éƒ½æ˜¯å·¦å€¼
&gt; 3. &lt;ins&gt;**å­—ç¬¦ä¸²å­—é¢é‡æ˜¯å·¦å€¼**&lt;/ins&gt;,&lt;ins&gt;**å…¶ä»–å­—é¢é‡(42/MyClass{})æ˜¯å³å€¼**&lt;/ins&gt;
&gt; 4. `std::move(arg) `çš„ç»“æœæ˜¯ `xvalue`
&gt; 5. ä¸´æ—¶å¯¹è±¡ `MyClass()` æ˜¯ `prvalue`


## å‡½æ•°è¿”å›å€¼

1. &lt;ins&gt;**è¿”å›å·¦å€¼å¼•ç”¨ (T&amp; func())ï¼šç»“æœæ˜¯ lvalue.**&lt;/ins&gt;
2. &lt;ins&gt;**è¿”å›å³å€¼å¼•ç”¨ (T&amp;&amp; func())ï¼šç»“æœæ˜¯ xvalue.**&lt;/ins&gt;
3. &lt;ins&gt;**è¿”å›éå¼•ç”¨ç±»å‹/å€¼ç±»å‹ (T func())ï¼šç»“æœæ˜¯ prvalue.**&lt;/ins&gt;


## å­—ç¬¦ä¸²å­—é¢é‡

&gt; [!IMPORTANT]
&gt; `'hello world'` æ˜¯å·¦å€¼

- å­—ç¬¦ä¸²å­—é¢é‡åœ¨ç¨‹åºç¼–è¯‘åï¼Œä¼šè¢«å­˜å‚¨åœ¨å†…å­˜çš„ç‰¹å®šåŒºåŸŸï¼ˆé€šå¸¸æ˜¯åªè¯»æ•°æ®æ®µï¼‰ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/49.html</guid><pubDate>Sat, 31 May 2025 10:58:58 +0000</pubDate></item><item><title>trait</title><link>https://0x1042.github.io//post/48.html</link><description>
# trait

## å®šä¹‰

- æ˜¯ä¸€ä¸ª&lt;ins&gt;**ç±»æ¨¡æ¿**&lt;/ins&gt;,é€šå¸¸æ˜¯&lt;ins&gt;**struct**&lt;/ins&gt;
- ç”¨äºåœ¨&lt;ins&gt;**ç¼–è¯‘æ—¶è·å–æˆ–è€…æŸ¥è¯¢æŸä¸ªç±»å‹Tçš„ä¿¡æ¯æˆ–è€…å±æ€§**&lt;/ins&gt;
- ä¸åŒ…å«è¿è¡Œæ—¶æ•°æ®,é€šå¸¸é€šè¿‡&lt;ins&gt;**static constexpr æˆå‘˜**&lt;/ins&gt;æˆ–è€…&lt;ins&gt;**åµŒå¥—ç±»å‹åˆ«å(using type = ...)**&lt;/ins&gt;


## åŠŸèƒ½

- ç±»å‹ä¿¡æ¯æŸ¥è¯¢. æ¯”å¦‚&lt;ins&gt;**`std::is_integral&lt;T&gt;`**&lt;/ins&gt; æŸ¥è¯¢`T`æ˜¯å¦æ˜¯æ•´å½¢
- ç±»å‹è½¬æ¢/å…³è”. æ¯”å¦‚&lt;ins&gt;**`std::remove_pointer&lt;T*&gt;::type`**&lt;/ins&gt; ç§»é™¤`T`çš„æŒ‡é’ˆå±æ€§
- æ¡ä»¶ç¼–è¯‘. ä¸ &lt;ins&gt;**std::enable_if æˆ– if constexpr**&lt;/ins&gt; ç»“åˆ,æ ¹æ®ç±»å‹ç‰¹æ€§é€‰æ‹©ä¸åŒçš„ä»£ç è·¯å¾„

## åŸç†

- ä¸»æ¨¡æ¿ (Primary Template): &lt;ins&gt;**å®šä¹‰é€šç”¨çš„æƒ…å†µæˆ–é»˜è®¤å€¼**&lt;/ins&gt;
- æ¨¡æ¿ç‰¹åŒ– (Template Specialization): ä¸º&lt;ins&gt;**ç‰¹å®šç±»å‹æˆ–æ»¡è¶³ç‰¹å®šæ¡ä»¶çš„ç±»å‹æä¾›ç‰¹å®šçš„ä¿¡æ¯**&lt;/ins&gt;


## ğŸŒ°

```c++

// step 1
// ä¸»æ¨¡æ¿ å®šä¹‰é€šç”¨æƒ…å†µ
template &lt;typename T&gt;
struct is_my_void {
  static constexpr bool value = false;
};

// step 2
// ç‰¹åŒ–æ¨¡æ¿ å®šä¹‰ç‰¹ä¾‹æƒ…å†µ
template &lt;&gt; struct
is_my_void&lt;void&gt; {
  static constexpr bool value = true;
};

// step3 å¯é€‰ å®šä¹‰è¾…åŠ©å˜é‡
template &lt;typename T&gt;
inline constexpr bool is_my_void_v = is_my_void&lt;T&gt;::value;
```
ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/48.html</guid><pubDate>Tue, 27 May 2025 18:01:43 +0000</pubDate></item><item><title>äº¤å‰ç¼–è¯‘c++</title><link>https://0x1042.github.io//post/47.html</link><description># å®‰è£… 

## å®‰è£…åŸºç¡€ä¾èµ– 

```shell
sudo apt update
sudo apt install build-essential git curl make gcc libncurses-dev
```

## å®‰è£…ç¼–è¯‘å™¨

```
git clone https://github.com/richfelker/musl-cross-make.git

cat &lt;&lt; EOF &gt; config.mak
GCC_VER = 14.2.0
TARGET = mipsel-linux-musl
OUTPUT = /opt/musl-cross
GNU_SITE = https://mirrors.tuna.tsinghua.edu.cn/gnu/
EOF
```

&gt; target æ”¯æŒ

- `aarch64[_be]-linux-musl`
- `arm[eb]-linux-musleabi[hf]`
- `i*86-linux-musl`
- `microblaze[el]-linux-musl`
- `mips-linux-musl`
- `mips[el]-linux-musl[sf]`
- `mips64[el]-linux-musl[n32][sf]`
- `powerpc-linux-musl[sf]`
- `powerpc64[le]-linux-musl`
- `riscv64-linux-musl`
- `s390x-linux-musl`
- `sh*[eb]-linux-musl[fdpic][sf]`
- `x86_64-linux-musl[x32]`


&gt; Here Document

- è¯­æ³•

```shell
å‘½ä»¤ &lt;&lt; ç»ˆæ­¢ç¬¦
å¤šè¡Œæ–‡æœ¬å†…å®¹...
ç»ˆæ­¢ç¬¦

eg:

cat &lt;&lt; EOF 
hello
world
EOF 

ssh user@host &lt;&lt; EOF
ls -l
df -h
EOF

```

## ç¼–è¯‘

```shell
make -j$(nproc)
sudo make install
echo 'export PATH='/opt/musl-cross/bin:$PATH'' &gt;&gt; ~/.bashrc
source ~/.bashrc
```

## éªŒè¯

```shell
/opt/musl-cross/bin/mipsel-linux-musl-c++ --version
```

# `with meson`

## é…ç½®

```shell

cat &lt;&lt; EOF &gt; mips.ini
[constants]
toolchain = '/opt/musl-cross'
sysroot = toolchain + '/mipsel-linux-musl'

[binaries]
c = toolchain + '/bin/mipsel-linux-musl-cc'
cpp = toolchain + '/bin/mipsel-linux-musl-c++'
ar = toolchain + '/bin/mipsel-linux-musl-ar'
strip = toolchain + '/bin/mipsel-linux-musl-strip'

[properties]
sys_root = sysroot
debug = false
strip = true

[host_machine]
system = 'linux'
cpu_family = 'mips'
cpu = 'mipsel'
endian = 'little'

EOF
```

## ç¼–è¯‘

```shell
meson setup target -Db_lto=true -Dbuildtype=release --cross-file mips.ini -Dstrip=true
meson compile -C target --verbose
meson install -C target --destdir=./install

```
ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/47.html</guid><pubDate>Sun, 30 Mar 2025 11:30:29 +0000</pubDate></item><item><title>c++ basic</title><link>https://0x1042.github.io//post/46.html</link><description># æ„é€ å‡½æ•°

```c++
Object a; // é»˜è®¤æ„é€ å‡½æ•°
Object b = a; // æ‹·è´æ„é€ å‡½æ•°
Object c(b);// æ‹·è´æ„é€ å‡½æ•°
c = a; // èµ‹å€¼è¿ç®—ç¬¦
```

- **æ‹·è´æ„é€ å‡½æ•°ç”¨äºæ–°å¯¹è±¡çš„åˆå§‹åŒ–**
- **èµ‹å€¼è¿ç®—ç¬¦ç”¨äºå·²å­˜åœ¨å¯¹è±¡çš„èµ‹å€¼**
- **å‡½æ•°æŒ‰å€¼ä¼ å‚æˆ–è¿”å›å¯¹è±¡æ—¶ï¼Œä¹Ÿä¼šè§¦å‘æ‹·è´æ„é€ å‡½æ•°æˆ–è€…ç§»åŠ¨æ„é€ å‡½æ•°**

# lvalue/rvalue

```c++
int f(std::string &amp;str) { return 0; }
int f(const std::string &amp;str) { return 1; }
int f(std::string &amp;&amp;str) { return 2; }

f('Hello!') -&gt; 2
```

**é‡è½½è§£æä¼˜å…ˆçº§**

- å³å€¼å¼•ç”¨(**&amp;&amp;**): ä¼˜å…ˆåŒ¹é…å³å€¼
- å¸¸é‡å·¦å€¼å¼•ç”¨(**const &amp;**): å¯æ¥å—å³å€¼ï¼Œä½†æ˜¯ä¼˜å…ˆçº§ä½äºå³å€¼å¼•ç”¨
- éconstå·¦å€¼å¼•ç”¨(**&amp;**): æ— æ³•ç»‘å®šå³å€¼

&gt; `'Hello!` æ˜¯å­—ç¬¦ä¸²å­—é¢é‡ï¼Œå³å³å€¼ï¼Œä¼˜å…ˆåŒ¹é…å³å€¼å¼•ç”¨çš„å‡½æ•°

# ç±»å‹è½¬æ¢

```c++
struct B {
  int m_a;
};

struct A {
  int m_a;
};

A a{0};
B b = static_cast&lt;B&gt;(a); // å…è®¸ç¼–è¯‘é€šè¿‡
```

## ç”¨æˆ·è‡ªå®šä¹‰è½¬æ¢å‡½æ•°

&gt; https://zh.cppreference.com/w/cpp/language/cast_operator

```c++
struct A {
  int m_a;

// å…è®¸A é€šè¿‡static_castçš„æ–¹å¼è½¬æ¢ä¸ºB
  explicit operator B() const {
      return B{m_a};
  }
};
```

- è¯­æ³•
    - `operator è½¬æ¢ç±»å‹æ ‡è¯†`
    - `explicit operator è½¬æ¢ç±»å‹æ ‡è¯†`
    - `explicit ( è¡¨è¾¾å¼ ) operator è½¬æ¢ç±»å‹æ ‡è¯†`

## æ„é€ å‡½æ•°

```c++
struct A {
  int m_a;
};

struct B {
  int m_a;
  explicit B(const A &amp;aObj) : m_a(aObj.m_a) {}
};

B b = static_cast&lt;B&gt;(a);
```

- `static_cast` æ”¯æŒåŸºæœ¬ç±»å‹ä¹‹é—´çš„åˆæ³•è½¬æ¢
- `static_cast` éåŸºæœ¬ç±»å‹æ—¶ï¼Œå°è¯•å¯»æ‰¾æ˜¾ç¤ºæ„é€ å‡½æ•°å’Œç”¨æˆ·è‡ªå®šä¹‰æ„é€ å‡½æ•°ï¼Œä¸¤ç§ä¸èƒ½åŒæ—¶å­˜åœ¨

# `const`

- **const å°±è¿‘åŸåˆ™ï¼Œä¿®é¥°çš„æ˜¯constå·¦è¾¹çš„ä¸œè¥¿ï¼Œå¦‚æœå·¦è¾¹æ²¡æœ‰ï¼Œå°±ä¿®é¥°å³è¾¹çš„**
- **å·¦å®šå€¼ï¼Œå³å®šå‘: const åœ¨`*`å·¦è¾¹æ—¶ï¼ŒæŒ‡é’ˆæŒ‡å‘çš„å€¼ï¼ˆå†…å®¹ï¼‰ä¸å¯å˜ï¼Œåœ¨`*`å³è¾¹æ—¶ï¼ŒæŒ‡é’ˆçš„æŒ‡å‘ä¸å¯æ”¹å˜**

## å·¦å®šå€¼

```c++

struct Item {
  int id = 0;
  std::string name;
};

const Item *item_ptr = new Item(1, 'hello');
```

**const åœ¨`*`çš„å·¦è¾¹ï¼Œå³å€¼ä¸å¯å˜**

- ä¸å¯å˜éƒ¨åˆ†: *item_ptr

&gt; ç¼–è¯‘æŠ¥é”™ `error: read-only variable is not assignable`

```c++
(*item_ptr).id = 2;
(*item_ptr).name = 'world';
```
- å¯å˜éƒ¨åˆ†: item_ptr

&gt; ä¸‹é¢çš„ç¼–è¯‘æ­£å¸¸

```c++
Item item2(2, 'world');
item_ptr = &amp;item2;
```

## å³å®šå‘

```c++
Item *const item_ptr = new Item(3, 'hello');
```
- ä¸å¯å˜éƒ¨åˆ†: `Item *`ï¼Œä¹Ÿå°±æ˜¯ä¸èƒ½ä¿®æ”¹æŒ‡å‘

&gt; ä¸‹é¢çš„ç¼–è¯‘æŠ¥é”™ `error: cannot assign to variable 'item_ptr' with const-qualified type 'Item *const'`

```c++
Item item3(3, 'world');
item_ptr = &amp;item3; // ä¸èƒ½ä¿®æ”¹æŒ‡å‘
```

- å¯å˜éƒ¨åˆ†: `*item_ptr`

```c++
(*item_ptr).id = 4;
(*item_ptr).name = 'world2';

```


ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/46.html</guid><pubDate>Sat, 08 Mar 2025 10:08:51 +0000</pubDate></item><item><title>simd hello world</title><link>https://0x1042.github.io//post/44.html</link><description># SIMD Dot Product

## å®ç°

```cpp
#include &lt;immintrin.h&gt;
#include &lt;pmmintrin.h&gt;
#include &lt;x86intrin.h&gt;
#include &lt;xmmintrin.h&gt;

/**
 * @brief base ç‰ˆæœ¬
 *
 * @param a
 * @param b
 * @param dim
 * @return float
 */
float dot(const void *a, const void *b, size_t dim) {
  float sum = 0;
  for (unsigned i = 0; i &lt; dim; i++) {
    sum += ((float *)a)[i] * ((float *)b)[i];
  }
  return sum;
}

/**
 * @brief simd ç‰ˆæœ¬
 *
 * @param a
 * @param b
 * @param dim
 * @return float
 */
float dot_simd(const void *a, const void *b, size_t dim) {

  float *va = (float *)a;
  float *vb = (float *)b;

  size_t qty16 = dim / 16;

  const float *enda = va + 16 * qty16;

  // åˆå§‹åŒ–ä¸€ä¸ªé›¶å‘é‡ é•¿åº¦ä¸º8
  __m256 sum = _mm256_set1_ps(0);

  while (va &lt; enda) {
      // å°†vaçš„å‰8ä¸ªå…ƒç´ åŠ è½½åˆ°å‘é‡v1ä¸­
    __m256 v1 = _mm256_loadu_ps(va);
    va += 8;
    // å°†vbçš„å‰8ä¸ªå…ƒç´ åŠ è½½åˆ°å‘é‡v2ä¸­
    __m256 v2 = _mm256_loadu_ps(vb);
    vb += 8;

    // æ‰§è¡Œä¹˜æ³•å’ŒåŠ æ³•ï¼šsum += v1 * v2
    sum = _mm256_fmadd_ps(v1, v2, sum);

    // å°†vaçš„å‰8ä¸ªå…ƒç´ åŠ è½½åˆ°å‘é‡v1ä¸­
    v1 = _mm256_loadu_ps(va);
    va += 8;
    // å°†vbçš„å‰8ä¸ªå…ƒç´ åŠ è½½åˆ°å‘é‡v2ä¸­
    v2 = _mm256_loadu_ps(vb);
    vb += 8;

    // æ‰§è¡Œä¹˜æ³•å’ŒåŠ æ³•ï¼šsum += v1 * v2
    sum = _mm256_fmadd_ps(v1, v2, sum);
  }

    // ä»256ä½å‘é‡ä¸­æå–ä¸¤ä¸ª128ä½éƒ¨åˆ†
  __m128 low = _mm256_extractf128_ps(sum, 0);// ä½128ä½
  __m128 hight = _mm256_extractf128_ps(sum, 1); // é«˜128ä½


 // å°†ä¸¤ä¸ª128ä½å‘é‡ç›¸åŠ ï¼Œå¾—åˆ°ä¸€ä¸ªåŒ…å«4ä¸ªfloatçš„å‘é‡
  __m128 sum128 = _mm_add_ps(low, hight);

  // è¿™æ—¶sum128åŒ…å«4ä¸ªfloatå€¼ï¼š[a, b, c, d]

  // ç¬¬ä¸€æ¬¡haddï¼šå°†ç›¸é‚»å…ƒç´ ä¸¤ä¸¤ç›¸åŠ 
  // è¾“å…¥ï¼š[a, b, c, d]
  // è¾“å‡ºï¼š[a+b, c+d, a+b, c+d]
  sum128 = _mm_hadd_ps(sum128, sum128);

  // ç¬¬äºŒæ¬¡haddï¼šå†æ¬¡å°†ç›¸é‚»å…ƒç´ ä¸¤ä¸¤ç›¸åŠ 
  // è¾“å…¥ï¼š[a+b, c+d, a+b, c+d]
  // è¾“å‡ºï¼š[a+b+c+d, a+b+c+d, a+b+c+d, a+b+c+d]
  sum128 = _mm_hadd_ps(sum128, sum128);

  // å¤„ç†å‰©ä½™éƒ¨åˆ†
  float tail_sum = 0.0f;
  size_t remainder = dim % 16;
  for (size_t i = 0; i &lt; remainder; ++i) {
    tail_sum += va[i] * vb[i];
  }

 //_mm_cvtss_f32 å°†ç»“æœä»SIMDå¯„å­˜å™¨æå–åˆ°æ™®é€šæµ®ç‚¹æ•°
  return _mm_cvtss_f32(sum128) + tail_sum;
}

```

## ç¼–è¯‘

```meson
add_global_arguments('-march=native', language: 'cpp')
add_global_arguments('-mavx2', language: 'cpp')
add_global_arguments('-mpclmul', language: 'cpp')
add_global_arguments('-mbmi', language: 'cpp')

dot_inc = include_directories('.')

dot_src = files(
    'dot.cc',
)

dot = library(
    'dot',
    dot_src,
    dependencies: [
        random_dep,
    ],
    include_directories: dot_inc,
)

dot_dep = declare_dependency(
    include_directories: dot_inc,
    link_with: dot,
)
```

## unittest

### å®ç°

```c++
#include 'dot.h'
#include &lt;gtest/gtest.h&gt;

TEST(check, check1) {
  constexpr size_t dim = 128;

  const auto &amp;va = random(dim);
  const auto &amp;vb = random(dim);

  const auto &amp;base = dot(va.data(), vb.data(), dim);
  const auto &amp;simd = dot_simd(va.data(), vb.data(), dim);

  EXPECT_NE(base, 0);
  EXPECT_NE(simd, 0);
  EXPECT_FLOAT_EQ(base, simd);
}

TEST(check, check2) {
  constexpr size_t dim = 333;

  const auto &amp;va = random(dim);
  const auto &amp;vb = random(dim);

  const auto &amp;base = dot(va.data(), vb.data(), dim);
  const auto &amp;simd = dot_simd(va.data(), vb.data(), dim);

  EXPECT_NE(base, 0);
  EXPECT_NE(simd, 0);
  EXPECT_FLOAT_EQ(base, simd);
}

int main(int argc, char **argv) {
  testing::InitGoogleTest(&amp;argc, argv);
  return RUN_ALL_TESTS();
}

```

### ç¼–è¯‘

```meson
executable(
    'ut',
    'ut.cc',
    install: true,
    dependencies: [thread_dep, random_dep, gtest_dep, dot_dep],
)
```

## benchmark

### å®ç°
```c++
#include 'dot.h'
#include &lt;benchmark/benchmark.h&gt;

static void BM_dot(benchmark::State &amp;state) {
  constexpr size_t dim = 128;

  const auto &amp;va = random(dim);
  const auto &amp;vb = random(dim);

  for (auto _ : state) {
    const auto &amp;simd = dot_simd(va.data(), vb.data(), dim);
    benchmark::DoNotOptimize(simd);
  }
}

BENCHMARK(BM_dot);

int main(int argc, char **argv) {
  benchmark::Initialize(&amp;argc, argv);
  benchmark::RunSpecifiedBenchmarks();
  return 0;
}

```

### ç¼–è¯‘

```meson
executable(
    'bench',
    'bench.cc',
    install: true,
    dependencies: [thread_dep, random_dep, bench_dep, dot_dep],
)
```

``` text
./target/bench --benchmark_min_time=10s
2025-02-19T01:19:44+08:00
Running ./target/bench
Run on (16 X 2300 MHz CPU s)
CPU Caches:
  L1 Data 32 KiB
  L1 Instruction 32 KiB
  L2 Unified 256 KiB (x8)
  L3 Unified 16384 KiB
Load Average: 1.89, 2.17, 2.30
------------------------------------------------------
Benchmark            Time             CPU   Iterations
------------------------------------------------------
BM_dot            94.0 ns         94.0 ns    147363798
BM_dot_simd       10.3 ns         10.2 ns   1442614248
```
ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/44.html</guid><pubDate>Tue, 18 Feb 2025 17:42:07 +0000</pubDate></item><item><title>zig build misc</title><link>https://0x1042.github.io//post/43.html</link><description># è·¨å¹³å°ç¼–è¯‘

```zig

const targets: []const std.Target.Query = &amp;.{
    .{ .cpu_arch = .x86_64, .os_tag = .macos },
    .{ .cpu_arch = .x86_64, .os_tag = .linux, .abi = .gnu },
    .{ .cpu_arch = .x86_64, .os_tag = .linux, .abi = .musl },
    .{ .cpu_arch = .x86_64, .os_tag = .windows },
    .{ .cpu_arch = .aarch64, .os_tag = .macos },
    .{ .cpu_arch = .aarch64, .os_tag = .linux },
    .{ .cpu_arch = .aarch64, .os_tag = .windows },
    .{ .cpu_arch = .mips, .os_tag = .linux, .abi = .musl },
    .{ .cpu_arch = .mipsel, .os_tag = .linux, .abi = .musl },
    .{ .cpu_arch = .mips64, .os_tag = .linux, .abi = .musl },
    .{ .cpu_arch = .mips64el, .os_tag = .linux, .abi = .musl },
};

pub fn build(b: *std.Build) void {
    const optimize = b.standardOptimizeOption(.{});

    for (targets) |t| {
        var name: []u8 = undefined;
        const arch = if (t.cpu_arch) |arch| @tagName(arch) else 'native';
        const os = if (t.os_tag) |os| @tagName(os) else 'unknown';
        if (t.abi) |abi| {
            name = b.fmt('{s}-{s}-{s}', .{ os, arch, @tagName(abi) });
        } else {
            name = b.fmt('{s}-{s}', .{ os, arch });
        }

        const exe = b.addExecutable(.{
            .name = name,
            .root_source_file = b.path('src/main.zig'),
            .target = b.resolveTargetQuery(t),
            .optimize = optimize,
        });

        b.installArtifact(exe);
    }
}

```

# è‡ªå®šä¹‰ç¼–è¯‘é€‰é¡¹ 


```zig

fn addOption(b: *std.Build) *std.Build.Step.Options {
    const version = b.option([]const u8, 'version', 'build version') orelse 'dev';
    const date = b.option([]const u8, 'date', 'build date') orelse 'unknown';

    const options = b.addOptions();
    options.addOption([]const u8, 'version', version);
    options.addOption([]const u8, 'date', date);

    return options;
}

exe.root_module.addOptions('config', options);

```

ç¼–è¯‘æ—¶ï¼ŒæŒ‡å®šé€‰é¡¹

```shell
zig build -freference-trace --summary all --verbose -Dversion=22c0548 -Ddate=2025-01-18
```

`addOptions` ä¼šå°†é€‰é¡¹è½¬æ¢æˆzigä»£ç ï¼ŒåŒæ—¶å¯ä»¥åœ¨é¡¹ç›®ä¸­ç›´æ¥ä¾èµ–ï¼Œå¯ä»¥ä½¿ç”¨è¿™ä¸ªåŠŸèƒ½æ¥ç”Ÿæˆä¸`golang`ä¸­é€šè¿‡ `ldflags -X` ç¼–è¯‘æ—¶ç”Ÿæˆæ„å»ºæ—¥æœŸ/commitç­‰ä¸€æ ·çš„åŠŸèƒ½

```zig
// main.zig

const config = @import('config');

const version = config.date ++ ' ' ++ config.version;

```

# æ ¹æ®ç¼–è¯‘ç±»å‹æ§åˆ¶æ—¥å¿—çº§åˆ«

```zig
pub const level = switch (@import('builtin').mode) {
    .Debug =&gt; std.log.Level.debug,
    else =&gt; std.log.Level.info,
};

pub const std_options = .{
    .log_level = level,
    .logFn = logger.logfn,
};
```



ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/43.html</guid><pubDate>Sat, 18 Jan 2025 10:32:33 +0000</pubDate></item><item><title>zig cc ç¼–è¯‘cé¡¹ç›®</title><link>https://0x1042.github.io//post/42.html</link><description># zig cc ç¼–è¯‘cé¡¹ç›® &#13;
&#13;
## å•ä¸ªcæ–‡ä»¶&#13;
&#13;
```zig&#13;
    const flags = .{&#13;
        '-Wall',&#13;
        '-Wextra',&#13;
        '-Wpedantic',&#13;
        '-Werror=return-type',&#13;
        '-std=gnu23',&#13;
    };&#13;
&#13;
    exe.addCSourceFile(.{&#13;
        .file = std.Build.LazyPath{ .cwd_relative = 'http.c' },&#13;
        .flags = &amp;flags,&#13;
    });&#13;
&#13;
    exe.linkLibC();&#13;
```&#13;
&#13;
## å¤šä¸ªcæ–‡ä»¶&#13;
&#13;
```zig&#13;
    const cfiles = .{&#13;
        'http.c',&#13;
        'log.c',&#13;
        'server.c',&#13;
        'main.c',&#13;
        'relay.c',&#13;
        'socks.c',&#13;
    };&#13;
&#13;
    exe.addCSourceFiles(.{&#13;
        .files = &amp;cfiles,&#13;
        .flags = &amp;flags,&#13;
    });&#13;
```&#13;
&#13;
## è‡ªå®šä¹‰ç›®å½•å’Œåç¼€&#13;
&#13;
```zig&#13;
&#13;
    {&#13;
        var sources = std.ArrayList([]const u8).init(b.allocator);&#13;
        var dir = try std.fs.cwd().openDir('.', .{ .access_sub_paths = true });&#13;
        var walker = try dir.walk(b.allocator);&#13;
        defer walker.deinit();&#13;
&#13;
        const allowed_exts = [_][]const u8{ '.c', '.cpp', '.cxx', '.c++', '.cc' };&#13;
&#13;
        while (try walker.next()) |entry| {&#13;
            const ext = std.fs.path.extension(entry.basename);&#13;
            const include_file = for (allowed_exts) |e| {&#13;
                if (std.mem.eql(u8, ext, e))&#13;
                    break true;&#13;
            } else false;&#13;
            if (include_file) {&#13;
                // we have to clone the path as walker.next() or walker.deinit() will override/kill it&#13;
                try sources.append(b.dupe(entry.path));&#13;
            }&#13;
        }&#13;
    }&#13;
```&#13;
&#13;
## todo1 å¤–éƒ¨åº“ &#13;
&#13;
## todo2 c++&#13;
&#13;
&#13;
## ç¼–è¯‘ &#13;
&#13;
- native &#13;
&#13;
```zig &#13;
&#13;
VERBOSE := '--verbose --summary all'&#13;
zb_rel:&#13;
    zig build {{ VERBOSE }} --release=safe -Doptimize=ReleaseSafe --prefix {{ OUTPUT }}/rel&#13;
&#13;
```&#13;
- äº¤å‰&#13;
&#13;
```zig &#13;
zb_linux_rel:&#13;
    zig build {{ VERBOSE }} -Dtarget=x86_64-linux-gnu -Doptimize=ReleaseSafe --prefix {{ OUTPUT }}/linux/rel&#13;
```&#13;
&#13;
ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/42.html</guid><pubDate>Sat, 04 Jan 2025 18:49:48 +0000</pubDate></item><item><title>criterion å•å…ƒæµ‹è¯•ä½¿ç”¨</title><link>https://0x1042.github.io//post/41.html</link><description># æ·»åŠ ä¾èµ–&#13;
&#13;
```meson&#13;
// meson.build&#13;
&#13;
libcriterion = dependency(&#13;
    'criterion',&#13;
    method: 'pkg-config',&#13;
    required: true,&#13;
)&#13;
&#13;
lib_xmacro_sources = files(&#13;
    'xmacro.c',&#13;
    'xmacro.h',&#13;
)&#13;
&#13;
libxmacro = shared_library(&#13;
    'xmacro',&#13;
    lib_xmacro_sources,&#13;
    dependencies: [&#13;
        libcriterion,&#13;
    ],&#13;
)&#13;
&#13;
&#13;
samples = [&#13;
    'xmacro_test.c',&#13;
]&#13;
&#13;
foreach sample : samples&#13;
    e = executable(&#13;
        sample + '.bin',&#13;
        sample,&#13;
        dependencies: [libcriterion],&#13;
        link_with: [libxmacro],&#13;
    )&#13;
    test('sample / ' + sample, e)&#13;
endforeach&#13;
&#13;
```&#13;
&#13;
&#13;
# ä½¿ç”¨ &#13;
&#13;
```c&#13;
#include 'xmacro.h'&#13;
#include &lt;criterion/criterion.h&gt;&#13;
#include &lt;criterion/logging.h&gt;&#13;
#include &lt;criterion/options.h&gt;&#13;
#include &lt;string.h&gt;&#13;
&#13;
Test(http_mhd, to_str) {&#13;
&#13;
  {&#13;
    const char *tmp = mhd_to_str(HTTP_GET);&#13;
    cr_log_info('HTTP_GET %s ', tmp);&#13;
    cr_assert(tmp, 'GET');&#13;
  }&#13;
&#13;
  {&#13;
    const char *tmp = mhd_to_str(HTTP_CONNECT);&#13;
    cr_log_info('HTTP_CONNECT %s ', tmp);&#13;
    cr_assert(tmp, 'CONNECT');&#13;
  }&#13;
}&#13;
&#13;
Test(http_mhd, from_str) {&#13;
  {&#13;
    http_method_t tmp = str_to_mhd('GET');&#13;
    cr_log_info('GET %d ', tmp);&#13;
    cr_assert_eq(tmp, HTTP_GET);&#13;
  }&#13;
  {&#13;
    http_method_t tmp = str_to_mhd('Post');&#13;
    cr_log_info('Post %d ', tmp);&#13;
    cr_assert_eq(tmp, HTTP_POST);&#13;
  }&#13;
  {&#13;
    http_method_t tmp = str_to_mhd('TRACE');&#13;
    cr_log_info('TRACE %d ', tmp);&#13;
    cr_assert_eq(tmp, HTTP_TRACE);&#13;
  }&#13;
}&#13;
&#13;
```&#13;
&#13;
# ç¼–è¯‘&#13;
&#13;
```&#13;
build_asan:&#13;
  meson setup buildDir -Db_sanitize=address -Db_lundef=false&#13;
  meson compile -C buildDir&#13;
  ln -sf buildDir/compile_commands.json .&#13;
&#13;
run_test:&#13;
    ./buildDir/xmacro_test.c.bin --verbos --full-stats&#13;
```&#13;
ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/41.html</guid><pubDate>Sat, 04 Jan 2025 17:32:54 +0000</pubDate></item><item><title>x macro</title><link>https://0x1042.github.io//post/40.html</link><description># x å®&#13;
&#13;
&gt; å®ç°æšä¸¾ä¸sträº’ç›¸è½¬æ¢çš„æ—¶å€™ï¼Œæœåˆ°çš„ä¸€ä¸ªç”¨æ³•ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/40.html</guid><pubDate>Sat, 04 Jan 2025 17:27:58 +0000</pubDate></item><item><title>c++ misc</title><link>https://0x1042.github.io//post/39.html</link><description># å…ƒå‡½æ•° &#13;
&#13;
- è¾“å…¥: é€šè¿‡æ¨¡æ¿å‚æ•° &#13;
- è¾“å‡º: é€šå¸¸é€šè¿‡ç±»å‹åˆ«å(using/typedef)æˆ–é™æ€æˆå‘˜æ¥æä¾› &#13;
- è®¡ç®—è¿‡ç¨‹: ç¼–è¯‘æœŸ&#13;
&#13;
```c++&#13;
template &lt;typename T&gt; // è¾“å…¥ &#13;
struct is_pointer {&#13;
    static constexpr bool value = false; // è¾“å‡º&#13;
};&#13;
&#13;
template &lt;typename T&gt;&#13;
struct is_pointer&lt;T *&gt; {&#13;
    static constexpr bool value = true;&#13;
};&#13;
&#13;
static_assert(is_pointer&lt;int *&gt;::value); // è®¡ç®—è¿‡ç¨‹&#13;
static_assert(!is_pointer&lt;int&gt;::value);&#13;
```&#13;
&#13;
# æ¨¡æ¿å‚æ•° &#13;
&#13;
- ç±»å‹å‚æ•°&#13;
&#13;
```c++&#13;
template &lt;typename T&gt;&#13;
struct Container {&#13;
    T val;&#13;
};&#13;
```&#13;
&#13;
- éç±»å‹å‚æ•°&#13;
&#13;
&gt; å¿…é¡»æ˜¯ ç¼–è¯‘æœŸå¸¸é‡&#13;
&#13;
```c++&#13;
template &lt;int size&gt;&#13;
struct Array {&#13;
    std::array&lt;int, size&gt; data;&#13;
};&#13;
```&#13;
&#13;
- æ¨¡æ¿å‚æ•° &#13;
```c++&#13;
template &lt;template &lt;typename&gt; class Container&gt;&#13;
class Wrapper {&#13;
    Container&lt;int&gt; data; // ä½¿ç”¨ä¼ å…¥çš„æ¨¡æ¿&#13;
public:&#13;
    void add(int value) { data.push_back(value); }&#13;
};&#13;
```&#13;
&#13;
&#13;
# `restrict` å…³é”®å­—&#13;
&#13;
## ä½œç”¨&#13;
&#13;
&gt; ç¨‹åºå‘˜å‘ç¼–è¯‘å™¨ä¿è¯ï¼Œåœ¨æŒ‡é’ˆçš„æ•´ä¸ªç”Ÿå‘½å‘¨æœŸå†…ï¼Œåªæœ‰è¿™ä¸ªæŒ‡é’ˆèƒ½ç”¨æ¥è®¿é—®å®ƒæŒ‡å‘çš„å¯¹è±¡ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/39.html</guid><pubDate>Sun, 22 Dec 2024 10:06:11 +0000</pubDate></item><item><title>strict weak order</title><link>https://0x1042.github.io//post/38.html</link><description># èƒŒæ™¯&#13;
&#13;
&gt; ä¸Šçº¿äº†ä¸šåŠ¡é€»è¾‘ä»£ç ï¼Œå‘ç°æœ‰`coredump`, ä»å †æ ˆçœ‹ï¼Œæ˜¯å‡ºç°äº†è¶Šç•Œã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/38.html</guid><pubDate>Mon, 02 Dec 2024 16:25:56 +0000</pubDate></item><item><title>macos cmake ä¾èµ– omp</title><link>https://0x1042.github.io//post/37.html</link><description>&#13;
# é…ç½®&#13;
&#13;
```cmake&#13;
set(CMAKE_CXX_FLAGS '${CMAKE_CXX_FLAGS} -stdlib=libc++')&#13;
link_directories(/usr/local/opt/llvm/lib/c++)&#13;
&#13;
find_package(OpenMP COMPONENTS CXX)&#13;
target_link_libraries(&#13;
  ${PROJECT_NAME}&#13;
  PUBLIC OpenMP::OpenMP_CXX&#13;
  PUBLIC c++abi&#13;
  PUBLIC c++&#13;
)&#13;
```&#13;
&#13;
# ä½¿ç”¨&#13;
&#13;
```c++&#13;
auto batch_get2(const std::vector&lt;std::string&gt; &amp; urls, std::vector&lt;std::string&gt; &amp; resps) -&gt; int {&#13;
    std::chrono::high_resolution_clock::time_point start = std::chrono::high_resolution_clock::now();&#13;
    resps.resize(urls.size());&#13;
&#13;
#pragma omp parallel for schedule(dynamic, 1)&#13;
    for (int i = 0; i &lt; urls.size(); i++) {&#13;
        get(urls[i], resps[i]);&#13;
    }&#13;
    std::chrono::high_resolution_clock::time_point finish = std::chrono::high_resolution_clock::now();&#13;
&#13;
    spdlog::info('omp cost {}', std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(finish - start).count());&#13;
&#13;
    return 0;&#13;
}&#13;
```&#13;
ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/37.html</guid><pubDate>Thu, 07 Nov 2024 17:19:02 +0000</pubDate></item><item><title>protobuf ListValue ä½¿ç”¨</title><link>https://0x1042.github.io//post/36.html</link><description># èƒŒæ™¯&#13;
&#13;
&gt; è€ƒè™‘è¿™ä¸ª`json` å¦‚ä½•å®šä¹‰å¯¹åº”çš„`protobuf` ç»“æ„ï¼Ÿ&#13;
&#13;
```json&#13;
{&#13;
    'show_list': {&#13;
        'hello1': [&#13;
            'world1',&#13;
            'world1'&#13;
        ],&#13;
        'hello2': [&#13;
            'world2',&#13;
            'world2'&#13;
        ]&#13;
    }&#13;
}&#13;
```&#13;
&#13;
**`protobuf` ä¸­æ— æ³•ç›´æ¥å£°æ˜`map&lt;key,repeated values&gt;` å¯¹åº”çš„ç»“æ„ï¼Œéœ€è¦å€ŸåŠ©`ListValue`**&#13;
&#13;
# å®šä¹‰&#13;
&#13;
```protobuf&#13;
syntax = 'proto3';&#13;
&#13;
package demo;&#13;
option go_package = './demos';&#13;
&#13;
import 'google/protobuf/struct.proto';&#13;
&#13;
message UaInfo {&#13;
  map&lt;string, google.protobuf.ListValue&gt; show_list = 1;&#13;
}&#13;
&#13;
```&#13;
&#13;
# cpp &#13;
&#13;
&gt; ç”Ÿæˆ `protoc --proto_path=proto --cpp_out=pbgen proto/*.proto`&#13;
&#13;
- ååºåˆ—åŒ–&#13;
&#13;
```cpp&#13;
TEST(pb, valus) {&#13;
    const std::string json = R'({'show_list':{'hello1':['world1','world1'],'hello2':['world2','world2']}})';&#13;
&#13;
    google::protobuf::json::ParseOptions opt;&#13;
    opt.ignore_unknown_fields = true;&#13;
    opt.case_insensitive_enum_parsing = true;&#13;
    demo::UaInfo info;&#13;
&#13;
    const auto &amp; status = google::protobuf::json::JsonStringToMessage(json, &amp;info, opt);&#13;
&#13;
    std::clog &lt;&lt; 'status ' &lt;&lt; status &lt;&lt; '\n';&#13;
&#13;
    std::clog &lt;&lt; info.DebugString() &lt;&lt; '\n';&#13;
&#13;
    std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt; db;&#13;
&#13;
    for (const auto &amp; inner : info.show_list()) {&#13;
        for (const auto &amp; list : inner.second.values()) {&#13;
            db[inner.first].push_back(list.string_value());&#13;
        }&#13;
    }&#13;
&#13;
    // è¾“å‡º {'hello1': ['world1', 'world1'], 'hello2': ['world2', 'world2']}&#13;
    std::clog &lt;&lt; fmt::to_string(db) &lt;&lt; '\n';&#13;
}&#13;
```&#13;
&#13;
- ç”Ÿæˆ&#13;
&#13;
```cpp&#13;
TEST(pb, valus2) {&#13;
    google::protobuf::json::PrintOptions opt;&#13;
    opt.add_whitespace = true;&#13;
    demo::UaInfo info;&#13;
    auto * map = info.mutable_show_list();&#13;
&#13;
    {&#13;
        google::protobuf::ListValue list_value;&#13;
        list_value.add_values()-&gt;set_string_value('orld1010');&#13;
        list_value.add_values()-&gt;set_string_value('orld1020');&#13;
        (*map)['hello101'] = std::move(list_value);&#13;
    }&#13;
&#13;
    {&#13;
        google::protobuf::ListValue list_value;&#13;
        list_value.add_values()-&gt;set_string_value('orld2010');&#13;
        list_value.add_values()-&gt;set_string_value('orld2020');&#13;
        (*map)['hello202'] = std::move(list_value);&#13;
    }&#13;
&#13;
    std::clog &lt;&lt; info.DebugString() &lt;&lt; '\n';&#13;
&#13;
    std::string message;&#13;
&#13;
    const auto &amp; status = google::protobuf::json::MessageToJsonString(info, &amp;message, opt);&#13;
&#13;
    std::clog &lt;&lt; 'status ' &lt;&lt; status &lt;&lt; '\n';&#13;
&#13;
    std::clog &lt;&lt; 'message ' &lt;&lt; message &lt;&lt; '\n';&#13;
}&#13;
```&#13;
&#13;
# go&#13;
&#13;
&gt; ç”Ÿæˆ `protoc --proto_path=. --go_out=. --go_opt=paths=source_relative *.proto`&#13;
&#13;
- ååºåˆ—åŒ–&#13;
&#13;
```go&#13;
func Test_test(t *testing.T) {&#13;
	str := '{\'show_list\':{\'hello1\':[\'world1\',\'world1\'],\'hello2\':[\'world2\',\'world2\']}}'&#13;
	uainfo := new(UaInfo)&#13;
&#13;
	if err := json.Unmarshal([]byte(str), uainfo); err != nil {&#13;
		log.Fatal(err)&#13;
	}&#13;
&#13;
	log.Printf('%+v', uainfo)&#13;
&#13;
	bs, err := json.Marshal(uainfo)&#13;
&#13;
	if err != nil {&#13;
		panic(err)&#13;
	}&#13;
	log.Printf('\n%s', bs)&#13;
}&#13;
&#13;
```&#13;
&#13;
- ç”Ÿæˆ&#13;
&#13;
```go&#13;
func Test_test2(t *testing.T) {&#13;
	uainfo := new(UaInfo)&#13;
	uainfo.ShowList = make(map[string]*structpb.ListValue)&#13;
	l1, _ := structpb.NewList([]any{'world101', 'world102'})&#13;
	uainfo.ShowList['hello1'] = l1&#13;
&#13;
	l2, _ := structpb.NewList([]any{'world202', 'world201'})&#13;
	uainfo.ShowList['hello2'] = l2&#13;
&#13;
	bs, err := json.Marshal(uainfo)&#13;
&#13;
	if err != nil {&#13;
		panic(err)&#13;
	}&#13;
	log.Printf('uainfo\n%s', bs)&#13;
}&#13;
```&#13;
ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/36.html</guid><pubDate>Fri, 11 Oct 2024 15:29:37 +0000</pubDate></item><item><title>misc error</title><link>https://0x1042.github.io//post/35.html</link><description># vscode 

## terminal æ‰“å¼€æŠ¥é”™ 

```
SecCodeCheckValidity: Error Domain=NSOSStatusErrorDomain Code=-67062 '(null)' (-67062)
```

## ä¿®å¤ 

```
xattr -cr  /Applications/Visual\ Studio\ Code.app
sudo codesign --force --deep --sign - /Applications/Visual\ Studio\ Code.app
``` 

# apt 

## install warning

```
Key is stored in legacy trusted.gpg keyring (/etc/apt/trusted.gpg), see the DEPRECATION section in apt-key(8) for details.
```

## ä¿®å¤

[askubuntu.com](https://askubuntu.com/questions/1398344/apt-key-deprecation-warning-when-updating-system-key-is-stored-in-legacy-trust)

```
cd /etc/apt
sudo cp trusted.gpg trusted.gpg.d
```ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/35.html</guid><pubDate>Sun, 22 Sep 2024 07:23:14 +0000</pubDate></item><item><title>ml æ‰«ç›²å››</title><link>https://0x1042.github.io//post/34.html</link><description># origin post&#13;
&#13;
&gt; https://x.com/konradgajdus/status/1837196363735482396&#13;
&#13;
- [origin post](#origin-post)&#13;
- [process data](#process-data)&#13;
  - [è¯»å–images](#è¯»å–images)&#13;
  - [è¯»å–labels](#è¯»å–labels)&#13;
- [å®šä¹‰ç½‘ç»œ](#å®šä¹‰ç½‘ç»œ)&#13;
  - [ç»“æ„](#ç»“æ„)&#13;
  - [åˆå§‹åŒ–](#åˆå§‹åŒ–)&#13;
- [å‰å‘ä¼ æ’­](#å‰å‘ä¼ æ’­)&#13;
- [åå‘ä¼ æ’­](#åå‘ä¼ æ’­)&#13;
- [è®­ç»ƒ](#è®­ç»ƒ)&#13;
  - [å•ä¸ªinstanceå•æ¬¡è¿­ä»£](#å•ä¸ªinstanceå•æ¬¡è¿­ä»£)&#13;
  - [batchè®­ç»ƒ](#batchè®­ç»ƒ)&#13;
- [é¢„æµ‹](#é¢„æµ‹)&#13;
- [éªŒè¯](#éªŒè¯)&#13;
&#13;
# process data&#13;
&#13;
&gt; æ•°æ®ä¸‹è½½åœ°å€ https://yann.lecun.com/exdb/mnist/&#13;
&#13;
| æ–‡ä»¶                    | è¯´æ˜       |&#13;
| ----------------------- | ---------- |&#13;
| `train-images-idx3-ubyte` | è®­ç»ƒé›†å›¾ç‰‡ |&#13;
| `train-labels-idx1-ubyte` | è®­ç»ƒé›†æ ‡ç­¾ |&#13;
| `t10k-images-idx3-ubyte`  | æµ‹è¯•é›†å›¾ç‰‡ |&#13;
| `t10k-labels-idx1-ubyte`  | æµ‹è¯•é›†æ ‡ç­¾ |&#13;
&#13;
&#13;
## è¯»å–images&#13;
&#13;
&gt; æ•°æ®æ ¼å¼ &#13;
&#13;
```&#13;
[offset] [type]          [value]          [description]&#13;
0000     32 bit integer  0x00000803(2051) magic number&#13;
0004     32 bit integer  60000            number of images&#13;
0008     32 bit integer  28               number of rows&#13;
0012     32 bit integer  28               number of columns&#13;
0016     unsigned byte   ??               pixel&#13;
0017     unsigned byte   ??               pixel&#13;
........&#13;
xxxx     unsigned byte   ??               pixel&#13;
Pixels are organized row-wise. Pixel values are 0 to 255. 0 means background (white), 255 means foreground (black).&#13;
```&#13;
&#13;
```c&#13;
void read_images(const char *fname, unsigned char **images, int *count) {&#13;
	FILE *file = fopen(fname, 'rb');&#13;
	if (file == NULL) {&#13;
		printf('%s open %s failed.', __FUNCTION__, fname);&#13;
		exit(1);&#13;
	}&#13;
&#13;
	int magic = 0;&#13;
	int rows, cols;&#13;
	// magic numx&#13;
	fread(&amp;magic, sizeof(int), 1, file);&#13;
	// number of images&#13;
	fread(count, sizeof(int), 1, file);&#13;
	// è½¬æˆå¤§ç«¯&#13;
	*count = __builtin_bswap32(*count);&#13;
&#13;
	// number of rows&#13;
	fread(&amp;rows, sizeof(int), 1, file);&#13;
	//	number of columns&#13;
	fread(&amp;cols, sizeof(int), 1, file);&#13;
&#13;
	rows = __builtin_bswap32(rows);&#13;
	cols = __builtin_bswap32(cols);&#13;
&#13;
	printf('%s: %d/%d/%d\n', __FUNCTION__, *count, rows, cols);&#13;
&#13;
	*images = malloc((*count) * IMAGE_SIZE * IMAGE_SIZE);&#13;
	fread(*images, sizeof(unsigned char), (*count) * IMAGE_SIZE * IMAGE_SIZE, file);&#13;
	fclose(file);&#13;
}&#13;
```&#13;
&#13;
## è¯»å–labels&#13;
&#13;
&gt; æ•°æ®æ ¼å¼&#13;
&#13;
```&#13;
[offset] [type]          [value]          [description]&#13;
0000     32 bit integer  0x00000801(2049) magic number (MSB first)&#13;
0004     32 bit integer  60000            number of items&#13;
0008     unsigned byte   ??               label&#13;
0009     unsigned byte   ??               label&#13;
........&#13;
xxxx     unsigned byte   ??               label&#13;
The labels values are 0 to 9.&#13;
```&#13;
&#13;
```c&#13;
void read_labels(const char *fname, unsigned char **labels, int *count) {&#13;
	FILE *file = fopen(fname, 'rb');&#13;
	if (file == NULL) {&#13;
		exit(1);&#13;
	}&#13;
	printf('open file [%s] success.\n', fname);&#13;
&#13;
	int magic = 0;&#13;
	fread(&amp;magic, sizeof(int), 1, file);&#13;
	fread(count, sizeof(int), 1, file);&#13;
	*count = __builtin_bswap32(*count);&#13;
&#13;
	printf('labels count. %d.\n', *count);&#13;
&#13;
	*labels = malloc(*count);&#13;
&#13;
	fread(*labels, sizeof(unsigned char), *count, file);&#13;
	fclose(file);&#13;
}&#13;
```&#13;
&#13;
# å®šä¹‰ç½‘ç»œ &#13;
&#13;
## ç»“æ„ &#13;
&#13;
```c&#13;
typedef struct {&#13;
	float *weights; // æƒé‡ &#13;
	float *biases;  // åå·®&#13;
	int input_size;&#13;
	int output_size;&#13;
} Layer;&#13;
&#13;
typedef struct {&#13;
	Layer hidden;&#13;
	Layer output;&#13;
} Network;&#13;
```&#13;
&#13;
## åˆå§‹åŒ– &#13;
&#13;
&gt; ç¥ç»ç½‘ç»œçš„è®­ç»ƒè¿‡ç¨‹æœ¬è´¨æ˜¯å¯¹æƒé‡å‚æ•°çš„æ›´æ–°ï¼Œé‚£ä¹ˆè¿™ä¸ªæƒé‡çš„åˆå§‹å€¼æ˜¯ä»€ä¹ˆ?&#13;
&gt; é¦–å…ˆä¸èƒ½æ˜¯0ï¼Œå› ä¸º $y = wx +b $ ä¸­ï¼Œå¦‚æœw = 0ï¼Œé‚£ä¹ˆæ‰€æœ‰ç¥ç»å…ƒçš„è¾“å‡ºæ˜¯ç›¸åŒçš„ åå‘ä¼ æ’­è¿‡ç¨‹çš„æ¢¯åº¦ä¹Ÿæ˜¯ç›¸åŒçš„ &#13;
&#13;
**He initialization**&#13;
&#13;
&gt; æ€æƒ³æ˜¯å°†æƒé‡åˆå§‹åŒ–ä¸ºæ»¡è¶³ä¸€ä¸ªæ ‡å‡†æ­£æ€åˆ†å¸ƒ&#13;
&#13;
```c&#13;
void init_layer(Layer *layer, int in_size, int out_size) {&#13;
	int n = in_size * out_size;&#13;
	float scale = sqrtf(2.0f / in_size);&#13;
&#13;
	layer-&gt;input_size = in_size;&#13;
	layer-&gt;output_size = out_size;&#13;
	layer-&gt;weights = malloc(n * sizeof(float));&#13;
	layer-&gt;biases = calloc(out_size, sizeof(float));&#13;
&#13;
	for (int i = 0; i &lt; n; i++)&#13;
		layer-&gt;weights[i] = ((float)rand() / RAND_MAX - 0.5f) * 2 * scale;&#13;
}&#13;
```&#13;
&#13;
# å‰å‘ä¼ æ’­&#13;
&#13;
&gt; å³ç»™å®šè¾“å…¥ è®¡ç®—ç¥ç»ç½‘ç»œè¾“å‡ºçš„è¿‡ç¨‹ &#13;
&gt; æ­¥éª¤: å°†è¾“å…¥æ•°æ®ç§»åŠ¨åˆ°ç½‘ç»œçš„æ¯ä¸€å±‚ï¼Œåº”ç”¨çº¿å½¢å˜æ¢å’Œæ¿€æ´»å‡½æ•°ï¼Œäº§ç”Ÿè¾“å‡º&#13;
&#13;
```c&#13;
void forward(Layer *layer, float *input, float *output) {&#13;
	for (int i = 0; i &lt; layer-&gt;output_size; i++) {&#13;
		output[i] = layer-&gt;biases[i];&#13;
		for (int j = 0; j &lt; layer-&gt;input_size; j++)&#13;
			output[i] += input[j] * layer-&gt;weights[j * layer-&gt;output_size + i];&#13;
	}&#13;
}&#13;
&#13;
void relu(float *hidden, int size) {&#13;
	for (int i = 0; i &lt; size; i++) {&#13;
		hidden[i] = hidden[i] &gt; 0 ? hidden[i] : 0;&#13;
	}&#13;
}&#13;
&#13;
void softmax(float *input, int size) {&#13;
	float max = input[0], sum = 0;&#13;
	for (int i = 1; i &lt; size; i++) {&#13;
		if (input[i] &gt; max) max = input[i];&#13;
	}&#13;
	for (int i = 0; i &lt; size; i++) {&#13;
		input[i] = expf(input[i] - max);&#13;
		sum += input[i];&#13;
	}&#13;
	for (int i = 0; i &lt; size; i++) {&#13;
		input[i] /= sum;&#13;
	}&#13;
}&#13;
```&#13;
&#13;
# åå‘ä¼ æ’­ &#13;
&#13;
&gt; æ ¹æ®æ¢¯åº¦æ›´æ–°æƒé‡å’Œåå·®&#13;
&gt; æ­¥éª¤:&#13;
&#13;
```c&#13;
void backward(Layer *layer, float *input, float *output_grad, float *input_grad, float lr) {&#13;
	for (int i = 0; i &lt; layer-&gt;output_size; i++) {&#13;
		for (int j = 0; j &lt; layer-&gt;input_size; j++) {&#13;
			int idx = j * layer-&gt;output_size + i;&#13;
			// ç›¸å¯¹äºæƒé‡çš„æŸå¤±æ¢¯åº¦ç­‰äºç›¸å¯¹äºè¾“å‡ºçš„æŸå¤±æ¢¯åº¦ä¹˜ä»¥è¾“å…¥å€¼&#13;
			float grad = output_grad[i] * input[j];&#13;
			// æ–°çš„æƒé‡ = æ—§çš„æƒé‡ å‡å» å­¦ä¹ ç‡ä¹˜ä»¥ç›¸å¯¹äºæƒé‡çš„æŸå¤±æ¢¯åº¦&#13;
			layer-&gt;weights[idx] -= lr * grad;&#13;
			//	ç›¸å¯¹äºè¾“å…¥ j çš„æŸå¤±æ¢¯åº¦æ˜¯æ‰€æœ‰è¾“å‡ºçš„ï¼ˆå…³äºæ¯ä¸ªè¾“å‡º i çš„æŸå¤±æ¢¯åº¦ä¹˜ä»¥å°†è¾“å…¥ j è¿æ¥åˆ°è¾“å‡º i çš„æƒé‡ï¼‰çš„æ€»å’Œ&#13;
			if (input_grad) {&#13;
				input_grad[j] += output_grad[i] * layer-&gt;weights[idx];&#13;
			}&#13;
		}&#13;
&#13;
		// æ–°åå·®ç­‰äºæ—§åå·®å‡å»å­¦ä¹ ç‡ä¹˜ä»¥ç›¸å¯¹äºåå·®çš„æŸå¤±æ¢¯åº¦ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/34.html</guid><pubDate>Sat, 21 Sep 2024 17:00:28 +0000</pubDate></item><item><title>ml æ‰«ç›²ä¸‰</title><link>https://0x1042.github.io//post/33.html</link><description># ç¥ç»ç½‘ç»œæ­å»ºæ­¥éª¤ &#13;
&#13;
- [ç¥ç»ç½‘ç»œæ­å»ºæ­¥éª¤](#ç¥ç»ç½‘ç»œæ­å»ºæ­¥éª¤)&#13;
  - [åŠ è½½æ•°æ®](#åŠ è½½æ•°æ®)&#13;
  - [å®šä¹‰ç½‘ç»œæ¨¡å‹](#å®šä¹‰ç½‘ç»œæ¨¡å‹)&#13;
  - [å®šä¹‰æŸå¤±å‡½æ•°](#å®šä¹‰æŸå¤±å‡½æ•°)&#13;
  - [å®šä¹‰ä¼˜åŒ–å™¨](#å®šä¹‰ä¼˜åŒ–å™¨)&#13;
  - [è®­ç»ƒ](#è®­ç»ƒ)&#13;
  - [æµ‹è¯•](#æµ‹è¯•)&#13;
  - [ä¿å­˜æ¨¡å‹](#ä¿å­˜æ¨¡å‹)&#13;
&#13;
&#13;
```mermaid&#13;
flowchart LR&#13;
&#13;
æ•°æ®--&gt;ç½‘ç»œç»“æ„&#13;
ç½‘ç»œç»“æ„--&gt;æŸå¤±å‡½æ•°&#13;
æŸå¤±å‡½æ•°--&gt;ä¼˜åŒ–å™¨&#13;
ä¼˜åŒ–å™¨--&gt;è®­ç»ƒ&#13;
è®­ç»ƒ--&gt;æµ‹è¯•&#13;
æµ‹è¯•--&gt;å¯¼å‡ºæ¨¡å‹&#13;
```&#13;
&#13;
## åŠ è½½æ•°æ®&#13;
&#13;
```python&#13;
import torch&#13;
from torchvision import datasets, transforms&#13;
import torch.optim as optim &#13;
import torch.nn as nn&#13;
import torch.utils.data as data&#13;
&#13;
train_data = datasets.MNIST(root='data/mnist', train=True, transform=transforms.ToTensor(), download=True)&#13;
test_data = datasets.MNIST(root='data/mnist', train=False, transform=transforms.ToTensor(), download=True)&#13;
```&#13;
&#13;
&gt; ç”±äºæ•°æ®è§„æ¨¡ï¼Œä¸å¯èƒ½å°†æ‰€æœ‰çš„æ•°æ®åŠ è½½ä¸€æ¬¡è®­ç»ƒã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/33.html</guid><pubDate>Tue, 17 Sep 2024 06:21:07 +0000</pubDate></item><item><title>æ±‡ç¼–(1)</title><link>https://0x1042.github.io//post/32.html</link><description>&#13;
- [åŸºæœ¬ç‰¹å¾](#åŸºæœ¬ç‰¹å¾)&#13;
- [`hello world`](#hello-world)&#13;
- [å¯»å€](#å¯»å€)&#13;
  - [å¯„å­˜å™¨å¯»å€](#å¯„å­˜å™¨å¯»å€)&#13;
  - [ç«‹å³å¯»å€](#ç«‹å³å¯»å€)&#13;
  - [é—´æ¥(å†…å­˜)å¯»å€](#é—´æ¥å†…å­˜å¯»å€)&#13;
  - [ç´¢å¼•å¯»å€](#ç´¢å¼•å¯»å€)&#13;
  - [åŸºå€å¯»å€](#åŸºå€å¯»å€)&#13;
- [op](#op)&#13;
&#13;
&gt; `gdb` é»˜è®¤çš„æ±‡ç¼–é£æ ¼æ˜¯`AT&amp;T` &#13;
&#13;
# åŸºæœ¬ç‰¹å¾ &#13;
&#13;
- æºæ“ä½œæ•°åœ¨å‰ï¼Œç›®çš„æ“ä½œæ•°åœ¨å &#13;
- å¯„å­˜å™¨ä»¥`%`å¼€å¤´  &#13;
- ç«‹å³æ•°ä»¥ `$`å¼€å¤´ï¼Œå³å¸¸é‡æ•°&#13;
&#13;
&#13;
# `hello world`&#13;
&#13;
```asm&#13;
movl %eax,%ebx ; æŠŠå¯„å­˜å™¨eaxçš„å€¼ç§»åŠ¨åˆ°ebxå¯„å­˜å™¨&#13;
```&#13;
&#13;
```asm&#13;
movl $5, %eax    ; æŠŠç«‹å³æ•° 5 ç§»åŠ¨åˆ° EAX&#13;
```&#13;
&#13;
# å¯»å€&#13;
&#13;
```asm &#13;
&#13;
; åœ°å€æˆ–åç§»(%åŸºå€æˆ–åç§»é‡å¯„å­˜å™¨,%ç´¢å¼•å¯„å­˜å™¨,æ¯”ä¾‹å› å­)&#13;
&#13;
; dst = åœ°å€æˆ–åç§» + %ç´¢å¼•å¯„å­˜å™¨ * æ¯”ä¾‹å› å­&#13;
&#13;
```&#13;
&#13;
## å¯„å­˜å™¨å¯»å€&#13;
&#13;
```asm&#13;
mov    %rax,%rdi ;æŠŠå¯„å­˜å™¨raxçš„å€¼ç§»åŠ¨åˆ°rdiå¯„å­˜å™¨&#13;
&#13;
; ä¸å†…å­˜æ— å…³&#13;
; å¦‚æœrax = 0x12345678&#13;
; é‚£ä¹ˆè¿™æ¡æŒ‡ä»¤æ‰§è¡Œç»“æŸåï¼Œrdiçš„å€¼ä¹Ÿæ˜¯ 0x12345678&#13;
```&#13;
&#13;
## ç«‹å³å¯»å€&#13;
&#13;
```asm&#13;
mov    $0xa,%esi&#13;
; $ è¡¨ç¤ºç«‹å³æ•° ï¼Œ0xa å³åè¿›åˆ¶çš„10&#13;
; æ‰§è¡Œç»“æŸåï¼Œå¯„å­˜å™¨esiçš„å€¼å°±æ˜¯10&#13;
```&#13;
&#13;
## é—´æ¥(å†…å­˜)å¯»å€ &#13;
&#13;
```asm&#13;
mov     (%rip),%rdi&#13;
; ripå¯„å­˜å™¨å­˜æ”¾çš„æ˜¯ä¸€ä¸ªå†…å­˜åœ°å€&#13;
; (%rip) è¡¨ç¤ºè¯¥å†…å­˜åœ°å€æŒ‡å‘çš„æ•°æ®&#13;
; ä¸Šè¿°æŒ‡ä»¤çš„æ˜¯æ„æ€æ˜¯ å°† ripå¯„å­˜å™¨æ‰€æŒ‡å‘çš„å†…å­˜ä¸­çš„å€¼åŠ è½½åˆ°rdiå¯„å­˜å™¨ä¸­ &#13;
```&#13;
&#13;
## ç´¢å¼•å¯»å€&#13;
&#13;
```asm&#13;
subl -0x20(%ebx, %ecx, 0x4), %eax&#13;
&#13;
; eax = %ebx + (%ecx * 0x4) - 0x20&#13;
```&#13;
&#13;
## åŸºå€å¯»å€&#13;
&#13;
```asm&#13;
movsd  -0x18(%rbp),%xmm0&#13;
; ä» (rbp)åœ°å€-0x18 çš„å†…å­˜åœ°å€è¯»å–æ•°æ®ï¼Œç§»åŠ¨åˆ°xmm0 å¯„å­˜å™¨ &#13;
&#13;
mov    0x2db6(%rip),%rdi&#13;
; ä» (rip)åœ°å€ + 0x2db6 çš„å†…å­˜åœ°å€è¯»å–æ•°æ®ï¼Œç§»åŠ¨åˆ°rdi å¯„å­˜å™¨&#13;
```&#13;
&#13;
# op&#13;
&#13;
&gt; åç¼€è¡¨ç¤ºæ“ä½œæ•°çš„é•¿åº¦&#13;
&#13;
| åç¼€ | è¯´æ˜            | é•¿åº¦(å­—èŠ‚) | Cå£°æ˜                     |&#13;
| ---- | --------------- | ---------- | ------------------------- |&#13;
| `b`  | `byte`          | **1**      | `char c = 'z';`           |&#13;
| `w`  | `word`          | **2**      | `short len = 3;`          |&#13;
| `l`  | `long`          | **4**      | `int32_t val = 1024;`     |&#13;
| `q`  | `quad`          | **8**      | `uint64_t id = 42;`       |&#13;
| `sd` | `Scalar Double` | **8**      | `double p = 3.141592653;` |ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/32.html</guid><pubDate>Sat, 07 Sep 2024 06:21:44 +0000</pubDate></item><item><title>Rustè°ƒç”¨C++ 32bit lib(1)</title><link>https://0x1042.github.io//post/31.html</link><description># cå…¼å®¹&#13;
&#13;
```c++&#13;
#pragma once&#13;
&#13;
#ifdef __cplusplus&#13;
&#13;
extern 'C' {&#13;
#endif&#13;
void parse_entry(char *fname, int level);&#13;
&#13;
#ifdef __cplusplus&#13;
}&#13;
&#13;
#endif&#13;
```&#13;
&#13;
# cmake &#13;
&#13;
```cmake&#13;
set(CMAKE_POSITION_INDEPENDENT_CODE ON)&#13;
set(CMAKE_INTERPROCEDURAL_OPTIMIZATION TRUE)&#13;
&#13;
add_library(parse STATIC ${LIBSRC})&#13;
```&#13;
&#13;
&#13;
# rust 32 bit target&#13;
&#13;
```&#13;
&#13;
# add target&#13;
rustup target add i686-unknown-linux-gnu&#13;
&#13;
# ç¼–è¯‘&#13;
cargo build --target=i686-unknown-linux-gnu&#13;
```&#13;
&#13;
# å¯¼å…¥&#13;
&#13;
## ä¾èµ–&#13;
&#13;
```rust&#13;
[build-dependencies]&#13;
cc = '1.0'&#13;
```&#13;
&#13;
## ä»£ç  &#13;
&#13;
```rust &#13;
#[link(name = 'parse', kind = 'static')]&#13;
extern 'C' {&#13;
    fn parsev2() -&gt; c_void;&#13;
}&#13;
```&#13;
&#13;
## build.rs&#13;
&#13;
```rust&#13;
fn main() {&#13;
    println!('cargo:rustc-link-search=native=reallibpath');&#13;
}&#13;
&#13;
```&#13;
&#13;
## ç¼–è¯‘å¤±è´¥ &#13;
&lt;img width='1876' alt='image' src='https://github.com/user-attachments/assets/e2121d3b-f342-490f-bf15-e19141aaae35'&gt;&#13;
&#13;
```&#13;
undefined reference to std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, &#13;
std::allocator&lt;char&gt; &gt;::rfind(char, unsigned int) const&#13;
```&#13;
&#13;
&gt; æ›´æ–°build.rs&#13;
&#13;
```rust&#13;
// build.sh &#13;
&#13;
fn main() {&#13;
    // é“¾æ¥c++æ ‡å‡†åº“å’ŒgccåŠ¨æ€åº“ &#13;
    println!('cargo:rustc-link-lib=dylib=stdc++');&#13;
    println!('cargo:rustc-link-lib=dylib=gcc_s');&#13;
}&#13;
```&#13;
&#13;
&gt; æˆ–è€…å…¨é™æ€ç¼–è¯‘lib&#13;
&#13;
```cmake&#13;
target_link_libraries(parse&#13;
    -static-libstdc++&#13;
    -static-libgcc&#13;
)&#13;
```&#13;
&#13;
ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/31.html</guid><pubDate>Sun, 25 Aug 2024 09:01:17 +0000</pubDate></item><item><title>gcc 32ä½ç¼–è¯‘</title><link>https://0x1042.github.io//post/30.html</link><description># 32ä½ç¼–è¯‘ m32 &#13;
&#13;
```&#13;
set(CMAKE_C_FLAGS '${CMAKE_C_FLAGS} -m32')&#13;
set(CMAKE_CXX_FLAGS '${CMAKE_CXX_FLAGS} -m32')&#13;
```&#13;
&#13;
# å®‰è£…32ä½lib &#13;
&#13;
```&#13;
sudo apt install gcc-multilib g++-multilib libc6-dev-i386 -y&#13;
```&#13;
&#13;
# å¼€å¯O3&#13;
&#13;
&gt; `cmake` é»˜è®¤`RelWithDebInfo` æ¨¡å¼æ˜¯`O2`&#13;
&#13;
```cmake&#13;
set(CMAKE_C_FLAGS_RELWITHDEBINFO&#13;
    '-O3 -g'&#13;
    CACHE STRING&#13;
          'Flags used by the C compiler during release builds with debug info.'&#13;
          FORCE)&#13;
set(CMAKE_CXX_FLAGS_RELWITHDEBINFO&#13;
    '-O3 -g'&#13;
    CACHE&#13;
      STRING&#13;
      'Flags used by the C++ compiler during release builds with debug info.'&#13;
      FORCE)&#13;
```&#13;
 &#13;
&#13;
&#13;
ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/30.html</guid><pubDate>Sun, 25 Aug 2024 07:30:57 +0000</pubDate></item><item><title>debian/ubuntuåŸºæœ¬ä½¿ç”¨</title><link>https://0x1042.github.io//post/29.html</link><description># apt update&#13;
&#13;
## warning&#13;
&#13;
```&#13;
 sudo apt update&#13;
W: https://mirrors.tuna.tsinghua.edu.cn/llvm-apt/jammy/dists/llvm-toolchain-jammy-18/InRelease: &#13;
Key is stored in legacy trusted.gpg keyring (/etc/apt/trusted.gpg),&#13;
see the DEPRECATION section in apt-key(8) for details.&#13;
```&#13;
&#13;
&#13;
## å¤„ç†&#13;
&#13;
- æ‰¾åˆ°å¯¹åº”çš„key &#13;
```&#13;
sudo apt-key list&#13;
&#13;
# æ‰¾åˆ°ä¸warningç›¸å…³çš„key&#13;
# è¿™é‡Œæ˜¯llvmçš„ pub line æœ€å8ä¸ªå­—ç¬¦ &#13;
&#13;
```&#13;
&#13;
- å¯¼å…¥&#13;
&#13;
```&#13;
sudo apt-key export AF4F7421 | sudo gpg --dearmour -o /etc/apt/trusted.gpg.d/llvm.gpg&#13;
```&#13;
&#13;
- é‡æ–°update &#13;
&#13;
# æ¸…ç†æ— æ•ˆè½¯è¿æ¥&#13;
&#13;
```shell&#13;
&#13;
find . -xtype l&#13;
&#13;
find /path -xtype l&#13;
```&#13;
&#13;
&#13;
ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/29.html</guid><pubDate>Sat, 24 Aug 2024 08:24:42 +0000</pubDate></item><item><title>sock5 &amp;&amp; http proxy in go</title><link>https://0x1042.github.io//post/28.html</link><description># listen&#13;
&#13;
```go&#13;
type Stream struct {&#13;
	r *bufio.Reader&#13;
	net.Conn&#13;
}&#13;
&#13;
func newStream(c net.Conn) *Stream {&#13;
	return &amp;Stream{bufio.NewReader(c), c}&#13;
}&#13;
&#13;
func (b *Stream) Peek(n int) ([]byte, error) {&#13;
	return b.r.Peek(n)&#13;
}&#13;
&#13;
func (b *Stream) Read(p []byte) (int, error) {&#13;
	return b.r.Read(p)&#13;
}&#13;
&#13;
func (b *Stream) Line() (string, error) {&#13;
	line, _, err := b.r.ReadLine()&#13;
	return string(line), err&#13;
}&#13;
&#13;
func readBe[T any](r io.Reader, data T) (err error) {&#13;
	if err = binary.Read(r, binary.BigEndian, data); err != nil {&#13;
		log.Error().Err(err).Msg('readBe error')&#13;
	}&#13;
	return&#13;
}&#13;
&#13;
func writeBe[T any](r io.Writer, data T) (err error) {&#13;
	if err = binary.Write(r, binary.BigEndian, data); err != nil {&#13;
		log.Error().Err(err).Msg('writeBe error')&#13;
	}&#13;
	return&#13;
}&#13;
&#13;
func listen(option Option) error {&#13;
	var lc net.ListenConfig&#13;
	lc.SetMultipathTCP(true)&#13;
	lc.Control = func(_, _ string, c syscall.RawConn) error {&#13;
		var err error&#13;
		_ = c.Control(func(fd uintptr) {&#13;
			if option.nodelay {&#13;
				err = unix.SetsockoptInt(int(fd), unix.IPPROTO_TCP, unix.TCP_NODELAY, 1)&#13;
			}&#13;
			if option.fastOpen {&#13;
				err = unix.SetsockoptInt(int(fd), unix.IPPROTO_TCP, unix.TCP_FASTOPEN, 1)&#13;
			}&#13;
			if option.reuseAddr {&#13;
				err = unix.SetsockoptInt(int(fd), unix.SOL_SOCKET, unix.SO_REUSEADDR, 1)&#13;
				err = unix.SetsockoptInt(int(fd), unix.SOL_SOCKET, unix.SO_REUSEPORT, 1)&#13;
			}&#13;
		})&#13;
		return err&#13;
	}&#13;
	ln, err := lc.Listen(context.Background(), 'tcp', option.addr)&#13;
	if err != nil {&#13;
		return err&#13;
	}&#13;
&#13;
	log.Info().Str('addr', option.addr).Msg('server start')&#13;
&#13;
	for {&#13;
		conn, err := ln.Accept()&#13;
		if err != nil {&#13;
			log.Error().Err(err).Msg('accept error')&#13;
			break&#13;
		}&#13;
		stream := newStream(conn)&#13;
&#13;
		peek, _ := stream.Peek(1)&#13;
		log.Trace().Uint8('type', peek[0]).Str('from', conn.LocalAddr().String()).Msg('incomeing request')&#13;
		if peek[0] == 0x05 {&#13;
			go serveSocks(stream)&#13;
		} else {&#13;
			go serveHTTP(stream)&#13;
		}&#13;
	}&#13;
	return nil&#13;
}&#13;
&#13;
```&#13;
&#13;
&#13;
# http&#13;
&#13;
```go&#13;
&#13;
var SUCCESS = []byte('HTTP/1.1 200 Connection Established\r\n\r\n')&#13;
&#13;
const (&#13;
	CONNECT  = 'CONNECT'&#13;
	LF       = '\r\n'&#13;
	PORT     = '80'&#13;
	HEADLEN  = 5&#13;
	HEADSIZE = 512&#13;
)&#13;
&#13;
type Req struct {&#13;
	Method string&#13;
	Host   string&#13;
	Port   string&#13;
}&#13;
&#13;
func newReq(line []string) *Req {&#13;
	req := new(Req)&#13;
	req.Port = PORT&#13;
	// first&#13;
	{&#13;
		// CONNECT www.google.com:443 HTTP/1.1\r\n&#13;
		// GET http://www.google.com/ HTTP/1.1\r\n&#13;
		tmps := strings.Split(line[0], ' ')&#13;
		req.Method = tmps[0]&#13;
	}&#13;
&#13;
	// second&#13;
	{&#13;
&#13;
		// Host: www.google.com:443&#13;
		// Host: www.google.com&#13;
		tmps := strings.Split(line[1], ':')&#13;
		req.Host = strings.TrimSpace(tmps[1])&#13;
		if len(tmps) == 3 {&#13;
			req.Port = strings.TrimSpace(tmps[2])&#13;
		}&#13;
	}&#13;
	return req&#13;
}&#13;
&#13;
func serveHTTP(stream *Stream) {&#13;
	headers := make([]string, 0, HEADLEN)&#13;
	for {&#13;
		line, err := stream.Line()&#13;
		if err != nil {&#13;
			log.Error().Err(err).Msg('read line error')&#13;
			return&#13;
		}&#13;
&#13;
		if line == LF || len(line) == 0 {&#13;
			break&#13;
		}&#13;
		headers = append(headers, line)&#13;
	}&#13;
&#13;
	req := newReq(headers)&#13;
	remoteAddr := net.JoinHostPort(req.Host, req.Port)&#13;
&#13;
	remote, err := net.Dial('tcp', remoteAddr)&#13;
	if err != nil {&#13;
		log.Error().Err(err).Str('to', remoteAddr).Msg('connect error')&#13;
		return&#13;
	}&#13;
&#13;
	if req.Method == CONNECT {&#13;
		_, _ = stream.Write(SUCCESS)&#13;
	} else {&#13;
		buf := bytes.Buffer{}&#13;
		buf.Grow(HEADSIZE)&#13;
		for _, line := range headers {&#13;
			if strings.HasPrefix(line, 'Proxy') {&#13;
				continue&#13;
			}&#13;
			buf.WriteString(line)&#13;
			buf.WriteString(LF)&#13;
		}&#13;
		buf.WriteString(LF)&#13;
		_, _ = remote.Write(buf.Bytes())&#13;
	}&#13;
	relay(stream, remote)&#13;
}&#13;
&#13;
```&#13;
&#13;
# socks5&#13;
&#13;
```go&#13;
&#13;
var (&#13;
	SUC    = []byte{0x05, 0x00}&#13;
	SusRep = []byte{0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}&#13;
	errRep = []byte{0x05, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}&#13;
)&#13;
&#13;
func serveSocks(stream *Stream) {&#13;
	header := make([]byte, 2)&#13;
	_ = readBe(stream, &amp;header)&#13;
&#13;
	nmeth := header[1]&#13;
&#13;
	methods := make([]byte, int(nmeth))&#13;
	_ = readBe(stream, &amp;methods)&#13;
&#13;
	_ = writeBe(stream, SUC)&#13;
&#13;
	// read request&#13;
&#13;
	request := make([]byte, 4)&#13;
	_ = readBe(stream, &amp;request)&#13;
&#13;
	adtp := request[3]&#13;
&#13;
	var host string&#13;
&#13;
	switch adtp {&#13;
	case 1:&#13;
		hostBuf := make([]byte, net.IPv4len)&#13;
		_ = readBe(stream, &amp;hostBuf)&#13;
		host = net.IP(hostBuf).String()&#13;
	case 3:&#13;
		hostBuf := make([]byte, net.IPv6len)&#13;
		_ = readBe(stream, &amp;hostBuf)&#13;
		host = net.IP(hostBuf).String()&#13;
	default:&#13;
		var length uint8&#13;
		_ = readBe(stream, &amp;length)&#13;
		buf := make([]byte, length)&#13;
		_ = readBe(stream, &amp;buf)&#13;
		host = string(buf)&#13;
	}&#13;
&#13;
	portBuf := make([]byte, 2)&#13;
	_ = readBe(stream, &amp;portBuf)&#13;
	port := binary.BigEndian.Uint16(portBuf)&#13;
&#13;
	targetAddr := net.JoinHostPort(host, strconv.FormatInt(int64(port), 10))&#13;
&#13;
	remote, err := net.Dial('tcp', targetAddr)&#13;
	if err != nil {&#13;
		log.Error().Err(err).Str('remote', targetAddr).Msg('connect error')&#13;
		_, _ = stream.Write(errRep)&#13;
		return&#13;
	}&#13;
	_, _ = stream.Write(SusRep)&#13;
	relay(stream, remote)&#13;
}&#13;
&#13;
```&#13;
&#13;
# relay&#13;
&#13;
```go&#13;
type Resp struct {&#13;
	len  int64&#13;
	err  error&#13;
	from net.Addr&#13;
	to   net.Addr&#13;
}&#13;
&#13;
func relay(from, to net.Conn) {&#13;
	defer func(from, to net.Conn) {&#13;
		_ = from.Close()&#13;
		_ = to.Close()&#13;
	}(from, to)&#13;
&#13;
	channel := make(chan Resp, 2)&#13;
&#13;
	go func(dst, src net.Conn) {&#13;
		size, err := io.Copy(dst, src)&#13;
		channel &lt;- Resp{len: size, err: err, from: src.RemoteAddr(), to: dst.RemoteAddr()}&#13;
	}(from, to)&#13;
&#13;
	go func(dst, src net.Conn) {&#13;
		size, err := io.Copy(dst, src)&#13;
		channel &lt;- Resp{len: size, err: err, from: src.RemoteAddr(), to: dst.RemoteAddr()}&#13;
	}(to, from)&#13;
&#13;
	for resp := range channel {&#13;
		if resp.err != nil &amp;&amp; resp.err != io.EOF {&#13;
			log.Error().Err(resp.err).Str('from', resp.from.String()).Str('to', resp.to.String()).Msg('relay error')&#13;
		} else {&#13;
			log.Info().Str('from', resp.from.String()).Str('to', resp.to.String()).Int64('transfer', resp.len).Msg('relay success')&#13;
		}&#13;
	}&#13;
}&#13;
&#13;
```&#13;
ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/28.html</guid><pubDate>Sat, 13 Jul 2024 16:29:46 +0000</pubDate></item><item><title>sock5 &amp;&amp; http proxy in rust</title><link>https://0x1042.github.io//post/27.html</link><description># listen&#13;
&#13;
```rust&#13;
pub async fn listen(addr: &amp;str) -&gt; anyhow::Result&lt;()&gt; {&#13;
    let mut endpoint = addr.to_owned();&#13;
    let info: Vec&lt;_&gt; = addr.split(':').collect();&#13;
    if info[0].is_empty() {&#13;
        endpoint = format!('0.0.0.0:{}', info[1]);&#13;
    }&#13;
    let ln = tokio::net::TcpListener::bind(&amp;endpoint).await?;&#13;
    info!('server start. auto://{}', &amp;endpoint);&#13;
    loop {&#13;
        let (incoming, peer) = ln.accept().await?;&#13;
        info!('incoming request {:?}', peer);&#13;
        tokio::spawn(async move {&#13;
            if let Err(err) = proxy(incoming).await {&#13;
                error!('proxy error. {err}');&#13;
            }&#13;
        });&#13;
    }&#13;
}&#13;
&#13;
async fn proxy(incoming: tokio::net::TcpStream) -&gt; anyhow::Result&lt;()&gt; {&#13;
    incoming.set_nodelay(true)?;&#13;
    let mut ver = vec![0; 1];&#13;
    let _ = incoming.peek(&amp;mut ver).await?;&#13;
&#13;
    if ver[0] == 0x05 {&#13;
        return socks::handle(incoming).await;&#13;
    }&#13;
    return http::handle(incoming).await;&#13;
}&#13;
&#13;
```&#13;
&#13;
# http&#13;
&#13;
```rust &#13;
const CONNECT: &amp;str = 'CONNECT';&#13;
const LF: &amp;str = '\r\n';&#13;
const SUC: &amp;str = 'HTTP/1.1 200 Connection Established\r\n\r\n';&#13;
&#13;
pub async fn handle(incoming: tokio::net::TcpStream) -&gt; anyhow::Result&lt;()&gt; {&#13;
    let start = Instant::now();&#13;
    let from = incoming.peer_addr()?;&#13;
&#13;
    let mut stream = BufReader::new(incoming);&#13;
    let mut lines = Vec::with_capacity(4);&#13;
    loop {&#13;
        let mut buf = String::new();&#13;
        stream.read_line(&amp;mut buf).await?;&#13;
        if buf.eq(LF) || buf.is_empty() {&#13;
            break;&#13;
        }&#13;
        lines.push(buf);&#13;
    }&#13;
&#13;
    let reqlines = lines.join('');&#13;
    let mut headers = [httparse::EMPTY_HEADER; 4];&#13;
    let mut req = httparse::Request::new(&amp;mut headers);&#13;
    req.parse(reqlines.as_bytes())?;&#13;
&#13;
    let mut host = String::new();&#13;
    for ele in req.headers.iter() {&#13;
        if ele.name == 'Host' {&#13;
            host = String::from_utf8(ele.value.to_vec()).unwrap();&#13;
            break;&#13;
        }&#13;
    }&#13;
&#13;
    let mut endpoint = host;&#13;
&#13;
    if !endpoint.contains(':') {&#13;
        endpoint = format!('{}:80', endpoint);&#13;
    }&#13;
&#13;
    let mut remote = tokio::net::TcpStream::connect(&amp;endpoint).await?;&#13;
&#13;
    info!('connect to {} succsss. ', &amp;endpoint);&#13;
&#13;
    if req.method.unwrap() == CONNECT {&#13;
        stream.write(SUC.as_bytes()).await?;&#13;
    } else {&#13;
        let mut reqlines = String::new();&#13;
        reqlines.reserve(256);&#13;
        for line in lines.iter() {&#13;
            if line.starts_with('Proxy-Connection') {&#13;
                continue;&#13;
            }&#13;
            reqlines.push_str(line);&#13;
        }&#13;
        reqlines.push_str(LF);&#13;
        remote.write(reqlines.as_bytes()).await?;&#13;
    }&#13;
&#13;
    let (rl, wl) = tokio::io::copy_bidirectional(&amp;mut stream, &amp;mut remote).await?;&#13;
    info!(&#13;
        'http tunnel {} &lt;-&gt; {} write {} read {} cost {:?}',&#13;
        from,&#13;
        &amp;endpoint,&#13;
        rl,&#13;
        wl,&#13;
        start.elapsed()&#13;
    );&#13;
    Ok(())&#13;
}&#13;
```&#13;
&#13;
# socks5  &#13;
&#13;
```rust &#13;
#[derive(Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]&#13;
pub enum Addr {&#13;
    /// Socket address (IP Address)&#13;
    SocketAddress(SocketAddr),&#13;
    /// Domain name address&#13;
    DomainNameAddress(String, u16),&#13;
}&#13;
&#13;
impl Addr {&#13;
    async fn from_reader&lt;R&gt;(adtype: u8, reader: &amp;mut R) -&gt; anyhow::Result&lt;Addr&gt;&#13;
    where&#13;
        R: AsyncRead + Unpin,&#13;
    {&#13;
        if adtype == 0x01 {&#13;
            let mut buf = [0u8; 6];&#13;
            let _ = reader.read_exact(&amp;mut buf).await?;&#13;
&#13;
            let v4addr = Ipv4Addr::new(buf[0], buf[1], buf[2], buf[3]);&#13;
            let port = u16::from_be_bytes([buf[4], buf[5]]);&#13;
            return Ok(Addr::SocketAddress(SocketAddr::V4(SocketAddrV4::new(&#13;
                v4addr, port,&#13;
            ))));&#13;
        }&#13;
&#13;
        if adtype == 0x04 {&#13;
            let mut buf = [0u16; 9];&#13;
&#13;
            let bytes_buf = unsafe { slice::from_raw_parts_mut(buf.as_mut_ptr() as *mut _, 18) };&#13;
            let _ = reader.read_exact(bytes_buf).await?;&#13;
&#13;
            let v6addr = Ipv6Addr::new(&#13;
                u16::from_be(buf[0]),&#13;
                u16::from_be(buf[1]),&#13;
                u16::from_be(buf[2]),&#13;
                u16::from_be(buf[3]),&#13;
                u16::from_be(buf[4]),&#13;
                u16::from_be(buf[5]),&#13;
                u16::from_be(buf[6]),&#13;
                u16::from_be(buf[7]),&#13;
            );&#13;
            let port = u16::from_be(buf[8]);&#13;
&#13;
            return Ok(Addr::SocketAddress(SocketAddr::V6(SocketAddrV6::new(&#13;
                v6addr, port, 0, 0,&#13;
            ))));&#13;
        }&#13;
        let mut length_buf = [0u8; 1];&#13;
        let _ = reader.read_exact(&amp;mut length_buf).await?;&#13;
        let length = length_buf[0] as usize;&#13;
&#13;
        // Len(Domain) + Len(Port)&#13;
        let buf_length = length + 2;&#13;
&#13;
        let mut raw_addr = vec![0u8; buf_length];&#13;
        let _ = reader.read_exact(&amp;mut raw_addr).await?;&#13;
&#13;
        let raw_port = &amp;raw_addr[length..];&#13;
        let port = u16::from_be_bytes([raw_port[0], raw_port[1]]);&#13;
&#13;
        raw_addr.truncate(length);&#13;
&#13;
        let addr = String::from_utf8(raw_addr).unwrap();&#13;
&#13;
        Ok(Addr::DomainNameAddress(addr, port))&#13;
    }&#13;
}&#13;
&#13;
// https://datatracker.ietf.org/doc/html/rfc1928&#13;
// https://datatracker.ietf.org/doc/html/rfc1929&#13;
pub async fn handle(mut incoming: tokio::net::TcpStream) -&gt; anyhow::Result&lt;()&gt; {&#13;
    let start = Instant::now();&#13;
&#13;
    // step1 handshake&#13;
&#13;
    //    +----+----------+----------+&#13;
    //    |VER | NMETHODS | METHODS  |&#13;
    //    +----+----------+----------+&#13;
    //    | 1  |    1     | 1 to 255 |&#13;
    //    +----+----------+----------+&#13;
&#13;
    {&#13;
        let mut buf = vec![0; 2];&#13;
        let _ = incoming.read_exact(&amp;mut buf).await?;&#13;
        let ver = buf[0];&#13;
        let nmet = buf[1];&#13;
        if ver != 0x05 {&#13;
            return Err(anyhow::anyhow!('unsupport version'));&#13;
        }&#13;
&#13;
        let mut methods = vec![0u8; nmet as usize];&#13;
        let _ = incoming.read_exact(&amp;mut methods).await?;&#13;
&#13;
        for method in methods.iter() {&#13;
            debug!('method is {:?}', *method);&#13;
&#13;
            // if *method == 0x00 {&#13;
            //     let mut buffer = vec![0x05, 0x00];&#13;
            //     incoming.write(&amp;mut buffer).await?;&#13;
            // }&#13;
&#13;
            if *method == 0x02 {&#13;
                let mut buffer = vec![0x05, 0x02];&#13;
                incoming.write(&amp;mut buffer).await?;&#13;
                let ver = incoming.read_u8().await?;&#13;
&#13;
                debug!('ver is {}', ver);&#13;
&#13;
                // assert ver = 1&#13;
&#13;
                let ulen = incoming.read_u8().await?;&#13;
                let mut namebuf = vec![0u8; ulen as usize];&#13;
                let _ = incoming.read_exact(&amp;mut namebuf).await?;&#13;
&#13;
                let plen = incoming.read_u8().await?;&#13;
                let mut pbuf = vec![0u8; plen as usize];&#13;
                let _ = incoming.read_exact(&amp;mut pbuf).await?;&#13;
&#13;
                // todo check&#13;
&#13;
                info!(&#13;
                    'user is {} passwd is {}',&#13;
                    String::from_utf8(namebuf).unwrap(),&#13;
                    String::from_utf8(pbuf).unwrap()&#13;
                );&#13;
                let mut authreply = vec![0x01, 0x00];&#13;
                incoming.write(&amp;mut authreply).await?;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    // step2 read request&#13;
&#13;
    // +----+-----+-------+------+----------+----------+&#13;
    // |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |&#13;
    // +----+-----+-------+------+----------+----------+&#13;
    // | 1  |  1  | X'00' |  1   | Variable |    2     |&#13;
    // +----+-----+-------+------+----------+----------+&#13;
    //  o  IP V4 address: X'01'&#13;
    //  o  DOMAINNAME: X'03'&#13;
    //  o  IP V6 address: X'04'&#13;
    let mut buf: Vec&lt;u8&gt; = vec![0; 4];&#13;
    incoming.read_exact(&amp;mut buf).await?;&#13;
&#13;
    // todo check ver and cmd&#13;
    let adtype = buf[3];&#13;
    let addr = Addr::from_reader(adtype, &amp;mut incoming).await?;&#13;
&#13;
    let mut remote = match addr {&#13;
        Addr::SocketAddress(sock) =&gt; tokio::net::TcpStream::connect(sock).await?,&#13;
        Addr::DomainNameAddress(domain, port) =&gt; {&#13;
            tokio::net::TcpStream::connect((domain, port)).await?&#13;
        }&#13;
    };&#13;
&#13;
    let mut reply = vec![0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];&#13;
    incoming.write(&amp;mut reply).await?;&#13;
&#13;
    let from = incoming.peer_addr()?;&#13;
    // let tunnel = incoming.local_addr()?;&#13;
    let target = remote.peer_addr()?;&#13;
&#13;
    let (rl, wl) = tokio::io::copy_bidirectional(&amp;mut incoming, &amp;mut remote).await?;&#13;
&#13;
    info!(&#13;
        'TCP tunnel {} &lt;-&gt; {} write {} read {} cost {:?}',&#13;
        from,&#13;
        target,&#13;
        rl,&#13;
        wl,&#13;
        start.elapsed()&#13;
    );&#13;
    Ok(())&#13;
}&#13;
&#13;
```ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/27.html</guid><pubDate>Sat, 13 Jul 2024 16:25:58 +0000</pubDate></item><item><title>sock5 &amp;&amp; http proxy in asio</title><link>https://0x1042.github.io//post/26.html</link><description># listen&#13;
&#13;
```c++&#13;
asio::awaitable&lt;void&gt; listener(asio::io_context &amp;io_context,&#13;
                               unsigned short port) {&#13;
  auto endpoint = asio::ip::tcp::endpoint(asio::ip::tcp::v4(), port);&#13;
  spdlog::info('server listen at {}:{}', endpoint.address().to_string(),&#13;
               endpoint.port());&#13;
&#13;
  asio::ip::tcp::acceptor acceptor(io_context, endpoint);&#13;
  for (;;) {&#13;
    asio::ip::tcp::socket socket =&#13;
        co_await acceptor.async_accept(asio::use_awaitable);&#13;
&#13;
    std::array&lt;std::byte, 1&gt; data{};&#13;
    socket.receive(asio::buffer(data), asio::socket_base::message_peek);&#13;
    const auto &amp;endpoint = socket.remote_endpoint();&#13;
    spdlog::info('incoming request. {}:{}', endpoint.address().to_string(),&#13;
                 endpoint.port());&#13;
&#13;
    if (std::to_integer&lt;uint8_t&gt;(data.at(0)) == 0x05) {&#13;
      asio::co_spawn(io_context, socks::handle(std::move(socket)),&#13;
                     asio::detached);&#13;
    } else {&#13;
      asio::co_spawn(io_context, http::handle(std::move(socket)),&#13;
                     asio::detached);&#13;
    }&#13;
  }&#13;
```&#13;
&#13;
# http&#13;
&#13;
```c++&#13;
asio::awaitable&lt;void&gt; handle(asio::ip::tcp::socket socket) {&#13;
  try {&#13;
    asio::streambuf buffer;&#13;
&#13;
    std::vector&lt;std::string&gt; lines;&#13;
    for (;;) {&#13;
      std::size_t n = co_await asio::async_read_until(socket, buffer, '\r\n',&#13;
                                                      asio::use_awaitable);&#13;
      auto bufs = buffer.data();&#13;
      std::string line(asio::buffers_begin(bufs),&#13;
                       asio::buffers_begin(bufs) + n);&#13;
&#13;
      if (line == '\r\n') {&#13;
        break;&#13;
      }&#13;
&#13;
      lines.push_back(std::move(line));&#13;
      buffer.consume(n);&#13;
    }&#13;
&#13;
    std::string line = replace_all(lines.at(1), '\r\n', '');&#13;
    line = replace_all(line, 'Host: ', '');&#13;
&#13;
    std::string port = '80';&#13;
&#13;
    std::vector&lt;std::string&gt; hostport = absl::StrSplit(line, ':');&#13;
    std::string host = hostport[0];&#13;
    if (hostport.size() == 2) {&#13;
      port = hostport[1];&#13;
    }&#13;
&#13;
    asio::ip::tcp::resolver resolver(socket.get_executor());&#13;
    asio::ip::tcp::resolver::results_type endpoints =&#13;
        co_await resolver.async_resolve(host, port, asio::use_awaitable);&#13;
&#13;
    asio::ip::tcp::socket remote_socket(socket.get_executor());&#13;
&#13;
    // todo http&#13;
&#13;
    co_await asio::async_connect(remote_socket, endpoints, asio::use_awaitable);&#13;
&#13;
    spdlog::info('connect to {}:{} success. ',&#13;
                 endpoints-&gt;endpoint().address().to_string(),&#13;
                 endpoints-&gt;endpoint().port());&#13;
&#13;
    const std::string &amp;response = 'HTTP/1.1 200 Connection Established\r\n\r\n';&#13;
    co_await asio::async_write(socket, asio::buffer(response),&#13;
                               asio::use_awaitable);&#13;
    co_await relay(socket, remote_socket);&#13;
&#13;
  } catch (const std::exception &amp;ex) {&#13;
    spdlog::error('run exception :{}', ex.what());&#13;
  }&#13;
}&#13;
```&#13;
&#13;
# socks5&#13;
&#13;
```c++&#13;
asio::awaitable&lt;void&gt; handle(asio::ip::tcp::socket socket) {&#13;
  try {&#13;
    // Perform SOCKS5 handshake&#13;
    std::array&lt;uint8_t, 4&gt; handshake_request{};&#13;
    co_await asio::async_read(socket, asio::buffer(handshake_request),&#13;
                              asio::use_awaitable);&#13;
&#13;
    if (handshake_request[0] != 0x05) {&#13;
      co_return; // Not SOCKS5&#13;
    }&#13;
    std::array&lt;uint8_t, 2&gt; handshake_response = {0x05, 0x00};&#13;
    co_await asio::async_write(socket, asio::buffer(handshake_response),&#13;
                               asio::use_awaitable);&#13;
&#13;
    // Read SOCKS5 request&#13;
    std::array&lt;uint8_t, 4&gt; request{};&#13;
    co_await asio::async_read(socket, asio::buffer(request),&#13;
                              asio::use_awaitable);&#13;
&#13;
    if (request[1] != 0x01) {&#13;
      co_return; // Only support CONNECT command&#13;
    }&#13;
&#13;
    // Read address and port&#13;
    std::array&lt;uint8_t, 4&gt; address{};&#13;
    co_await asio::async_read(socket, asio::buffer(address),&#13;
                              asio::use_awaitable);&#13;
&#13;
    std::array&lt;uint8_t, 2&gt; port{};&#13;
    co_await asio::async_read(socket, asio::buffer(port), asio::use_awaitable);&#13;
&#13;
    asio::ip::tcp::endpoint remote_endpoint(asio::ip::make_address_v4(address),&#13;
                                            (port[0] &lt;&lt; 8) | port[1]);&#13;
&#13;
    spdlog::info('connect to {}:{} success. ',&#13;
                 remote_endpoint.address().to_string(), remote_endpoint.port());&#13;
&#13;
    asio::ip::tcp::socket remote_socket(socket.get_executor());&#13;
&#13;
    // Connect to the remote server&#13;
    co_await remote_socket.async_connect(remote_endpoint, asio::use_awaitable);&#13;
&#13;
    // Send success response to the client&#13;
    std::array&lt;uint8_t, 10&gt; response = {&#13;
        0x05,       0x00,       0x00,       0x01,    address[0],&#13;
        address[1], address[2], address[3], port[0], port[1]};&#13;
    co_await asio::async_write(socket, asio::buffer(response),&#13;
                               asio::use_awaitable);&#13;
&#13;
    // Relay traffic between client and remote server&#13;
    co_await relay(socket, remote_socket);&#13;
  } catch (const std::exception &amp;ex) {&#13;
    spdlog::error('run exception :{}', ex.what());&#13;
  }&#13;
}&#13;
```&#13;
&#13;
# relay&#13;
&#13;
```c++&#13;
asio::awaitable&lt;void&gt; relay(asio::ip::tcp::socket &amp;from,&#13;
                            asio::ip::tcp::socket &amp;to) {&#13;
&#13;
  auto relay = [](asio::ip::tcp::socket &amp;from,&#13;
                  asio::ip::tcp::socket &amp;to) -&gt; asio::awaitable&lt;void&gt; {&#13;
    const auto &amp;from_addr = from.remote_endpoint();&#13;
    const auto &amp;to_addr = to.remote_endpoint();&#13;
    size_t cnt = 0;&#13;
    try {&#13;
      std::array&lt;std::byte, bufsize&gt; data{};&#13;
      for (;;) {&#13;
        std::size_t n = co_await from.async_read_some(asio::buffer(data),&#13;
                                                      asio::use_awaitable);&#13;
        co_await asio::async_write(to, asio::buffer(data, n),&#13;
                                   asio::use_awaitable);&#13;
        cnt += n;&#13;
      }&#13;
    } catch (...) {&#13;
      from.close();&#13;
      to.close();&#13;
    }&#13;
&#13;
    spdlog::info('{}:{} -&gt; {}:{} transfer {} bytes success. ',&#13;
                 from_addr.address().to_string(), from_addr.port(),&#13;
                 to_addr.address().to_string(), to_addr.port(), cnt);&#13;
  };&#13;
&#13;
  co_await (relay(from, to) &amp;&amp; relay(to, from));&#13;
}&#13;
```&#13;
&#13;
# main&#13;
&#13;
```c++&#13;
ABSL_FLAG(uint16_t, port, 10010, 'server listen port');&#13;
ABSL_FLAG(size_t, worker, 4, 'worker num');&#13;
&#13;
int main(int argc, char **argv) {&#13;
&#13;
  absl::ParseCommandLine(argc, argv);&#13;
&#13;
  auto console = spdlog::stdout_color_mt('console');&#13;
  spdlog::set_default_logger(console);&#13;
  spdlog::set_pattern('%^[%H:%M:%S %e] %l thread-%t %v %$');&#13;
&#13;
  try {&#13;
    asio::io_context io_context;&#13;
&#13;
    // Run listener coroutine&#13;
    asio::co_spawn(io_context, listener(io_context, absl::GetFlag(FLAGS_port)),&#13;
                   asio::detached);&#13;
&#13;
    std::vector&lt;std::thread&gt; threads;&#13;
    size_t worker_num = absl::GetFlag(FLAGS_worker);&#13;
&#13;
    threads.resize(worker_num);&#13;
    for (size_t i = 0; i &lt; worker_num; ++i) {&#13;
      threads.emplace_back([&amp;io_context]() { io_context.run(); });&#13;
    }&#13;
&#13;
    io_context.run();&#13;
&#13;
    // Join all threads&#13;
    for (auto &amp;t : threads) {&#13;
      t.join();&#13;
    }&#13;
  } catch (const std::exception &amp;ex) {&#13;
    spdlog::error('run exception :{}', ex.what());&#13;
  }&#13;
  return 0;&#13;
}&#13;
```&#13;
ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/26.html</guid><pubDate>Mon, 01 Jul 2024 17:10:21 +0000</pubDate></item><item><title>asioåŸºæœ¬ä½¿ç”¨</title><link>https://0x1042.github.io//post/25.html</link><description># è§£æåŸŸå&#13;
&#13;
```c++&#13;
    std::string domain = 'www.toutiao.com';&#13;
    std::string port = '443';&#13;
&#13;
    asio::ip::tcp::resolver resolver(socket.get_executor());&#13;
    asio::ip::tcp::resolver::results_type endpoints =&#13;
        co_await resolver.async_resolve(host, port, asio::use_awaitable);&#13;
```&#13;
&#13;
# tcpè¿æ¥ &#13;
&#13;
```c++&#13;
&#13;
// è¿æ¥è§£æåçš„ç»“æœ &#13;
&#13;
asio::ip::tcp::socket remote_socket(socket.get_executor());&#13;
co_await asio::async_connect(remote_socket, endpoints, asio::use_awaitable);&#13;
&#13;
// è¿æ¥host port&#13;
asio::ip::tcp::endpoint remote_endpoint(asio::ip::make_address_v4(address),&#13;
                                            (port[0] &lt;&lt; 8) | port[1]);&#13;
asio::ip::tcp::socket remote_socket(socket.get_executor());&#13;
co_await remote_socket.async_connect(remote_endpoint, asio::use_awaitable);&#13;
```&#13;
&#13;
# copy ä¸¤ä¸ªsocket &#13;
&#13;
```c++&#13;
using namespace asio::experimental::awaitable_operators;&#13;
&#13;
constexpr size_t bufsize = 16 * 1024;&#13;
&#13;
asio::awaitable&lt;void&gt; relay(asio::ip::tcp::socket &amp;from,&#13;
                            asio::ip::tcp::socket &amp;to) {&#13;
&#13;
  auto relay = [](asio::ip::tcp::socket &amp;from,&#13;
                  asio::ip::tcp::socket &amp;to) -&gt; asio::awaitable&lt;void&gt; {&#13;
    try {&#13;
      std::array&lt;uint8_t, bufsize&gt; data{};&#13;
      for (;;) {&#13;
        std::size_t n = co_await from.async_read_some(asio::buffer(data),&#13;
                                                      asio::use_awaitable);&#13;
        co_await asio::async_write(to, asio::buffer(data, n),&#13;
                                   asio::use_awaitable);&#13;
      }&#13;
    } catch (...) {&#13;
      from.close();&#13;
      to.close();&#13;
    }&#13;
  };&#13;
&#13;
  co_await (relay(from, to) &amp;&amp; relay(to, from));&#13;
}&#13;
&#13;
&#13;
// ä½¿ç”¨ &#13;
co_await relay(socket, remote_socket);&#13;
&#13;
```&#13;
&#13;
# è¯»å–æŒ‡å®šé•¿åº¦æ•°æ® &#13;
&#13;
```c++&#13;
std::array&lt;uint8_t, 4&gt; handshake_request{};&#13;
co_await asio::async_read(socket, asio::buffer(handshake_request), asio::use_awaitable);&#13;
```&#13;
&#13;
# æŒ‰è¡Œè¯»å– &#13;
&#13;
```c++&#13;
    asio::streambuf buffer;&#13;
    std::vector&lt;std::string&gt; lines;&#13;
    for (;;) {&#13;
      std::size_t n = co_await asio::async_read_until(socket, buffer, '\r\n',&#13;
                                                      asio::use_awaitable);&#13;
      auto bufs = buffer.data();&#13;
      std::string line(asio::buffers_begin(bufs),&#13;
                       asio::buffers_begin(bufs) + n);&#13;
&#13;
      if (line == '\r\n') {&#13;
        break;&#13;
      }&#13;
&#13;
      lines.push_back(std::move(line));&#13;
      buffer.consume(n);&#13;
    }&#13;
```&#13;
&#13;
# peek &#13;
&#13;
```c++&#13;
std::array&lt;uint8_t, 1&gt; data{};&#13;
socket.receive(asio::buffer(data), asio::socket_base::message_peek);&#13;
std::clog &lt;&lt; 'message_peek:' &lt;&lt; fmt::to_string(data) &lt;&lt; '\n';&#13;
```&#13;
&#13;
&#13;
# å†™å…¥æ•°æ®&#13;
&#13;
- å†™å…¥string&#13;
&#13;
```c++&#13;
const std::string &amp;response = 'HTTP/1.1 200 Connection Established\r\n\r\n';&#13;
co_await asio::async_write(socket, asio::buffer(response),&#13;
                               asio::use_awaitable);&#13;
```&#13;
&#13;
- å†™å…¥bytes&#13;
&#13;
```c++&#13;
std::array&lt;uint8_t, 10&gt; response = {&#13;
        0x05,       0x00,       0x00,       0x01,    address[0],&#13;
        address[1], address[2], address[3], port[0], port[1]};&#13;
co_await asio::async_write(socket, asio::buffer(response),&#13;
                               asio::use_awaitable);&#13;
```&#13;
&#13;
# listen&#13;
&#13;
```c++&#13;
auto endpoint = asio::ip::tcp::endpoint(asio::ip::tcp::v4(), port);&#13;
asio::ip::tcp::acceptor acceptor(io_context, endpoint);&#13;
&#13;
  for (;;) {&#13;
    asio::ip::tcp::socket socket = co_await acceptor.async_accept(asio::use_awaitable);&#13;
  }&#13;
&#13;
```&#13;
&#13;
&#13;
&#13;
ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/25.html</guid><pubDate>Sun, 30 Jun 2024 18:45:30 +0000</pubDate></item><item><title>parallel</title><link>https://0x1042.github.io//post/24.html</link><description># parallel&#13;
&#13;
## fetch &#13;
&#13;
```c++&#13;
auto fetch(const std::string &amp; url) -&gt; int {&#13;
    Timer start;&#13;
    cpr::Response r = cpr::Get(cpr::Url{url}, cpr::Timeout{std::chrono::milliseconds(200)});&#13;
    LOG(INFO) &lt;&lt; 'thread-' &lt;&lt; std::this_thread::get_id() &lt;&lt; ' fetch [' &lt;&lt; url &lt;&lt; '] cost:' &lt;&lt; start.get_elapsed_ms()&#13;
              &lt;&lt; ' ms. status_code: ' &lt;&lt; r.status_code &lt;&lt; ' text:' &lt;&lt; r.text.size() &lt;&lt; '\n';&#13;
    return 0;&#13;
}&#13;
```&#13;
&#13;
## folly&#13;
 &#13;
```c++&#13;
    Timer start;&#13;
&#13;
    std::vector&lt;std::string&gt; urls = {&#13;
        'https://www.cnblogs.com/',&#13;
        'https://www.alipan.com/',&#13;
        'https://www.toutiao.com/',&#13;
    };&#13;
&#13;
    std::vector&lt;folly::Future&lt;int&gt;&gt; futures;&#13;
    futures.reserve(urls.size());&#13;
&#13;
    for (const auto &amp; url : urls) {&#13;
        auto fn = folly::via(infra::global().get(), [url]() { return infra::fetch(url); });&#13;
        futures.push_back(std::move(fn));&#13;
    }&#13;
&#13;
    folly::collectAll(futures).get();&#13;
&#13;
    LOG(INFO) &lt;&lt; 'folly fetch ' &lt;&lt; urls.size() &lt;&lt; ' total cost:' &lt;&lt; start.get_elapsed_ms() &lt;&lt; ' ms\n';&#13;
```&#13;
&#13;
## omp &#13;
&#13;
```c++&#13;
    Timer start;&#13;
&#13;
    std::vector&lt;std::string&gt; urls = {&#13;
        'https://www.cnblogs.com/',&#13;
        'https://www.alipan.com/',&#13;
        'https://www.toutiao.com/',&#13;
    };&#13;
&#13;
#pragma omp parallel for num_threads(urls.size())&#13;
    for (size_t i = 0; i &lt; urls.size(); i++) {&#13;
        int status = infra::fetch(urls[i]);&#13;
        LOG(INFO) &lt;&lt; 'status:' &lt;&lt; status;&#13;
    }&#13;
    LOG(INFO) &lt;&lt; 'omp fetch ' &lt;&lt; urls.size() &lt;&lt; ' total cost:' &lt;&lt; start.get_elapsed_ms() &lt;&lt; ' ms\n';&#13;
```ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/24.html</guid><pubDate>Sun, 19 May 2024 16:20:10 +0000</pubDate></item><item><title>highway hash  </title><link>https://0x1042.github.io//post/23.html</link><description># highway hash &#13;
&#13;
- c [https://github.com/google/highwayhash](https://github.com/google/highwayhash) &#13;
- go [https://github.com/minio/highwayhash](https://github.com/minio/highwayhash)&#13;
&#13;
# go &#13;
&#13;
## 64bit &#13;
&#13;
```go&#13;
&#13;
var (&#13;
	key [32]byte&#13;
)&#13;
&#13;
func HighHash(input string) string {&#13;
	hash, _ := highwayhash.New64(key[:])&#13;
	hash.Write([]byte(input))&#13;
	checksum := hash.Sum(nil)&#13;
	return hex.EncodeToString(checksum)&#13;
}&#13;
&#13;
func HighHashFile(path string) string {&#13;
	hash, _ := highwayhash.New64(key[:])&#13;
	file, _ := os.Open(path)&#13;
	io.Copy(hash, file)&#13;
	return hex.EncodeToString(hash.Sum(nil))&#13;
}&#13;
```&#13;
&#13;
&#13;
## 128 bit&#13;
&#13;
```go&#13;
func HighHash128(input string) string {&#13;
	hash, _ := highwayhash.New128(key[:])&#13;
	hash.Write([]byte(input))&#13;
	checksum := hash.Sum(nil)&#13;
	return hex.EncodeToString(checksum)&#13;
}&#13;
```&#13;
&#13;
# c++&#13;
&#13;
## 64bit &#13;
&#13;
```c++&#13;
&#13;
void put_uint64_le(uint8_t *buf, uint64_t value) {&#13;
  buf[0] = static_cast&lt;uint8_t&gt;(value &amp; 0xFF);&#13;
  buf[1] = static_cast&lt;uint8_t&gt;((value &gt;&gt; 8) &amp; 0xFF);&#13;
  buf[2] = static_cast&lt;uint8_t&gt;((value &gt;&gt; 16) &amp; 0xFF);&#13;
  buf[3] = static_cast&lt;uint8_t&gt;((value &gt;&gt; 24) &amp; 0xFF);&#13;
  buf[4] = static_cast&lt;uint8_t&gt;((value &gt;&gt; 32) &amp; 0xFF);&#13;
  buf[5] = static_cast&lt;uint8_t&gt;((value &gt;&gt; 40) &amp; 0xFF);&#13;
  buf[6] = static_cast&lt;uint8_t&gt;((value &gt;&gt; 48) &amp; 0xFF);&#13;
  buf[7] = static_cast&lt;uint8_t&gt;((value &gt;&gt; 56) &amp; 0xFF);&#13;
}&#13;
&#13;
const static uint64_t EMPTY_KEY[4] = {0, 0, 0, 0};&#13;
&#13;
std::string high_hash(const std::string &amp;input) {&#13;
  uint64_t hash = HighwayHash64(reinterpret_cast&lt;const uint8_t *&gt;(input.data()),&#13;
                                input.size(), EMPTY_KEY);&#13;
  uint8_t bytes[8];&#13;
  put_uint64_le(bytes, hash);&#13;
  std::string rsp;&#13;
  for (int i = 0; i &lt; 8; i++) {&#13;
    rsp += fmt::format('{0:02x}', bytes[i]);&#13;
  }&#13;
  return rsp;&#13;
}&#13;
```&#13;
&#13;
## 128 bit&#13;
&#13;
```c++&#13;
&#13;
std::string high_hash128(const std::string &amp;input) {&#13;
  uint64_t hash[2];&#13;
  HighwayHash128(reinterpret_cast&lt;const uint8_t *&gt;(input.data()), input.size(),&#13;
                 EMPTY_KEY, hash);&#13;
  uint8_t bytes1[8];&#13;
  put_uint64_le(bytes1, hash[0]);&#13;
&#13;
  uint8_t bytes2[8];&#13;
  put_uint64_le(bytes2, hash[1]);&#13;
  std::string rsp;&#13;
  for (int i = 0; i &lt; 8; i++) {&#13;
    rsp += fmt::format('{0:02x}', bytes1[i]);&#13;
  }&#13;
  for (int i = 0; i &lt; 8; i++) {&#13;
    rsp += fmt::format('{0:02x}', bytes2[i]);&#13;
  }&#13;
  return rsp;&#13;
}&#13;
```&#13;
&#13;
## ä¼˜åŒ–ç‰ˆæœ¬&#13;
&#13;
```c++&#13;
auto high_hash128_v2(const std::string &amp; input) -&gt; std::string {&#13;
    uint64_t hash[2];&#13;
    HighwayHash128(reinterpret_cast&lt;const uint8_t *&gt;(input.data()), input.size(), EMPTY_KEY, hash);&#13;
&#13;
    std::array&lt;uint8_t, 16&gt; buffer{};&#13;
    std::memcpy(buffer.data(), &amp;hash, sizeof(hash));&#13;
&#13;
    std::string rsp;&#13;
    for (unsigned char &amp; b : buffer) {&#13;
        rsp += fmt::format('{0:02x}', b);&#13;
    }&#13;
    return rsp;&#13;
}&#13;
```&#13;
ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/23.html</guid><pubDate>Thu, 16 May 2024 16:54:53 +0000</pubDate></item><item><title>absl timeåŸºæœ¬ä½¿ç”¨</title><link>https://0x1042.github.io//post/22.html</link><description>&#13;
# æ—¶é—´åŸºæœ¬ä½¿ç”¨ &#13;
&#13;
## è·å–æŒ‡å®šæ—¶åŒºçš„æ—¶é—´ &#13;
&#13;
```c++&#13;
        absl::TimeZone local;&#13;
        absl::LoadTimeZone('Asia/Shanghai', &amp;local);&#13;
        auto now_in_second = absl::ToCivilSecond(absl::Now(), local);&#13;
        std::clog &lt;&lt; 'now_in_second:' &lt;&lt; now_in_second &lt;&lt; '\n';&#13;
```&#13;
&#13;
&#13;
## è·å–æŒ‡å®šæ—¶åŒºå½“å‰å°æ—¶&#13;
&#13;
```c++&#13;
        absl::TimeZone local;&#13;
        absl::LoadTimeZone('Asia/Shanghai', &amp;local);&#13;
        auto now_in_hour = absl::ToCivilHour(absl::Now(), local);&#13;
        std::clog &lt;&lt; 'now_in_hour:' &lt;&lt; now_in_hour.hour() &lt;&lt; '\n';&#13;
```&#13;
&#13;
## è·å–æ—¥æœŸ &#13;
&#13;
```c++&#13;
    absl::Duration one_day = absl::Hours(24) * offset;&#13;
    absl::Time tt = absl::Now() + one_day;&#13;
    absl::TimeZone local;&#13;
    absl::LoadTimeZone('Asia/Shanghai', &amp;local);&#13;
    auto today = absl::ToCivilDay(tt, local);&#13;
    return absl::FormatCivilTime(today);&#13;
```&#13;
&#13;
## è§£æå­—ç¬¦ä¸²åˆ°æ—¶é—´ &#13;
&#13;
```c++&#13;
auto str2time(const std::string &amp; str, absl::Time &amp; dst, absl::TimeZone tz) -&gt; bool {&#13;
    std::string err;&#13;
    bool status = absl::ParseTime('%Y-%m-%d', str, tz, &amp;dst, &amp;err);&#13;
    return status;&#13;
}&#13;
&#13;
auto parse_time(const std::string &amp; str) -&gt; absl::CivilDay {&#13;
    absl::CivilDay day;&#13;
&#13;
    bool status = absl::ParseCivilTime(str, &amp;day);&#13;
    std::clog &lt;&lt; 'status:' &lt;&lt; status &lt;&lt; '\n';&#13;
    return day;&#13;
}&#13;
```&#13;
&#13;
## æ—¶é—´è®¡ç®—&#13;
&#13;
```c++&#13;
        const std::string &amp; start_str = '2024-05-10';&#13;
        auto start = parse_time(start_str);&#13;
&#13;
        const std::string &amp; end_str = '2024-05-18';&#13;
        auto end = parse_time(end_str);&#13;
&#13;
        std::clog &lt;&lt; '(end - start) = ' &lt;&lt; end - start &lt;&lt; '\n';&#13;
        ASSERT_EQ(end - start, 8);&#13;
```ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/22.html</guid><pubDate>Fri, 10 May 2024 16:54:33 +0000</pubDate></item><item><title>cmake å¼€å¯sanitize</title><link>https://0x1042.github.io//post/21.html</link><description>&#13;
- [é…ç½®](#é…ç½®)&#13;
- [æµ‹è¯•](#æµ‹è¯•)&#13;
- [ç¼–è¯‘è¿è¡Œ](#ç¼–è¯‘è¿è¡Œ)&#13;
  - [`-fsanitize=thread`](#-fsanitizethread)&#13;
  - [`-fsanitize=address`](#-fsanitizeaddress)&#13;
- [`sanitier`](#sanitier)&#13;
&#13;
# é…ç½® &#13;
&#13;
```cmake&#13;
option(ENABLE_SANITIZE 'Enable feature' ON)&#13;
&#13;
if(ENABLE_SANITIZE) &#13;
  add_compile_options('-fno-omit-frame-pointer') &#13;
  add_compile_options('-fno-optimize-sibling-calls')&#13;
  # add_compile_options('-fsanitize=address')&#13;
  add_compile_options('-fsanitize=thread')&#13;
  add_compile_options('-fsanitize-address-use-after-scope')&#13;
  # set(CMAKE_EXE_LINKER_FLAGS '-fno-omit-frame-pointer -fno-optimize-sibling-calls -fsanitize=address' ) &#13;
  set(CMAKE_EXE_LINKER_FLAGS '-fno-omit-frame-pointer -fno-optimize-sibling-calls -fsanitize=thread' ) &#13;
endif()&#13;
```&#13;
&#13;
# æµ‹è¯•&#13;
&#13;
```c++&#13;
#include &lt;functional&gt;&#13;
#include &lt;string&gt;&#13;
#include &lt;thread&gt;&#13;
#include &lt;vector&gt;&#13;
&#13;
#include &lt;fmt/ranges.h&gt;&#13;
#include &lt;gtest/gtest.h&gt;&#13;
&#13;
void add_to_vec(std::vector&lt;std::string&gt; &amp;target, const std::string &amp;name) {&#13;
	for (int i = 0; i &lt; 10; i++) {&#13;
		target.push_back(fmt::format('{}:{}', name, i));&#13;
	}&#13;
}&#13;
&#13;
TEST(race, addtovec) {&#13;
	std::vector&lt;std::string&gt; dst;&#13;
	std::string hello = 'hello';&#13;
	std::string world = 'world';&#13;
	std::thread t1(add_to_vec, std::ref(dst), std::cref(hello));&#13;
	std::thread t2(add_to_vec, std::ref(dst), std::cref(world));&#13;
	t1.join();&#13;
	t2.join();&#13;
	std::cerr &lt;&lt; ' res: ' &lt;&lt; fmt::format('{}', dst) &lt;&lt; '\n';&#13;
}&#13;
```&#13;
&#13;
# ç¼–è¯‘è¿è¡Œ &#13;
&#13;
## `-fsanitize=thread`&#13;
&#13;
```shell&#13;
WARNING: ThreadSanitizer: data race (pid=77881)&#13;
  Read of size 8 at 0x7ff7ba7ae880 by thread T4:&#13;
    #0 add_to_vec(std::__1::vector&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;, std::__1::allocator&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&gt;&gt;&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt; const&amp;) race.cc:14 (singleton:x86_64+0x100021ba9)&#13;
    #1 void* std::__1::__thread_proxy[abi:ue170006]&lt;std::__1::tuple&lt;std::__1::unique_ptr&lt;std::__1::__thread_struct, std::__1::default_delete&lt;std::__1::__thread_struct&gt;&gt;, void (*)(std::__1::vector&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;, std::__1::allocator&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&gt;&gt;&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt; const&amp;), std::__1::reference_wrapper&lt;std::__1::vector&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;, std::__1::allocator&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&gt;&gt;&gt;, std::__1::reference_wrapper&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt; const&gt;&gt;&gt;(void*) thread.h:232 (singleton:x86_64+0x100022437)&#13;
&#13;
  Previous write of size 8 at 0x7ff7ba7ae880 by thread T3:&#13;
    #0 add_to_vec(std::__1::vector&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;, std::__1::allocator&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&gt;&gt;&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt; const&amp;) race.cc:14 (singleton:x86_64+0x100021b0b)&#13;
    #1 void* std::__1::__thread_proxy[abi:ue170006]&lt;std::__1::tuple&lt;std::__1::unique_ptr&lt;std::__1::__thread_struct, std::__1::default_delete&lt;std::__1::__thread_struct&gt;&gt;, void (*)(std::__1::vector&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;, std::__1::allocator&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&gt;&gt;&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt; const&amp;), std::__1::reference_wrapper&lt;std::__1::vector&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;, std::__1::allocator&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&gt;&gt;&gt;, std::__1::reference_wrapper&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt; const&gt;&gt;&gt;(void*) thread.h:232 (singleton:x86_64+0x100022437)&#13;
```&#13;
&#13;
## `-fsanitize=address`&#13;
&#13;
```shell&#13;
==84486==ERROR: AddressSanitizer: attempting free on address which was not malloc()-ed: 0x603000003058 in thread T4&#13;
    #0 0x10f6dd4ad in _ZdlPv (/usr/local/Cellar/llvm/17.0.6_1/lib/clang/17/lib/darwin/libclang_rt.asan_osx_dynamic.dylib:x86_64h+0xf14ad)&#13;
    #1 0x10eb5162e in add_to_vec(std::__1::vector&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;, std::__1::allocator&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&gt;&gt;&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt; const&amp;) (/Users/weixuan/code/ccode/singleton/_build/singleton:x86_64+0x10004162e)&#13;
    #2 0x10eb52fab in void* std::__1::__thread_proxy[abi:ue170006]&lt;std::__1::tuple&lt;std::__1::unique_ptr&lt;std::__1::__thread_struct, std::__1::default_delete&lt;std::__1::__thread_struct&gt;&gt;, void (*)(std::__1::vector&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;, std::__1::allocator&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&gt;&gt;&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt; const&amp;), std::__1::reference_wrapper&lt;std::__1::vector&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;, std::__1::allocator&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&gt;&gt;&gt;, std::__1::reference_wrapper&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt; const&gt;&gt;&gt;(void*) (/Users/weixuan/code/ccode/singleton/_build/singleton:x86_64+0x100042fab)&#13;
    #3 0x10f6c59dd in asan_thread_start(void*) (/usr/local/Cellar/llvm/17.0.6_1/lib/clang/17/lib/darwin/libclang_rt.asan_osx_dynamic.dylib:x86_64h+0xd99dd)&#13;
    #4 0x7ff819cf818a in _pthread_start (/usr/lib/system/libsystem_pthread.dylib:x86_64+0x618a)&#13;
    #5 0x7ff819cf3ae2 in thread_start (/usr/lib/system/libsystem_pthread.dylib:x86_64+0x1ae2)&#13;
&#13;
0x603000003058 is located 40 bytes after 32-byte region [0x603000003010,0x603000003030)&#13;
freed by thread T0 here:&#13;
    #0 0x10f6dd4ad in _ZdlPv (/usr/local/Cellar/llvm/17.0.6_1/lib/clang/17/lib/darwin/libclang_rt.asan_osx_dynamic.dylib:x86_64h+0xf14ad)&#13;
    #1 0x10eb4e399 in tf::Executor::~Executor() (/Users/weixuan/code/ccode/singleton/_build/singleton:x86_64+0x10003e399)&#13;
    #2 0x10eb142b9 in test_task_flow() (/Users/weixuan/code/ccode/singleton/_build/singleton:x86_64+0x1000042b9)&#13;
    #3 0x10eb17228 in taskflow_dag_Test::TestBody() (/Users/weixuan/code/ccode/singleton/_build/singleton:x86_64+0x100007228)&#13;
    #4 0x10eba18ea in void testing::internal::HandleExceptionsInMethodIfSupported&lt;testing::Test, void&gt;(testing::Test*, void (testing::Test::*)(), char const*) (/Users/weixuan/code/ccode/singleton/_build/singleton:x86_64+0x1000918ea)&#13;
    #5 0x10eba183f in testing::Test::Run() (/Users/weixuan/code/ccode/singleton/_build/singleton:x86_64+0x10009183f)&#13;
    #6 0x10eba2b9f in testing::TestInfo::Run() (/Users/weixuan/code/ccode/singleton/_build/singleton:x86_64+0x100092b9f)&#13;
    #7 0x10eba3bc6 in testing::TestSuite::Run() (/Users/weixuan/code/ccode/singleton/_build/singleton:x86_64+0x100093bc6)&#13;
    #8 0x10ebb40ed in testing::internal::UnitTestImpl::RunAllTests() (/Users/weixuan/code/ccode/singleton/_build/singleton:x86_64+0x1000a40ed)&#13;
    #9 0x10ebb391a in bool testing::internal::HandleExceptionsInMethodIfSupported&lt;testing::internal::UnitTestImpl, bool&gt;(testing::internal::UnitTestImpl*, bool (testing::internal::UnitTestImpl::*)(), char const*) (/Users/weixuan/code/ccode/singleton/_build/singleton:x86_64+0x1000a391a)&#13;
    #10 0x10ebb389c in testing::UnitTest::Run() (/Users/weixuan/code/ccode/singleton/_build/singleton:x86_64+0x1000a389c)&#13;
    #11 0x10eb57c2f in main (/Users/weixuan/code/ccode/singleton/_build/singleton:x86_64+0x100047c2f)&#13;
    #12 0x7ff81996c365  (/usr/lib/dyld:x86_64+0xfffffffffff5c365)&#13;
&#13;
previously allocated by thread T1 here:&#13;
    #0 0x10f6dd08d in _Znwm (/usr/local/Cellar/llvm/17.0.6_1/lib/clang/17/lib/darwin/libclang_rt.asan_osx_dynamic.dylib:x86_64h+0xf108d)&#13;
    #1 0x10eb1efc9 in std::__1::pair&lt;std::__1::__hash_iterator&lt;std::__1::__hash_node&lt;std::__1::__hash_value_type&lt;std::__1::__thread_id, unsigned long&gt;, void*&gt;*&gt;, bool&gt; std::__1::__hash_table&lt;std::__1::__hash_value_type&lt;std::__1::__thread_id, unsigned long&gt;, std::__1::__unordered_map_hasher&lt;std::__1::__thread_id, std::__1::__hash_value_type&lt;std::__1::__thread_id, unsigned long&gt;, std::__1::hash&lt;std::__1::__thread_id&gt;, std::__1::equal_to&lt;std::__1::__thread_id&gt;, true&gt;, std::__1::__unordered_map_equal&lt;std::__1::__thread_id, std::__1::__hash_value_type&lt;std::__1::__thread_id, unsigned long&gt;, std::__1::equal_to&lt;std::__1::__thread_id&gt;, std::__1::hash&lt;std::__1::__thread_id&gt;, true&gt;, std::__1::allocator&lt;std::__1::__hash_value_type&lt;std::__1::__thread_id, unsigned long&gt;&gt;&gt;::__emplace_unique_key_args&lt;std::__1::__thread_id, std::__1::piecewise_construct_t const&amp;, std::__1::tuple&lt;std::__1::__thread_id&amp;&amp;&gt;, std::__1::tuple&lt;&gt;&gt;(std::__1::__thread_id const&amp;, std::__1::piecewise_construct_t const&amp;, std::__1::tuple&lt;std::__1::__thread_id&amp;&amp;&gt;&amp;&amp;, std::__1::tuple&lt;&gt;&amp;&amp;) (/Users/weixuan/code/ccode/singleton/_build/singleton:x86_64+0x10000efc9)&#13;
    #2 0x10eb1dfa2 in tf::Executor::_spawn(unsigned long)::'lambda'(tf::Worker&amp;, std::__1::mutex&amp;, std::__1::condition_variable&amp;, unsigned long&amp;)::operator()(tf::Worker&amp;, std::__1::mutex&amp;, std::__1::condition_variable&amp;, unsigned long&amp;) const (/Users/weixuan/code/ccode/singleton/_build/singleton:x86_64+0x10000dfa2)&#13;
    #3 0x10eb1db2c in void* std::__1::__thread_proxy[abi:ue170006]&lt;std::__1::tuple&lt;std::__1::unique_ptr&lt;std::__1::__thread_struct, std::__1::default_delete&lt;std::__1::__thread_struct&gt;&gt;, tf::Executor::_spawn(unsigned long)::'lambda'(tf::Worker&amp;, std::__1::mutex&amp;, std::__1::condition_variable&amp;, unsigned long&amp;), std::__1::reference_wrapper&lt;tf::Worker&gt;, std::__1::reference_wrapper&lt;std::__1::mutex&gt;, std::__1::reference_wrapper&lt;std::__1::condition_variable&gt;, std::__1::reference_wrapper&lt;unsigned long&gt;&gt;&gt;(void*) (/Users/weixuan/code/ccode/singleton/_build/singleton:x86_64+0x10000db2c)&#13;
    #4 0x10f6c59dd in asan_thread_start(void*) (/usr/local/Cellar/llvm/17.0.6_1/lib/clang/17/lib/darwin/libclang_rt.asan_osx_dynamic.dylib:x86_64h+0xd99dd)&#13;
    #5 0x7ff819cf818a in _pthread_start (/usr/lib/system/libsystem_pthread.dylib:x86_64+0x618a)&#13;
    #6 0x7ff819cf3ae2 in thread_start (/usr/lib/system/libsystem_pthread.dylib:x86_64+0x1ae2)&#13;
```&#13;
&#13;
&#13;
# `sanitier`&#13;
&#13;
| sanitizer   | å®˜æ–¹åœ°å€                                                    | å¼€å¯æ–¹å¼                | è¯´æ˜             |&#13;
| ----------- | ----------------------------------------------------------- | ----------------------- | ---------------- |&#13;
| `thread`    | https://clang.llvm.org/docs/ThreadSanitizer.html.           | `-fsanitize=thread`     | æ£€æµ‹datarace     |&#13;
| `address`   | https://clang.llvm.org/docs/AddressSanitizer.html           | `-fsanitize=address`    | å†…å­˜é”™è¯¯         |&#13;
| `memory`    | https://clang.llvm.org/docs/MemorySanitizer.html            | `-fsanitize=memory`     | æ£€æµ‹æœªåˆå§‹åŒ–è¯»å– |&#13;
| `undefined` | https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html | ` -fsanitize=undefined` | æ£€æµ‹ä¸ºå®šä¹‰è¡Œä¸º   |&#13;
&#13;
ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/21.html</guid><pubDate>Sun, 24 Mar 2024 07:40:15 +0000</pubDate></item><item><title>the rule of five</title><link>https://0x1042.github.io//post/20.html</link><description>&#13;
- [å®šä¹‰](#å®šä¹‰)&#13;
- [`copy constructor`](#copy-constructor)&#13;
  - [é—®é¢˜](#é—®é¢˜)&#13;
  - [è§£å†³æ–¹æ¡ˆ](#è§£å†³æ–¹æ¡ˆ)&#13;
- [`operator=`](#operator)&#13;
  - [é—®é¢˜](#é—®é¢˜-1)&#13;
  - [è§£å†³æ–¹æ¡ˆ](#è§£å†³æ–¹æ¡ˆ-1)&#13;
- [`move constructor`](#move-constructor)&#13;
  - [é—®é¢˜](#é—®é¢˜-2)&#13;
  - [è§£å†³æ–¹æ¡ˆ](#è§£å†³æ–¹æ¡ˆ-2)&#13;
- [`move operator`](#move-operator)&#13;
  - [é—®é¢˜](#é—®é¢˜-3)&#13;
  - [è§£å†³æ–¹æ¡ˆ](#è§£å†³æ–¹æ¡ˆ-3)&#13;
&#13;
# å®šä¹‰ &#13;
&#13;
```cpp&#13;
class SString {&#13;
public:&#13;
    explicit SString(const char * cp);&#13;
&#13;
    virtual ~SString();&#13;
&#13;
private:&#13;
    char * data_;&#13;
};&#13;
&#13;
// impl &#13;
// ç¡®ä¿é•¿åº¦&#13;
SString::SString(const char * cp) : data_(new char[strlen(cp) + 1]) {&#13;
    strcpy(data_, cp);&#13;
}&#13;
&#13;
SString::~SString() {&#13;
    delete[] data_;&#13;
}&#13;
```&#13;
&#13;
&gt; the rule of five &#13;
&gt; - Destructor&#13;
&gt; - Copy Constructor&#13;
&gt; - Copy Assignment Operator&#13;
&gt; - Move Constructor&#13;
&gt; - Move Assignment Operator&#13;
&#13;
&#13;
# `copy constructor`&#13;
&#13;
&gt; è€ƒè™‘ä¸€ä¸‹ä½¿ç”¨æ–¹å¼ ï¼Œè¿™ä¸ªä»£ç æœ‰ä¸¤ä¸ªé—®é¢˜ &#13;
&#13;
```cpp&#13;
&#13;
void foo(rof::SString val) {&#13;
    spdlog::info('size is {}', val.size());&#13;
}&#13;
&#13;
TEST_CASE('case1', 'copy') {&#13;
    rof::SString s{'hello world'};&#13;
    { foo(s); }&#13;
    { foo(s); }&#13;
}&#13;
```&#13;
&#13;
```&#13;
==23702==ERROR: AddressSanitizer: heap-use-after-free on address 0x6020000037f0 at pc 0x000104cd721d bp 0x7ff7bc0ea590 sp 0x7ff7bc0e9d58&#13;
READ of size 3 at 0x6020000037f0 thread T0&#13;
    #0 0x104cd721c in strlen+0x80c (libclang_rt.asan_osx_dynamic.dylib:x86_64h+0x1b21c)&#13;
    #1 0x103fc4869 in tests::foo(rof::SString)+0x181 (c20:x86_64+0x1001b1869)&#13;
    #2 0x103fc4c64 in tests::CATCH2_INTERNAL_TEST_0()+0x2fc (c20:x86_64+0x1001b1c64)&#13;
    #3 0x103eadd03 in Catch::RunContext::runCurrentTest(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&amp;)+0x203 (c20:x86_64+0x10009ad03)&#13;
    #4 0x103ead79a in Catch::RunContext::runTest(Catch::TestCaseHandle const&amp;)+0x1ea (c20:x86_64+0x10009a79a)&#13;
    #5 0x103e8f870 in Catch::Session::runInternal()+0xe20 (c20:x86_64+0x10007c870)&#13;
    #6 0x103e8e9e4 in Catch::Session::run()+0x44 (c20:x86_64+0x10007b9e4)&#13;
    #7 0x103f6702c in main+0x624 (c20:x86_64+0x10015402c)&#13;
    #8 0x7ff811187365 in start+0x795 (dyld:x86_64+0xfffffffffff5c365)&#13;
&#13;
0x6020000037f0 is located 0 bytes inside of 12-byte region [0x6020000037f0,0x6020000037fc)&#13;
freed by thread T0 here:&#13;
    #0 0x104dad5ad in _ZdaPv+0x7d (libclang_rt.asan_osx_dynamic.dylib:x86_64h+0xf15ad)&#13;
    #1 0x103fc4bfc in tests::CATCH2_INTERNAL_TEST_0()+0x294 (c20:x86_64+0x1001b1bfc)&#13;
    #2 0x103eadd03 in Catch::RunContext::runCurrentTest(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&amp;)+0x203 (c20:x86_64+0x10009ad03)&#13;
    #3 0x103ead79a in Catch::RunContext::runTest(Catch::TestCaseHandle const&amp;)+0x1ea (c20:x86_64+0x10009a79a)&#13;
    #4 0x103e8f870 in Catch::Session::runInternal()+0xe20 (c20:x86_64+0x10007c870)&#13;
    #5 0x103e8e9e4 in Catch::Session::run()+0x44 (c20:x86_64+0x10007b9e4)&#13;
    #6 0x103f6702c in main+0x624 (c20:x86_64+0x10015402c)&#13;
    #7 0x7ff811187365 in start+0x795 (dyld:x86_64+0xfffffffffff5c365)&#13;
&#13;
previously allocated by thread T0 here:&#13;
    #0 0x104dad19d in _Znam+0x7d (libclang_rt.asan_osx_dynamic.dylib:x86_64h+0xf119d)&#13;
    #1 0x103fc4a6d in tests::CATCH2_INTERNAL_TEST_0()+0x105 (c20:x86_64+0x1001b1a6d)&#13;
    #2 0x103eadd03 in Catch::RunContext::runCurrentTest(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&amp;)+0x203 (c20:x86_64+0x10009ad03)&#13;
    #3 0x103ead79a in Catch::RunContext::runTest(Catch::TestCaseHandle const&amp;)+0x1ea (c20:x86_64+0x10009a79a)&#13;
    #4 0x103e8f870 in Catch::Session::runInternal()+0xe20 (c20:x86_64+0x10007c870)&#13;
    #5 0x103e8e9e4 in Catch::Session::run()+0x44 (c20:x86_64+0x10007b9e4)&#13;
    #6 0x103f6702c in main+0x624 (c20:x86_64+0x10015402c)&#13;
    #7 0x7ff811187365 in start+0x795 (dyld:x86_64+0xfffffffffff5c365)&#13;
&#13;
SUMMARY: AddressSanitizer: heap-use-after-free (libclang_rt.asan_osx_dynamic.dylib:x86_64h+0x1b21c) in strlen+0x80c&#13;
```&#13;
&#13;
## é—®é¢˜&#13;
1. use after free&#13;
2. double free &#13;
&#13;
## è§£å†³æ–¹æ¡ˆ &#13;
&gt; å®ç°copy constructorï¼Œé¿å…ä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘ä¸€å—å†…å­˜åœ°å€&#13;
&#13;
```cpp &#13;
&#13;
SString(const SString &amp; other);&#13;
&#13;
// impl&#13;
SString::SString(const SString &amp; other) : data_(new char[strlen(other.data_) + 1]) {&#13;
    strcpy(data_, other.data_);&#13;
}&#13;
&#13;
```&#13;
&#13;
# `operator=`&#13;
&#13;
&gt; è€ƒè™‘ä¸€ä¸‹ä½¿ç”¨æ–¹å¼&#13;
&#13;
```cpp&#13;
TEST_CASE('sstring2', 'operator') {&#13;
    rof::SString hello{'hello'};&#13;
    rof::SString world{'world'};&#13;
&#13;
    world = hello;&#13;
}&#13;
```&#13;
&#13;
```&#13;
==24524==ERROR: AddressSanitizer: attempting double-free on 0x602000003830 in thread T0:&#13;
    #0 0x1061ad5ad in _ZdaPv+0x7d (libclang_rt.asan_osx_dynamic.dylib:x86_64h+0xf15ad)&#13;
    #1 0x105424859 in tests::CATCH2_INTERNAL_TEST_2()+0x2b1 (c20:x86_64+0x1001b1859)&#13;
    #2 0x10530d303 in Catch::RunContext::runCurrentTest(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&amp;)+0x203 (c20:x86_64+0x10009a303)&#13;
    #3 0x10530cd9a in Catch::RunContext::runTest(Catch::TestCaseHandle const&amp;)+0x1ea (c20:x86_64+0x100099d9a)&#13;
    #4 0x1052eee70 in Catch::Session::runInternal()+0xe20 (c20:x86_64+0x10007be70)&#13;
    #5 0x1052edfe4 in Catch::Session::run()+0x44 (c20:x86_64+0x10007afe4)&#13;
    #6 0x1053c662c in main+0x624 (c20:x86_64+0x10015362c)&#13;
    #7 0x7ff811187365 in start+0x795 (dyld:x86_64+0xfffffffffff5c365)&#13;
&#13;
0x602000003830 is located 0 bytes inside of 6-byte region [0x602000003830,0x602000003836)&#13;
freed by thread T0 here:&#13;
    #0 0x1061ad5ad in _ZdaPv+0x7d (libclang_rt.asan_osx_dynamic.dylib:x86_64h+0xf15ad)&#13;
    #1 0x1054247f2 in tests::CATCH2_INTERNAL_TEST_2()+0x24a (c20:x86_64+0x1001b17f2)&#13;
    #2 0x10530d303 in Catch::RunContext::runCurrentTest(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&amp;)+0x203 (c20:x86_64+0x10009a303)&#13;
    #3 0x10530cd9a in Catch::RunContext::runTest(Catch::TestCaseHandle const&amp;)+0x1ea (c20:x86_64+0x100099d9a)&#13;
    #4 0x1052eee70 in Catch::Session::runInternal()+0xe20 (c20:x86_64+0x10007be70)&#13;
    #5 0x1052edfe4 in Catch::Session::run()+0x44 (c20:x86_64+0x10007afe4)&#13;
    #6 0x1053c662c in main+0x624 (c20:x86_64+0x10015362c)&#13;
    #7 0x7ff811187365 in start+0x795 (dyld:x86_64+0xfffffffffff5c365)&#13;
&#13;
previously allocated by thread T0 here:&#13;
    #0 0x1061ad19d in _Znam+0x7d (libclang_rt.asan_osx_dynamic.dylib:x86_64h+0xf119d)&#13;
    #1 0x105423d2f in rof::SString::SString(char const*)+0x4f (c20:x86_64+0x1001b0d2f)&#13;
    #2 0x10542467a in tests::CATCH2_INTERNAL_TEST_2()+0xd2 (c20:x86_64+0x1001b167a)&#13;
    #3 0x10530d303 in Catch::RunContext::runCurrentTest(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt;&amp;)+0x203 (c20:x86_64+0x10009a303)&#13;
    #4 0x10530cd9a in Catch::RunContext::runTest(Catch::TestCaseHandle const&amp;)+0x1ea (c20:x86_64+0x100099d9a)&#13;
    #5 0x1052eee70 in Catch::Session::runInternal()+0xe20 (c20:x86_64+0x10007be70)&#13;
    #6 0x1052edfe4 in Catch::Session::run()+0x44 (c20:x86_64+0x10007afe4)&#13;
    #7 0x1053c662c in main+0x624 (c20:x86_64+0x10015362c)&#13;
    #8 0x7ff811187365 in start+0x795 (dyld:x86_64+0xfffffffffff5c365)&#13;
&#13;
SUMMARY: AddressSanitizer: double-free (libclang_rt.asan_osx_dynamic.dylib:x86_64h+0xf15ad) in _ZdaPv+0x7d&#13;
```&#13;
&#13;
## é—®é¢˜ &#13;
- double free&#13;
&#13;
&gt; èµ‹å€¼ä¹‹åï¼Œworld å’Œ hello çš„æŒ‡é’ˆéƒ½æŒ‡å‘äº† helloçš„æŒ‡é’ˆçš„å†…å­˜åœ°å€&#13;
&gt; ææ„çš„æ—¶å€™ï¼Œä¼šææ„ä¸¤æ¬¡&#13;
 &#13;
## è§£å†³æ–¹æ¡ˆ &#13;
&#13;
&gt; å®ç°è‡ªå®šä¹‰çš„ operator= (copy assignment operator)&#13;
&#13;
```cpp&#13;
&#13;
auto operator=(const SString &amp; other) -&gt; SString &amp;;&#13;
&#13;
auto SString::operator=(const SString &amp; other) -&gt; SString &amp; {&#13;
    // bugprone-unhandled-self-assignment&#13;
    if (this == &amp;other) {&#13;
        return *this;&#13;
    }&#13;
&#13;
    char * newdata = new char[strlen(other.data_) + 1];&#13;
    strcpy(newdata, other.data_);&#13;
    std::swap(newdata, this-&gt;data_);&#13;
    delete[] newdata;&#13;
    return *this;&#13;
}&#13;
```&#13;
&#13;
# `move constructor`&#13;
&#13;
&gt; ç”¨æ³• &#13;
&#13;
```cpp &#13;
TEST_CASE('sstring3', 'move1') {&#13;
    rof::SString hello{'hello'};&#13;
&#13;
    foo(std::move(hello));&#13;
}&#13;
```&#13;
&#13;
## é—®é¢˜&#13;
&#13;
```&#13;
Passing result of std::move() as a const reference argument; no move will actually happen (fix available)clang-tidyperformance-move-const-arg&#13;
ruleoffive.h(6, 7): 'SString' is not move assignable/constructible&#13;
```&#13;
&#13;
## è§£å†³æ–¹æ¡ˆ&#13;
&#13;
```cpp&#13;
SString(SString &amp;&amp; other) noexcept;&#13;
&#13;
// impl&#13;
SString::SString(SString &amp;&amp; other) noexcept : data_(other.data_) {&#13;
    other.data_ = nullptr;&#13;
}&#13;
```&#13;
&#13;
# `move operator` &#13;
&#13;
&gt; ç”¨æ³• &#13;
&#13;
```cpp &#13;
TEST_CASE('sstring4', 'move2') {&#13;
    rof::SString hello{'hello'};&#13;
    rof::SString world{'world'};&#13;
&#13;
    world = std::move(hello);&#13;
}&#13;
```&#13;
&#13;
## é—®é¢˜&#13;
&#13;
```&#13;
no move will actually happen (fix available)clang-tidyperformance-move-const-arg&#13;
ruleoffive.h(6, 7): 'SString' is not move assignable&#13;
```&#13;
&#13;
## è§£å†³æ–¹æ¡ˆ&#13;
&#13;
```cpp&#13;
auto operator=(SString &amp;&amp; other) noexcept -&gt; SString &amp;;&#13;
&#13;
auto SString::operator=(SString &amp;&amp; other) noexcept -&gt; SString &amp; {&#13;
    delete[] data_;&#13;
    data_ = other.data_;&#13;
    other.data_ = nullptr;&#13;
    return *this;&#13;
}&#13;
```ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/20.html</guid><pubDate>Tue, 19 Mar 2024 08:05:32 +0000</pubDate></item><item><title>proc_macro_derive hello world</title><link>https://0x1042.github.io//post/19.html</link><description>- [builder](#builder)&#13;
  - [cargo.toml](#cargotoml)&#13;
  - [struct](#struct)&#13;
  - [lib.rs](#librs)&#13;
  - [éªŒè¯ç»“æœ](#éªŒè¯ç»“æœ)&#13;
&#13;
# builder &#13;
&#13;
&gt; ç»™å®š `struct` ç”Ÿæˆ`builder`ç›¸å…³çš„ç»“æ„&#13;
&#13;
## cargo.toml&#13;
&#13;
```toml&#13;
[package]&#13;
name = 'builder'&#13;
version = '0.1.0'&#13;
edition = '2021'&#13;
&#13;
[lib]&#13;
proc-macro = true&#13;
&#13;
[dependencies]&#13;
proc-macro2 = '1.0'&#13;
quote = '1.0'&#13;
syn = { version = '2.0', features = ['full'] }&#13;
```&#13;
&#13;
## struct&#13;
&#13;
```rust&#13;
#[derive(builder::Builder)]&#13;
pub struct Ad {&#13;
	id: u64,&#13;
	cids: Vec&lt;u64&gt;,&#13;
	title: String,&#13;
	bid: f32,&#13;
}&#13;
```&#13;
&#13;
## lib.rs&#13;
&#13;
- `quote!`: å°†`Rust`ä»£ç è½¬æ¢ä¸º`TokenStream`&#13;
- `parse_macro_input!` è¾“å…¥çš„ `TokenStream` è§£ææˆ `Rust` ä»£ç çš„æ•°æ®ç»“æ„&#13;
&#13;
&#13;
```rust&#13;
#[proc_macro_derive(Builder)]&#13;
pub fn derive(input: proc_macro::TokenStream) -&gt; proc_macro::TokenStream {&#13;
    let ast = syn::parse_macro_input!(input as syn::DeriveInput);&#13;
&#13;
    let ident = ast.ident;&#13;
&#13;
    let builder_ident = quote::format_ident!('{ident}Builder');&#13;
&#13;
    // è·å–æ‰€æœ‰çš„field &#13;
    let fields = match ast.data.clone() {&#13;
        syn::Data::Struct(data) =&gt; data.fields,&#13;
        _ =&gt; panic!('only support struct'),&#13;
    };&#13;
&#13;
    // å®šä¹‰builder çš„å­—æ®µ&#13;
    // id: std::option::Option&lt;u64&gt;&#13;
    let builder_fields = fields.iter().map(|field| {&#13;
        let field = field.clone();&#13;
        let id = field.ident.unwrap();&#13;
        let ty = field.ty;&#13;
&#13;
        quote::quote! {&#13;
            #id: std::option::Option&lt;#ty&gt;&#13;
        }&#13;
    });&#13;
&#13;
    // åˆå§‹åŒ–ä¸ºNone &#13;
    // id: std::option::Option::None &#13;
    let builder_defaults = fields.iter().map(|field| {&#13;
        let field = field.clone();&#13;
        let id = field.ident.unwrap();&#13;
&#13;
        quote::quote! { #id: std::option::Option::None }&#13;
    });&#13;
&#13;
    // å®šä¹‰setter å‡½æ•°&#13;
    //     pub fn id(&amp;mut self, value: u64) -&gt; &amp;mut Self {&#13;
    //     self.id = std::option::Option::Some(value);&#13;
    //     self&#13;
    // }&#13;
    let setters = fields.iter().map(|field| {&#13;
        let field = field.clone();&#13;
        let ty = field.ty;&#13;
        let id = field.ident.unwrap();&#13;
&#13;
        quote::quote! {&#13;
            pub fn #id(&amp;mut self,value:#ty) -&gt; &amp;mut Self {&#13;
                self.#id = std::option::Option::Some(value);&#13;
                self&#13;
            }&#13;
        }&#13;
    });&#13;
&#13;
    // å­—æ®µèµ‹å€¼&#13;
    //  id: self.id.clone().unwrap()&#13;
    let build_fields = fields.iter().map(|field| {&#13;
        let field = field.clone();&#13;
        let id = field.ident.unwrap();&#13;
&#13;
        quote::quote! {&#13;
            #id: self.#id.clone().unwrap()&#13;
        }&#13;
    });&#13;
&#13;
    let output = quote::quote! {&#13;
        // å®šä¹‰builder struct &#13;
        pub struct #builder_ident {&#13;
            #(#builder_fields),*&#13;
        }&#13;
&#13;
        impl #builder_ident {&#13;
            #(#setters)*&#13;
        }&#13;
&#13;
        impl #builder_ident {&#13;
            pub fn build(&amp;mut self) -&gt; std::result::Result&lt;#ident, std::boxed::Box&lt;dyn std::error::Error&gt;&gt; {&#13;
                std::result::Result::Ok(#ident {&#13;
                    #(#build_fields),*&#13;
                })&#13;
            }&#13;
&#13;
        }&#13;
&#13;
        impl #ident {&#13;
            pub fn builder() -&gt; #builder_ident {&#13;
                #builder_ident {&#13;
                    #(#builder_defaults),*&#13;
                }&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    proc_macro::TokenStream::from(output)&#13;
}&#13;
```&#13;
&#13;
## éªŒè¯ç»“æœ &#13;
&#13;
```rust&#13;
&#13;
#[derive(builder::Builder)]&#13;
pub struct Ad {&#13;
    id: u64,&#13;
    cids: Vec&lt;u64&gt;,&#13;
    title: String,&#13;
    bid: f32,&#13;
}&#13;
&#13;
fn main() {&#13;
    let mut builder = Ad::builder();&#13;
&#13;
    let ad = builder&#13;
        .bid(1.23)&#13;
        .id(193987829387)&#13;
        .cids(vec![1, 2, 3])&#13;
        .title('æ¨å¹¿'.to_string())&#13;
        .build();&#13;
}&#13;
```&#13;
&#13;
&gt; cargo expand &#13;
&#13;
```rust&#13;
#![feature(prelude_import)]&#13;
#[prelude_import]&#13;
use std::prelude::rust_2021::*;&#13;
#[macro_use]&#13;
extern crate std;&#13;
pub struct Ad {&#13;
    id: u64,&#13;
    cids: Vec&lt;u64&gt;,&#13;
    title: String,&#13;
    bid: f32,&#13;
}&#13;
pub struct AdBuilder {&#13;
    id: std::option::Option&lt;u64&gt;,&#13;
    cids: std::option::Option&lt;Vec&lt;u64&gt;&gt;,&#13;
    title: std::option::Option&lt;String&gt;,&#13;
    bid: std::option::Option&lt;f32&gt;,&#13;
}&#13;
impl AdBuilder {&#13;
    pub fn id(&amp;mut self, value: u64) -&gt; &amp;mut Self {&#13;
        self.id = std::option::Option::Some(value);&#13;
        self&#13;
    }&#13;
    pub fn cids(&amp;mut self, value: Vec&lt;u64&gt;) -&gt; &amp;mut Self {&#13;
        self.cids = std::option::Option::Some(value);&#13;
        self&#13;
    }&#13;
    pub fn title(&amp;mut self, value: String) -&gt; &amp;mut Self {&#13;
        self.title = std::option::Option::Some(value);&#13;
        self&#13;
    }&#13;
    pub fn bid(&amp;mut self, value: f32) -&gt; &amp;mut Self {&#13;
        self.bid = std::option::Option::Some(value);&#13;
        self&#13;
    }&#13;
}&#13;
impl AdBuilder {&#13;
    pub fn build(&#13;
        &amp;mut self,&#13;
    ) -&gt; std::result::Result&lt;Ad, std::boxed::Box&lt;dyn std::error::Error&gt;&gt; {&#13;
        std::result::Result::Ok(Ad {&#13;
            id: self.id.clone().unwrap(),&#13;
            cids: self.cids.clone().unwrap(),&#13;
            title: self.title.clone().unwrap(),&#13;
            bid: self.bid.clone().unwrap(),&#13;
        })&#13;
    }&#13;
}&#13;
impl Ad {&#13;
    pub fn builder() -&gt; AdBuilder {&#13;
        AdBuilder {&#13;
            id: std::option::Option::None,&#13;
            cids: std::option::Option::None,&#13;
            title: std::option::Option::None,&#13;
            bid: std::option::Option::None,&#13;
        }&#13;
    }&#13;
}&#13;
fn main() {&#13;
    let mut builder = Ad::builder();&#13;
    let ad = builder&#13;
        .bid(1.23)&#13;
        .id(193987829387)&#13;
        .cids(&lt;[_]&gt;::into_vec(#[rustc_box] ::alloc::boxed::Box::new([1, 2, 3])))&#13;
        .title('æ¨å¹¿'.to_string())&#13;
        .build();&#13;
}&#13;
```ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/19.html</guid><pubDate>Mon, 19 Feb 2024 16:19:05 +0000</pubDate></item><item><title>macroåŸºæœ¬ä½¿ç”¨</title><link>https://0x1042.github.io//post/18.html</link><description># macro&#13;
&#13;
- [macro](#macro)&#13;
  - [å­—ç¬¦ä¸²åŒ–](#å­—ç¬¦ä¸²åŒ–)&#13;
  - [è¿æ¥](#è¿æ¥)&#13;
  - [å˜å‚å®](#å˜å‚å®)&#13;
  - [æ¡ä»¶ç¼–è¯‘](#æ¡ä»¶ç¼–è¯‘)&#13;
- [macro vs function](#macro-vs-function)&#13;
  - [å®ä¼˜ç‚¹](#å®ä¼˜ç‚¹)&#13;
  - [å®ç¼ºç‚¹](#å®ç¼ºç‚¹)&#13;
&#13;
&#13;
&gt; ä¸€èˆ¬æˆ‘ä»¬åœ¨CRä¸­ä¸å»ºè®®å®ï¼Œå› ä¸ºæ— æ³•åšåˆ°ç±»å‹å®‰å…¨ä»¥åŠå¯è¯»æ€§ä¸Šæ¯”è¾ƒå·®&#13;
&gt; ä½†æ˜¯åœ¨ä¸€äº›ä¸šåŠ¡æ— å…³çš„ä»£ç ä¸Šï¼Œæ¯”å¦‚é…ç½®è§£æï¼Œå¯ä»¥æœ‰æ•ˆå‡å°‘é‡å¤ä»£ç  &#13;
&gt; ä¸‹é¢æ”¶é›†ä¸€äº›å®çš„å¸¸è§ä½¿ç”¨ &#13;
&#13;
## å­—ç¬¦ä¸²åŒ–&#13;
&#13;
&gt; ç®€å•è¯´å°±æ˜¯åœ¨ç¬¦å·çš„å‰ååŠ ä¸ŠåŒå¼•å·ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/18.html</guid><pubDate>Sat, 06 Jan 2024 07:38:15 +0000</pubDate></item><item><title>ml æ‰«ç›²äºŒ</title><link>https://0x1042.github.io//post/17.html</link><description># MLæ‰«ç›²äºŒ&#13;
&#13;
- [MLæ‰«ç›²äºŒ](#mlæ‰«ç›²äºŒ)&#13;
- [ç¯å¢ƒæ­å»º](#ç¯å¢ƒæ­å»º)&#13;
- [æœºå™¨å­¦ä¹ çš„åˆ†ç±»](#æœºå™¨å­¦ä¹ çš„åˆ†ç±»)&#13;
  - [ç›‘ç£å­¦ä¹   `supervised learning`](#ç›‘ç£å­¦ä¹ --supervised-learning)&#13;
  - [æ— ç›‘ç£å­¦ä¹  `unsupervised learning`](#æ— ç›‘ç£å­¦ä¹ -unsupervised-learning)&#13;
  - [åŠç›‘ç£å­¦ä¹  `semi-supervised learning`](#åŠç›‘ç£å­¦ä¹ -semi-supervised-learning)&#13;
  - [å¼ºåŒ–å­¦ä¹  `reinforcement learning`](#å¼ºåŒ–å­¦ä¹ -reinforcement-learning)&#13;
- [å›å½’  regression](#å›å½’--regression)&#13;
- [çº¿æ€§å›å½’ linear regression](#çº¿æ€§å›å½’-linear-regression)&#13;
  - [ä»€ä¹ˆæ˜¯çº¿æ€§å›å½’](#ä»€ä¹ˆæ˜¯çº¿æ€§å›å½’)&#13;
  - [æŸå¤±å‡½æ•° loss function](#æŸå¤±å‡½æ•°-loss-function)&#13;
  - [éšæœºæ¢¯åº¦ä¸‹é™](#éšæœºæ¢¯åº¦ä¸‹é™)&#13;
  - [from zero](#from-zero)&#13;
  - [use tf](#use-tf)&#13;
- [éçº¿æ€§å›å½’ Non-linear Regression](#éçº¿æ€§å›å½’-non-linear-regression)&#13;
- [é€»è¾‘å›å½’ logistic regression](#é€»è¾‘å›å½’-logistic-regression)&#13;
  - [åˆ†ç±»é—®é¢˜](#åˆ†ç±»é—®é¢˜)&#13;
  - [ç½‘ç»œç»“æ„](#ç½‘ç»œç»“æ„)&#13;
  - [æŸå¤±å‡½æ•°](#æŸå¤±å‡½æ•°)&#13;
  - [use tf](#use-tf-1)&#13;
- [å­¦ä¹ èµ„æ–™](#å­¦ä¹ èµ„æ–™)&#13;
&#13;
#  ç¯å¢ƒæ­å»º &#13;
&#13;
```shell&#13;
&#13;
# å¼€å‘æœºå¯åŠ¨jupyter notebook &#13;
&#13;
nohup jupyter notebook --no-browser --port=8889 &amp;&#13;
&#13;
# æœ¬åœ°ç«¯å£è½¬å‘ &#13;
ssh -N -f -L localhost:8888:localhost:8889 ubuntu&#13;
```&#13;
&#13;
# æœºå™¨å­¦ä¹ çš„åˆ†ç±»&#13;
&#13;
## ç›‘ç£å­¦ä¹   `supervised learning`&#13;
&#13;
&gt; **è®­ç»ƒæ•°æ®åŒ…å«æ­£ç¡®çš„ç»“æœï¼ˆlabelï¼‰ï¼Œå³å¸Œæœ›å­¦ä¹ æˆ–è€…é¢„ä¼°çš„ç›®æ ‡.**&#13;
&#13;
- ç›‘ç£å­¦ä¹ å»ºç«‹ä¸€ä¸ªå­¦ä¹ è¿‡ç¨‹ï¼Œå°†é¢„æµ‹ç»“æœä¸ â€œè®­ç»ƒæ•°æ®â€ï¼ˆå³è¾“å…¥æ•°æ®ï¼‰çš„å®é™…ç»“æœè¿›è¡Œæ¯”è¾ƒï¼Œä¸æ–­çš„è°ƒæ•´é¢„æµ‹æ¨¡å‹ï¼Œç›´åˆ°æ¨¡å‹çš„é¢„æµ‹ç»“æœè¾¾åˆ°ä¸€ä¸ªé¢„æœŸçš„å‡†ç¡®ç‡ï¼Œæ¯”å¦‚åˆ†ç±»å’Œå›å½’é—®é¢˜ç­‰ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/17.html</guid><pubDate>Sat, 23 Dec 2023 10:37:27 +0000</pubDate></item><item><title>C++æ‰“å°ç¯å¢ƒå˜é‡</title><link>https://0x1042.github.io//post/16.html</link><description># è·å–æ‰€æœ‰çš„ç¯å¢ƒå˜é‡ &#13;
&#13;
- [è·å–æ‰€æœ‰çš„ç¯å¢ƒå˜é‡](#è·å–æ‰€æœ‰çš„ç¯å¢ƒå˜é‡)&#13;
  - [`main` å‡½æ•°æ–¹å¼è·å–](#main-å‡½æ•°æ–¹å¼è·å–)&#13;
  - [`environ`è¯»å–](#environè¯»å–)&#13;
&#13;
## `main` å‡½æ•°æ–¹å¼è·å– &#13;
&#13;
```cpp&#13;
&#13;
auto main(int argc, char ** argv, char ** envp) -&gt; int {&#13;
    logEnv(envp);&#13;
}&#13;
&#13;
void logEnv(char ** envp) {&#13;
    LOG(INFO) &lt;&lt; 'current pid is ' &lt;&lt; getpid();&#13;
    for (char ** this_env = envp; *this_env != nullptr; ++this_env) {&#13;
        LOG(INFO) &lt;&lt; 'env:' &lt;&lt; std::string(*this_env);&#13;
    }&#13;
}&#13;
```&#13;
&#13;
&#13;
## `environ`è¯»å– &#13;
&#13;
&gt; ç­‰åŒ `cat /proc/${PID}/environ | tr '\0' '\n'`&#13;
&#13;
```cpp&#13;
&#13;
auto main() -&gt; int {&#13;
    logEnv2();&#13;
}&#13;
&#13;
void logEnv2() {&#13;
    pid_t pid = getpid();&#13;
    std::clog &lt;&lt; 'current pid is ' &lt;&lt; pid &lt;&lt; '\n';&#13;
    std::string envfile = '/proc/' + std::to_string(pid) + '/environ';&#13;
&#13;
    std::ifstream input(envfile);&#13;
&#13;
    std::string envkv;&#13;
    while (!input.eof()) {&#13;
        std::getline(input, envkv, '\0');&#13;
        std::clog &lt;&lt; envkv &lt;&lt; '\n';&#13;
    }&#13;
&#13;
    input.close();&#13;
}&#13;
```&#13;
ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/16.html</guid><pubDate>Sun, 17 Dec 2023 15:11:33 +0000</pubDate></item><item><title>ML hello world</title><link>https://0x1042.github.io//post/15.html</link><description># ç¥ç»ç½‘ç»œç®€ä»‹&#13;
&#13;
- [ç¥ç»ç½‘ç»œç®€ä»‹](#ç¥ç»ç½‘ç»œç®€ä»‹)&#13;
  - [è®­ç»ƒè¿‡ç¨‹](#è®­ç»ƒè¿‡ç¨‹)&#13;
  - [ä¼ æ’­](#ä¼ æ’­)&#13;
  - [å¦‚ä½•è®¡ç®—æŸå¤±](#å¦‚ä½•è®¡ç®—æŸå¤±)&#13;
  - [å¦‚ä½•ä¼˜åŒ–](#å¦‚ä½•ä¼˜åŒ–)&#13;
  - [æ¢¯åº¦ä¸‹é™](#æ¢¯åº¦ä¸‹é™)&#13;
  - [å­¦ä¹ ç‡](#å­¦ä¹ ç‡)&#13;
  - [æ¿€æ´»å‡½æ•°](#æ¿€æ´»å‡½æ•°)&#13;
  - [tensor](#tensor)&#13;
- [æ“ä½œè¿‡ç¨‹](#æ“ä½œè¿‡ç¨‹)&#13;
- [å•å˜é‡çº¿æ€§å›å½’](#å•å˜é‡çº¿æ€§å›å½’)&#13;
  - [æ„å»ºæ¨¡å‹](#æ„å»ºæ¨¡å‹)&#13;
  - [è®­ç»ƒ](#è®­ç»ƒ)&#13;
  - [æµ‹è¯•](#æµ‹è¯•)&#13;
  - [å¤šå˜é‡çº¿æ€§å›å½’æ¨¡å‹](#å¤šå˜é‡çº¿æ€§å›å½’æ¨¡å‹)&#13;
    - [æ¨¡å‹è®­ç»ƒ](#æ¨¡å‹è®­ç»ƒ)&#13;
    - [éªŒè¯](#éªŒè¯)&#13;
- [å‚è€ƒ](#å‚è€ƒ)&#13;
&#13;
![ç¥ç»ç½‘ç»œ](https://github.com/0x1042/0x1042.github.io/assets/7525242/86419435-239d-424d-afd2-021096a0c932)&#13;
&#13;
&#13;
ç»™å®š1000ä¸ªç›¸äº²å¯¹è±¡çš„æ•°æ®**ç‰¹å¾**(**feature**),å’Œå¯¹åº”çš„æ»¡æ„ç¨‹åº¦**æ ‡ç­¾**(**label**)ï¼Œè®­ç»ƒå®Œæˆåï¼Œç»™å®šæ–°çš„ç›¸äº²å¯¹è±¡æ•°æ®æ¥é¢„æµ‹æ»¡æ„ç¨‹åº¦ï¼Œå³é¢„ä¼°(**predict**)&#13;
&#13;
## è®­ç»ƒè¿‡ç¨‹ &#13;
&#13;
&gt; è®­ç»ƒæ¨¡å‹çš„ç›®æ ‡æ˜¯ä»æ‰€æœ‰æ ·æœ¬ä¸­æ‰¾åˆ°ä¸€ç»„å¹³å‡æŸå¤±â€œè¾ƒå°â€çš„æƒé‡ï¼ˆwï¼‰å’Œåå·®ï¼ˆbï¼‰ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/15.html</guid><pubDate>Sun, 10 Dec 2023 14:15:07 +0000</pubDate></item><item><title>æ™ºèƒ½æŒ‡é’ˆä»¥åŠnew</title><link>https://0x1042.github.io//post/14.html</link><description># æ™ºèƒ½æŒ‡é’ˆè‡ªå®šä¹‰deleter&#13;
&#13;
- [æ™ºèƒ½æŒ‡é’ˆè‡ªå®šä¹‰deleter](#æ™ºèƒ½æŒ‡é’ˆè‡ªå®šä¹‰deleter)&#13;
  - [å‡½æ•°æŒ‡é’ˆ](#å‡½æ•°æŒ‡é’ˆ)&#13;
  - [å‡½æ•°å¯¹è±¡](#å‡½æ•°å¯¹è±¡)&#13;
  - [`lambda`å‡½æ•°](#lambdaå‡½æ•°)&#13;
- [å¯¹è±¡æ± ](#å¯¹è±¡æ± )&#13;
- [`new`](#new)&#13;
  - [`new operator` æ˜¯å…³é”®å­—](#new-operator-æ˜¯å…³é”®å­—)&#13;
  - [`operator new` æ˜¯ä¸€ä¸ªå‡½æ•°](#operator-new-æ˜¯ä¸€ä¸ªå‡½æ•°)&#13;
  - [`placement new` æ˜¯`operator new`çš„é‡è½½](#placement-new-æ˜¯operator-newçš„é‡è½½)&#13;
&#13;
## å‡½æ•°æŒ‡é’ˆ &#13;
&#13;
```cpp&#13;
void deleteVec(int * ptr) {&#13;
    delete[] ptr;&#13;
}&#13;
&#13;
TEST_CASE('test deleter', '[fb_pointer]') {&#13;
    std::unique_ptr&lt;int, decltype(&amp;deleteVec)&gt; my_ptr(new int[5], deleteVec);&#13;
}&#13;
```&#13;
## å‡½æ•°å¯¹è±¡ &#13;
&#13;
```cpp&#13;
template &lt;typename T&gt;&#13;
struct CustomDeleter {&#13;
    void operator()(T * t) const {&#13;
        delete t;&#13;
        std::clog &lt;&lt; 'CustomDeleter run... delete type is ' &lt;&lt; infra::Name&lt;T&gt;().name &lt;&lt; '\n';&#13;
    }&#13;
};&#13;
&#13;
TEST_CASE('test deleter', '[fb_obj]') {&#13;
    std::unique_ptr&lt;int, CustomDeleter&lt;int&gt;&gt; int_ptr(new int);&#13;
    std::unique_ptr&lt;double, CustomDeleter&lt;double&gt;&gt; double_ptr(new double);&#13;
}&#13;
```&#13;
&#13;
## `lambda`å‡½æ•°&#13;
&#13;
```cpp&#13;
TEST_CASE('test deleter', '[lambda]') {&#13;
    auto deleter = [](int * ptr) {&#13;
        delete[] ptr;&#13;
        std::clog &lt;&lt; ' delete by lambda ...' &lt;&lt; '\n';&#13;
    };&#13;
    std::unique_ptr&lt;int, decltype(deleter)&gt; arr(new int[5], deleter);&#13;
}&#13;
```&#13;
&#13;
# å¯¹è±¡æ± &#13;
&#13;
&#13;
- è¦ç¼“å­˜çš„å¯¹è±¡&#13;
&#13;
```cpp&#13;
class Object {&#13;
public:&#13;
    Object(const Object &amp;) = default;&#13;
    Object(Object &amp;&amp;) = delete;&#13;
    auto operator=(const Object &amp;) -&gt; Object &amp; = default;&#13;
    auto operator=(Object &amp;&amp;) -&gt; Object &amp; = delete;&#13;
    explicit Object(int id) : id(id) { std::clog &lt;&lt; 'Object ' &lt;&lt; id &lt;&lt; ' is created.\n'; }&#13;
&#13;
    ~Object() { std::cout &lt;&lt; 'Object ' &lt;&lt; id &lt;&lt; ' is destroyed.\n'; }&#13;
&#13;
    void doSomething() const;&#13;
&#13;
    [[nodiscard]] auto getId() const -&gt; int;&#13;
    void setId(int id_);&#13;
&#13;
private:&#13;
    int id;&#13;
};&#13;
```&#13;
&#13;
- å®šä¹‰å¯¹è±¡æ±  &#13;
&#13;
```cpp&#13;
&#13;
// pool.h &#13;
class ObjectPool {&#13;
public:&#13;
    struct ObjectDeleter {&#13;
        void operator()(Object * obj) {&#13;
            std::clog &lt;&lt; 'fake delete ' &lt;&lt; obj-&gt;getId() &lt;&lt; '\n';&#13;
            obj-&gt;setId(0);&#13;
            pool.push_back(obj);&#13;
        }&#13;
    };&#13;
&#13;
    static auto acquire() -&gt; std::unique_ptr&lt;Object, ObjectDeleter&gt;;&#13;
&#13;
    static auto size() -&gt; size_t;&#13;
&#13;
private:&#13;
    inline static std::vector&lt;Object *&gt; pool; // å¯¹è±¡æ± &#13;
};&#13;
&#13;
// pool.cpp&#13;
auto ObjectPool::acquire() -&gt; std::unique_ptr&lt;Object, ObjectDeleter&gt; {&#13;
    if (pool.empty()) {&#13;
        // return std::unique_ptr&lt;Object, ObjectDeleter&gt;(new Object(0), ObjectDeleter());&#13;
        return {new Object(0), ObjectDeleter()};&#13;
    }&#13;
    Object * obj = pool.back();&#13;
    pool.pop_back();&#13;
    // return std::unique_ptr&lt;Object, ObjectDeleter&gt;(obj, ObjectDeleter());&#13;
    return {obj, ObjectDeleter()};&#13;
}&#13;
&#13;
auto ObjectPool::size() -&gt; size_t {&#13;
    return pool.size();&#13;
}&#13;
```&#13;
&#13;
&#13;
# `new`&#13;
&#13;
## `new operator` æ˜¯å…³é”®å­— &#13;
&#13;
å°±æ˜¯`new` å…³é”®å­— `T *t = new T();` èƒŒååŒ…å«ä¸¤ä¸ªåŠ¨ä½œ&#13;
&#13;
1. è°ƒç”¨ `operator new` åˆ†é…å†…å­˜ ,å¹¶è¿”å›æŒ‡å‘è¯¥å¯¹è±¡çš„æŒ‡é’ˆ &#13;
2. è°ƒç”¨`T`çš„æ„é€ å‡½æ•° &#13;
3. ä¸å¯è¢«é‡è½½ &#13;
&#13;
&#13;
## `operator new` æ˜¯ä¸€ä¸ªå‡½æ•° &#13;
&#13;
æ˜¯ä¸€ä¸ªåŠ¨æ€å†…å­˜åˆ†é…çš„å‡½æ•° &#13;
&#13;
```cpp&#13;
void* operator new(std::size_t size);&#13;
```&#13;
&#13;
- åªåˆ†é…æ‰€è¦æ±‚çš„ç©ºé—´ï¼Œä¸è°ƒç”¨ç›¸å…³å¯¹è±¡çš„æ„é€ å‡½æ•°&#13;
- å½“æ— æ³•æ»¡è¶³æ‰€è¦æ±‚åˆ†é…çš„ç©ºé—´æ—¶&#13;
  - å¦‚æœæœ‰`new_handler`ï¼Œåˆ™è°ƒç”¨`new_handler`&#13;
  - å¦åˆ™å¦‚æœæ²¡è¦æ±‚ä¸æŠ›å‡ºå¼‚å¸¸ï¼ˆä»¥nothrowå‚æ•°è¡¨è¾¾ï¼‰ï¼Œåˆ™æ‰§è¡Œbad_allocå¼‚å¸¸ï¼Œå¦åˆ™&#13;
  - å¦åˆ™è¿”å›0&#13;
- å¯ä»¥è¢«é‡è½½ï¼Œé‡è½½æ—¶ï¼Œè¿”å›ç±»å‹å¿…é¡»å£°æ˜ä¸º`void*`&#13;
- ç¬¬ä¸€ä¸ªå‚æ•°ç±»å‹å¿…é¡»ä¸ºè¡¨è¾¾è¦æ±‚åˆ†é…ç©ºé—´çš„å¤§å°ï¼ˆå­—èŠ‚ï¼‰ï¼Œç±»å‹ä¸ºsize_t,å¯ä»¥æœ‰å…¶ä»–å‚æ•°&#13;
&#13;
&#13;
## `placement new` æ˜¯`operator new`çš„é‡è½½&#13;
&#13;
&gt; åŸå‹&#13;
&#13;
```cpp&#13;
void *operator new( size_t, void * p ) throw() { return p; }&#13;
```&#13;
&#13;
1. æ˜¯é‡è½½`operator new`çš„ä¸€ä¸ªæ ‡å‡†ã€å…¨å±€çš„ç‰ˆæœ¬ï¼Œå®ƒä¸èƒ½å¤Ÿè¢«è‡ªå®šä¹‰çš„ç‰ˆæœ¬ä»£æ›¿(ä¸åƒæ™®é€šç‰ˆæœ¬çš„operator newå’Œoperator deleteèƒ½å¤Ÿè¢«æ›¿æ¢)&#13;
2. æ‰§è¡Œå¿½ç•¥`size_t`å‚æ•°ï¼Œåªè¿”å›ç¬¬äºŒä¸ªå‚æ•°ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/14.html</guid><pubDate>Fri, 01 Dec 2023 14:56:01 +0000</pubDate></item><item><title>c++ä¸­è·å–ç±»å®šä¹‰çš„å®Œæ•´åå­—</title><link>https://0x1042.github.io//post/13.html</link><description># è¯´æ˜&#13;
&#13;
&gt; ä»…é™äºè¯»å–ç±»å®šä¹‰&#13;
&#13;
```cpp&#13;
&#13;
#include &lt;memory&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
#include &lt;cxxabi.h&gt;&#13;
&#13;
template &lt;typename T&gt;&#13;
struct Name {&#13;
    Name() {&#13;
        std::unique_ptr&lt;char, decltype(free) *&gt; real_name(abi::__cxa_demangle(typeid(T).name(), nullptr, nullptr, nullptr), free);&#13;
        this-&gt;name = std::string(real_name.get());&#13;
    }&#13;
&#13;
    std::string name{};&#13;
};&#13;
&#13;
```&#13;
&#13;
æµ‹è¯• &#13;
&#13;
```cpp&#13;
namespace tests {&#13;
&#13;
namespace a::b::c {&#13;
    class A {};&#13;
} // namespace a::b::c&#13;
&#13;
namespace na {&#13;
    class B {};&#13;
} // namespace na&#13;
&#13;
namespace a::b::d {&#13;
    struct C {};&#13;
} // namespace a::b::d&#13;
&#13;
TEST_CASE('test name', '[name]') {&#13;
    // tests::a::b::c::A&#13;
    LOG(INFO) &lt;&lt; 'infra::Name&lt;a::b::c::A&gt;().name:' &lt;&lt; infra::Name&lt;a::b::c::A&gt;().name;&#13;
    // tests::na::B&#13;
    LOG(INFO) &lt;&lt; 'infra::Name&lt;na::B&gt;().name:' &lt;&lt; infra::Name&lt;na::B&gt;().name;&#13;
    // tests::a::b::d::C&#13;
    LOG(INFO) &lt;&lt; 'infra::Name&lt;a::b::d::C&gt;().name:' &lt;&lt; infra::Name&lt;a::b::d::C&gt;().name;&#13;
}&#13;
} // namespace tests&#13;
```&#13;
ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/13.html</guid><pubDate>Mon, 27 Nov 2023 15:28:20 +0000</pubDate></item><item><title>ä¸ƒã€`constexpr` </title><link>https://0x1042.github.io//post/12.html</link><description># constexpr å…ƒç¼–ç¨‹&#13;
&#13;
- [constexpr å…ƒç¼–ç¨‹](#constexpr-å…ƒç¼–ç¨‹)&#13;
  - [`constexpr` å˜é‡](#constexpr-å˜é‡)&#13;
  - [`constinit` åˆå§‹åŒ–](#constinit-åˆå§‹åŒ–)&#13;
  - [`constexpr` å‡½æ•°](#constexpr-å‡½æ•°)&#13;
  - [`consteval` å‡½æ•°](#consteval-å‡½æ•°)&#13;
- [`if constexpr`](#if-constexpr)&#13;
- [æŠ˜å è¡¨è¾¾å¼](#æŠ˜å è¡¨è¾¾å¼)&#13;
  - [å³æŠ˜å ](#å³æŠ˜å )&#13;
  - [å·¦æŠ˜å ](#å·¦æŠ˜å )&#13;
- [ä»¤äººå¤´å¤§çš„`const`](#ä»¤äººå¤´å¤§çš„const)&#13;
  - [`int const* ptr`](#int-const-ptr)&#13;
  - [`int * const ptr`](#int--const-ptr)&#13;
  - [ç»ˆæCASE](#ç»ˆæcase)&#13;
&#13;
## `constexpr` å˜é‡&#13;
&#13;
**ä¸`const`å˜é‡çš„åŒºåˆ«ï¼Ÿ**&#13;
&#13;
- `constexpr` éœ€è¦ä¿è¯è¡¨è¾¾å¼å¯åœ¨ç¼–è¯‘æ—¶æ±‚å€¼ï¼Œå¦åˆ™ä¼šå‡ºç°ç¼–è¯‘é”™è¯¯ &#13;
- `const` è¡¨è¾¾å¼æ‹¥æœ‰å¸¸é‡æ€§ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/12.html</guid><pubDate>Sun, 26 Nov 2023 10:44:29 +0000</pubDate></item><item><title>å…­ã€åç¨‹å®ç°ç»†èŠ‚</title><link>https://0x1042.github.io//post/11.html</link><description># åç¨‹å®ç°ç»†èŠ‚&#13;
&#13;
- [åç¨‹å®ç°ç»†èŠ‚](#åç¨‹å®ç°ç»†èŠ‚)&#13;
- [åç¨‹çš„ç”Ÿå‘½å‘¨æœŸ](#åç¨‹çš„ç”Ÿå‘½å‘¨æœŸ)&#13;
  - [`promise_type`](#promise_type)&#13;
  - [åç¨‹ç±»](#åç¨‹ç±»)&#13;
  - [`coroutine_handle`](#coroutine_handle)&#13;
- [åç¨‹çš„è°ƒåº¦](#åç¨‹çš„è°ƒåº¦)&#13;
  - [`co_await`](#co_await)&#13;
  - [`co_yield`](#co_yield)&#13;
&#13;
&#13;
# åç¨‹çš„ç”Ÿå‘½å‘¨æœŸ &#13;
&#13;
![call_routine](https://github.com/0x1042/0x1042.github.io/assets/7525242/f155fdff-fff4-49eb-88cb-500b55bd63ea)&#13;
&#13;
&#13;
1. è°ƒç”¨å‡½æ•°åœ¨**å †**ä¸Šï¼Œåˆ›å»ºåç¨‹å¸§(`coroutine_frame`)ï¼Œé‡Œé¢åŒ…å«äº†åç¨‹çš„`promise_type`,åç¨‹çš„å®å‚ï¼Œå½“å‰ä¿å­˜çš„å±€éƒ¨å˜é‡ï¼Œåç¨‹å†…éƒ¨çŠ¶æ€å¦‚æŒ‚èµ·ç‚¹. ç”±ç¼–è¯‘å™¨å®ç°&#13;
2. åˆ›å»ºåç¨‹å¸§ä¹‹åï¼Œä¼šè¿”å›ç»™è°ƒç”¨è€…`coroutine_handle`,ä¹Ÿå«åç¨‹å¥æŸ„ï¼Œæ˜¯æ§åˆ¶åç¨‹çš„å”¯ä¸€å…¥å£ï¼Œå¯ä»¥è¢«ä¼ é€’åˆ°å…¶ä»–åœ°æ–¹&#13;
3. è°ƒç”¨è¢«è°ƒç”¨åç¨‹ï¼Œåç¨‹å¼€å§‹æ‰§è¡Œ&#13;
4. è¢«è°ƒç”¨åç¨‹æ‰§è¡Œåˆ°æŸä¸ªç‰¹å®šç‚¹ï¼Œé€šè¿‡`co_await/co_yield` å°†å½“å‰åç¨‹ä¼‘çœ ï¼Œè°ƒç”¨è€…æ¢å¤åŸæœ¬çš„æ‰§è¡Œæµç¨‹ç»§ç»­æ‰§è¡Œå‰©ä½™ä»£ç &#13;
5. åç¨‹æ¢å¤è€…ï¼ˆæ¯”å¦‚å¦ä¸€ä¸ªçº¿ç¨‹ï¼‰é€šè¿‡`coroutine_handle`çš„æ¢å¤å‡½æ•°`resume` æ¢å¤åç¨‹æ‰§è¡Œ&#13;
6. åç¨‹åœ¨æ¢å¤è€…ä¸Šç»§ç»­æ‰§è¡Œï¼Œç»“æŸåé€šè¿‡ `coroutine_handle` é”€æ¯åç¨‹å¸§ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/11.html</guid><pubDate>Sat, 18 Nov 2023 19:03:14 +0000</pubDate></item><item><title>äº”ã€åç¨‹åŸºæœ¬ä½¿ç”¨</title><link>https://0x1042.github.io//post/10.html</link><description># åç¨‹ ~~å…¥é—¨~~&#13;
&#13;
- [åç¨‹ ~~å…¥é—¨~~](#åç¨‹-å…¥é—¨)&#13;
  - [å®šä¹‰](#å®šä¹‰)&#13;
  - [åŸºæœ¬åŸç†](#åŸºæœ¬åŸç†)&#13;
    - [ä¸€ã€åç¨‹æ ˆå¸§(ç¼–è¯‘å™¨ç”Ÿæˆ)](#ä¸€åç¨‹æ ˆå¸§ç¼–è¯‘å™¨ç”Ÿæˆ)&#13;
    - [äºŒã€åˆ›å»ºåç¨‹](#äºŒåˆ›å»ºåç¨‹)&#13;
    - [ä¸‰ã€åç¨‹æ¢å¤(\_\_fibonacciResume)](#ä¸‰åç¨‹æ¢å¤__fibonacciresume)&#13;
    - [å››ã€é”€æ¯](#å››é”€æ¯)&#13;
- [å®ç°ä¸€ä¸ªåç¨‹](#å®ç°ä¸€ä¸ªåç¨‹)&#13;
  - [å®šä¹‰ `Generator`](#å®šä¹‰-generator)&#13;
  - [å®šä¹‰ `promise_type`](#å®šä¹‰-promise_type)&#13;
  - [å®šä¹‰åç¨‹å‡½æ•°](#å®šä¹‰åç¨‹å‡½æ•°)&#13;
- [å‚è€ƒ](#å‚è€ƒ)&#13;
&#13;
&#13;
## å®šä¹‰ &#13;
&#13;
c++20çš„åç¨‹å®šä¹‰æ˜¯ä¸€ä¸ª**å¯æš‚åœã€å¯æ¢å¤**çš„å‡½æ•°ï¼Œå…·ä½“åˆ°å®ç°ä¸Šï¼Œå¦‚æœå‡½æ•°åŒ…å«`co_awaitã€co_yieldã€co_return` å…³é”®å­—ä¹‹ä¸€ï¼Œå°±ä¼šè¢«è®¤ä¸ºæ˜¯åç¨‹&#13;
&#13;
![coroutine](https://github.com/0x1042/0x1042.github.io/assets/7525242/c2954b77-82a6-4a8f-b3a8-740adb8a9852)&#13;
&#13;
&#13;
- æš‚åœï¼Œå³æ„å‘³ç€éœ€è¦ä¿å­˜å‡½æ•°æ‰§è¡Œè¿‡ç¨‹ä¸­äº§ç”Ÿçš„ä¸Šä¸‹æ–‡&#13;
- æ¢å¤ï¼Œè°ƒç”¨æ–¹å¯ä»¥è·å–åˆ°è¿™ä¸ªåç¨‹åœ¨å †ä¸Šçš„æ§åˆ¶å…¥å£&#13;
&#13;
| å…³é”®å­—      | è¯´æ˜         |&#13;
| ----------- | ------------ |&#13;
| `co_await`  | æŒ‚èµ·         |&#13;
| `co_yield`  | æŒ‚èµ·å¹¶è¿”å›å€¼ |&#13;
| `co_return` | ç»“æŸåç¨‹     |&#13;
&#13;
## åŸºæœ¬åŸç† &#13;
&#13;
å‚è€ƒ [C++20 Coroutine][1],[C++20åç¨‹][2].  æ ¸å¿ƒæ˜¯æœ‰ç¼–è¯‘å™¨é’ˆå¯¹åç¨‹å‡½æ•°åšpatchï¼Œç”Ÿæˆæ–°çš„ä»£ç ï¼ŒåŒºåˆ«äºæœ‰æ ˆåç¨‹ï¼Œéœ€è¦æœ‰å¯¹åº”çš„runtimeæ¥è°ƒåº¦.&#13;
&#13;
å¯ä»¥åœ¨ [cppinsights.io](https://cppinsights.io) ä¸Šæ‰“å¼€ `Show coroutine transformation` é€‰é¡¹ï¼ŒæŸ¥çœ‹è¯¦ç»†çš„ç»†èŠ‚ï¼Œç”Ÿæˆçš„ç»“æœä¸­æœ‰æ³¨é‡Šï¼Œæ˜¯ä¸€ä¸ªè¿‘ä¼¼çš„ç»“æœ&#13;
&#13;
### ä¸€ã€åç¨‹æ ˆå¸§(ç¼–è¯‘å™¨ç”Ÿæˆ)&#13;
&#13;
```cpp&#13;
struct __fibonacciFrame&#13;
{&#13;
  void (*resume_fn)(__fibonacciFrame *);  // åç¨‹æ¢å¤å‡½æ•° &#13;
  void (*destroy_fn)(__fibonacciFrame *); // åç¨‹é”€æ¯å‡½æ•° &#13;
  std::coroutine_traits&lt;std::coroutine_handle&lt;promise&gt;, int&gt;::promise_type __promise; // åç¨‹çš„promise_type&#13;
  int __suspend_index;&#13;
  bool __initial_await_suspend_called;&#13;
  int a;&#13;
  int i;&#13;
  int j;&#13;
  std::suspend_never __suspend_47_27;&#13;
  std::suspend_always __suspend_51_9;&#13;
  std::suspend_always __suspend_47_27_1;&#13;
};&#13;
```&#13;
&#13;
### äºŒã€åˆ›å»ºåç¨‹&#13;
&#13;
&gt; è°ƒç”¨æ–¹è°ƒç”¨åç¨‹å‡½æ•°æ—¶(`fibonacci()`)ï¼Œç¼–è¯‘å™¨ä¼šç”Ÿæˆç±»ä¼¼ä¸‹é¢çš„ä»£ç , è¿™ä¸ªå‡½æ•°çš„è¿”å›å€¼æ—¶ `std::coroutine_handle&lt;promise&gt;`,ä¹Ÿå°±æ˜¯ä¸Šé¢è¯´çš„ åç¨‹çš„æ§åˆ¶ç‚¹(å¥æŸ„)&#13;
&gt; è€Œè¿™ä¸ªè¿”å›å€¼æ˜¯é€šè¿‡ åç¨‹çš„ promise_type å¯¹åº”çš„ get_return_object å‡½æ•°è·å–&#13;
&#13;
```cpp&#13;
std::coroutine_handle&lt;promise&gt; fibonacci(int a)&#13;
{&#13;
  /* Allocate the frame including the promise */&#13;
  /* Note: The actual parameter new is __builtin_coro_size */&#13;
  __fibonacciFrame * __f = reinterpret_cast&lt;__fibonacciFrame *&gt;(operator new(sizeof(__fibonacciFrame)));&#13;
  __f-&gt;__suspend_index = 0;&#13;
  __f-&gt;__initial_await_suspend_called = false;&#13;
  __f-&gt;a = std::forward&lt;int&gt;(a);&#13;
  &#13;
  /* Construct the promise. */&#13;
  new (&amp;__f-&gt;__promise)std::coroutine_traits&lt;std::coroutine_handle&lt;promise&gt;, int&gt;::promise_type{__f-&gt;a};&#13;
  &#13;
  /* Forward declare the resume and destroy function. */&#13;
  void __fibonacciResume(__fibonacciFrame * __f);&#13;
  void __fibonacciDestroy(__fibonacciFrame * __f);&#13;
  &#13;
  /* Assign the resume and destroy function pointers. */&#13;
  __f-&gt;resume_fn = &amp;__fibonacciResume;&#13;
  __f-&gt;destroy_fn = &amp;__fibonacciDestroy;&#13;
  &#13;
  /* Call the made up function with the coroutine body for initial suspend.&#13;
     This function will be called subsequently by coroutine_handle&lt;&gt;::resume()&#13;
     which calls __builtin_coro_resume(__handle_) */&#13;
  __fibonacciResume(__f);&#13;
  &#13;
  &#13;
  return __f-&gt;__promise.get_return_object();&#13;
}&#13;
```&#13;
&#13;
&#13;
### ä¸‰ã€åç¨‹æ¢å¤(__fibonacciResume)&#13;
&#13;
&gt; è¿™ä¸ªæ˜¯åç¨‹çš„æ ¸å¿ƒæ‰§è¡Œé€»è¾‘ï¼Œä¹Ÿå°±æ˜¯ç¼–è¯‘å™¨patchåçš„ç»“æœ &#13;
&gt; æ ¸å¿ƒæ˜¯ è°ƒç”¨åç¨‹çš„promise_typeç›¸å…³çš„æ–¹æ³•  &#13;
&#13;
```cpp&#13;
/* This function invoked by coroutine_handle&lt;&gt;::resume() */&#13;
void __fibonacciResume(__fibonacciFrame * __f)&#13;
{&#13;
  try &#13;
  {&#13;
    /* Create a switch to get to the correct resume point */&#13;
    switch(__f-&gt;__suspend_index) {&#13;
      case 0: break;&#13;
      case 1: goto __resume_fibonacci_1;&#13;
      case 2: goto __resume_fibonacci_2;&#13;
    }&#13;
    &#13;
    /* co_await insights.cpp:47 */&#13;
    __f-&gt;__suspend_47_27 = __f-&gt;__promise.initial_suspend();&#13;
    if(!__f-&gt;__suspend_47_27.await_ready()) {&#13;
      __f-&gt;__suspend_47_27.await_suspend(std::coroutine_handle&lt;promise&gt;::from_address(static_cast&lt;void *&gt;(__f)).operator std::coroutine_handle&lt;void&gt;());&#13;
      __f-&gt;__suspend_index = 1;&#13;
      __f-&gt;__initial_await_suspend_called = true;&#13;
      return;&#13;
    } &#13;
    &#13;
    __resume_fibonacci_1:&#13;
    __f-&gt;__suspend_47_27.await_resume();&#13;
    __f-&gt;i = 1;&#13;
    __f-&gt;j = __f-&gt;a;&#13;
    while(1) {&#13;
      std::tie(__f-&gt;i, __f-&gt;j).operator=(std::make_pair(__f-&gt;j, __f-&gt;i + __f-&gt;j));&#13;
      &#13;
      /* co_yield insights.cpp:51 */&#13;
      __f-&gt;__suspend_51_9 = __f-&gt;__promise.yield_value(__f-&gt;j);&#13;
      if(!__f-&gt;__suspend_51_9.await_ready()) {&#13;
        __f-&gt;__suspend_51_9.await_suspend(std::coroutine_handle&lt;promise&gt;::from_address(static_cast&lt;void *&gt;(__f)).operator std::coroutine_handle&lt;void&gt;());&#13;
        __f-&gt;__suspend_index = 2;&#13;
        return;&#13;
      } &#13;
      &#13;
      __resume_fibonacci_2:&#13;
      __f-&gt;__suspend_51_9.await_resume();&#13;
    }&#13;
    &#13;
    goto __final_suspend;&#13;
  } catch(...) {&#13;
    if(!__f-&gt;__initial_await_suspend_called) {&#13;
      throw ;&#13;
    } &#13;
    &#13;
    __f-&gt;__promise.unhandled_exception();&#13;
  }&#13;
  &#13;
  __final_suspend:&#13;
  &#13;
  /* co_await insights.cpp:47 */&#13;
  __f-&gt;__suspend_47_27_1 = __f-&gt;__promise.final_suspend();&#13;
  if(!__f-&gt;__suspend_47_27_1.await_ready()) {&#13;
    __f-&gt;__suspend_47_27_1.await_suspend(std::coroutine_handle&lt;promise&gt;::from_address(static_cast&lt;void *&gt;(__f)).operator std::coroutine_handle&lt;void&gt;());&#13;
  } &#13;
  &#13;
  ;&#13;
}&#13;
```&#13;
&#13;
### å››ã€é”€æ¯ &#13;
&#13;
```cpp&#13;
/* This function invoked by coroutine_handle&lt;&gt;::destroy() */&#13;
void __fibonacciDestroy(__fibonacciFrame * __f)&#13;
{&#13;
  /* destroy all variables with dtors */&#13;
  __f-&gt;~__fibonacciFrame();&#13;
  /* Deallocating the coroutine frame */&#13;
  /* Note: The actual argument to delete is __builtin_coro_frame with the promise as parameter */&#13;
  operator delete(static_cast&lt;void *&gt;(__f));&#13;
}&#13;
```&#13;
&#13;
**ä»ç¼–è¯‘å™¨ç”Ÿæˆçš„ä»£ç çœ‹ï¼Œå¦‚æœè¦è‡ªå·±å®ç°åç¨‹ï¼Œå°±éœ€è¦è‡ªå®šä¹‰è¿™ä¸ªåç¨‹çš„promise_type**&#13;
&#13;
`promise_type å¿…é¡»åŒ…å«ä¸€ä¸‹æˆå‘˜å‡½æ•°`&#13;
&#13;
```cpp&#13;
SOME_TYPE get_return_object();//ç”¨äºå¾—åˆ°åç¨‹å‡½æ•°å¼€å§‹æ‰§è¡Œçš„è¿”å›å€¼&#13;
SOME_TYPE initial_suspend();//ç”¨äºåç¨‹å‡½æ•°å¼€å§‹æ‰§è¡Œæ—¶æ‰§è¡Œæš‚åœæ“ä½œ&#13;
void return_void();//åç¨‹å‡½æ•°å†…éƒ¨co_returnç»ˆæ­¢è¿”å›voidæ—¶æ‰§è¡Œçš„æ“ä½œï¼ˆå’Œä¸‹é¢return_valueåŒæ—¶åªèƒ½æœ‰ä¸€ä¸ªå­˜åœ¨ï¼‰&#13;
void return_value(SOME_TYPE);//åç¨‹å‡½æ•°å†…éƒ¨co_returnç»ˆæ­¢è¿”å›évoidå€¼æ—¶æ‰§è¡Œçš„æ“ä½œ&#13;
SOME_TYPE final_suspend()noexcept;//ç”¨äºåç¨‹å‡½æ•°ç»“æŸæ‰§è¡Œæ—¶æ‰§è¡Œæš‚åœæ“ä½œ&#13;
void unhandled_exception();//ç”¨äºåç¨‹å‡½æ•°å†…éƒ¨æœ‰æœªæ¥ä½çš„å¼‚å¸¸æ—¶æ‰§è¡Œ&#13;
auto ield_value();&#13;
```&#13;
&#13;
&#13;
# å®ç°ä¸€ä¸ªåç¨‹ &#13;
&#13;
## å®šä¹‰ `Generator`&#13;
&#13;
**çº¦æŸèŒƒå‹çš„ç±»å‹çº¦æŸæ˜¯æ— ç¬¦å·æ•´æ•°**&#13;
&#13;
```cpp&#13;
template &lt;typename T&gt;&#13;
concept integral = std::is_integral_v&lt;T&gt; &amp;&amp; !std::is_signed_v&lt;T&gt;;&#13;
&#13;
template &lt;integral T&gt;&#13;
struct FibPromise;&#13;
&#13;
template &lt;integral T&gt;&#13;
struct FibGenerator {&#13;
    using promise_type = FibPromise&lt;T&gt;;&#13;
&#13;
    std::coroutine_handle&lt;promise_type&gt; handler;&#13;
&#13;
    auto next() -&gt; int {&#13;
        handler.resume();&#13;
        return handler.promise().value;&#13;
    }&#13;
&#13;
    explicit FibGenerator(promise_type * p)&#13;
        : handler{std::coroutine_handle&lt;promise_type&gt;::from_promise(*p)} {&#13;
    }&#13;
&#13;
    ~FibGenerator() {&#13;
        handler.destroy();&#13;
    }&#13;
};&#13;
```&#13;
&#13;
## å®šä¹‰ `promise_type`&#13;
&#13;
```cpp&#13;
template &lt;integral T&gt;&#13;
struct FibPromise {&#13;
    std::exception_ptr exception;&#13;
&#13;
    FibPromise() = default;&#13;
&#13;
    FibPromise(T val)&#13;
        : value(val) {&#13;
    }&#13;
&#13;
    FibGenerator&lt;T&gt; get_return_object() { return FibGenerator{this}; }&#13;
&#13;
    auto initial_suspend() noexcept -&gt; std::suspend_always { return {}; }&#13;
&#13;
    auto final_suspend() noexcept -&gt; std::suspend_always { return {}; }&#13;
&#13;
    auto yield_value(T val) -&gt; std::suspend_always {&#13;
        value = val;&#13;
        return {};&#13;
    }&#13;
&#13;
    auto return_value(T val) -&gt; std::suspend_always {&#13;
        value = val;&#13;
        return {};&#13;
    }&#13;
    // void return_void() {}&#13;
&#13;
    void unhandled_exception() { exception = std::current_exception(); }&#13;
&#13;
    T value;&#13;
};&#13;
```&#13;
&#13;
## å®šä¹‰åç¨‹å‡½æ•°&#13;
&#13;
```cpp&#13;
inline FibGenerator&lt;uint32_t&gt; fib(uint32_t n) {&#13;
    uint32_t first = 0;&#13;
    uint32_t second = 1;&#13;
    while (n--) {&#13;
        co_yield second;&#13;
        const auto tmp = first;&#13;
        first = second;&#13;
        second += tmp;&#13;
    }&#13;
}&#13;
&#13;
&#13;
// æµ‹è¯• &#13;
void test_fib() {&#13;
    auto gen = fib(10);&#13;
    for (int i = 0; i &lt; 10; i++) {&#13;
        std::clog &lt;&lt; gen.next() &lt;&lt; '\n';&#13;
    }&#13;
}&#13;
```&#13;
&#13;
# å‚è€ƒ &#13;
&#13;
[1]: https://owent.net/2019/1904.html  'C++20 Coroutine'&#13;
[2]: https://z3475.work/post/c20-xie-cheng-mai-xiang-yi-bu-part1-zui-jian-dan-de-xie-cheng/  '[C++20åç¨‹]è¿ˆå‘å¼‚æ­¥ Part1-æœ€ç®€å•çš„åç¨‹'&#13;
&#13;
&#13;
ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/10.html</guid><pubDate>Sat, 18 Nov 2023 14:20:07 +0000</pubDate></item><item><title>å››ã€concept</title><link>https://0x1042.github.io//post/9.html</link><description># concept&#13;
&#13;
- [concept](#concept)&#13;
  - [åŸºæœ¬å®šä¹‰å’Œä½¿ç”¨](#åŸºæœ¬å®šä¹‰å’Œä½¿ç”¨)&#13;
  - [çº¦æŸè¡¨è¾¾å¼](#çº¦æŸè¡¨è¾¾å¼)&#13;
  - [`requires` è¡¨è¾¾å¼](#requires-è¡¨è¾¾å¼)&#13;
  - [`requires` å­å¥](#requires-å­å¥)&#13;
  - [`concepts` header](#concepts-header)&#13;
&#13;
## åŸºæœ¬å®šä¹‰å’Œä½¿ç”¨&#13;
&#13;
- åŸºæœ¬å®šä¹‰&#13;
```cpp&#13;
// è¯­æ³•æ ¼å¼&#13;
// template&lt;typename T&gt;&#13;
// concept concept_name = constraint-expression(çº¦æŸè¡¨è¾¾å¼);&#13;
&#13;
template &lt;typename T&gt;&#13;
concept integral = std::is_integral_v&lt;T&gt;;&#13;
&#13;
template &lt;typename T&gt;&#13;
concept floating_point = std::is_floating_point_v&lt;T&gt;;&#13;
&#13;
template &lt;typename T&gt;&#13;
concept C = std::is_integral_v&lt;T&gt; || (sizeof(T) &gt; 1);&#13;
&#13;
template &lt;typename T, typename U&gt;&#13;
concept Derived = std::is_base_of_v&lt;U, T&gt;;&#13;
&#13;
```&#13;
&#13;
- åŸºæœ¬ä½¿ç”¨ **ä½¿ç”¨`concept_name` æ›¿æ¢ `typename`**&#13;
&#13;
```cpp&#13;
&#13;
// å®šä¹‰ &#13;
class Base {&#13;
public:&#13;
    [[nodiscard]] auto getValue() const -&gt; int32_t { return value; }&#13;
&#13;
    explicit Base(const int32_t value)&#13;
        : value(value) {&#13;
    }&#13;
&#13;
private:&#13;
    int32_t value;&#13;
};&#13;
&#13;
template &lt;typename T&gt;&#13;
concept DerivedBase = std::is_base_of_v&lt;Base, T&gt;;&#13;
&#13;
// ä½¿ç”¨concept_name æ›¿æ¢ typename&#13;
template &lt;DerivedBase T&gt;&#13;
auto doGetValue(const T &amp; t) -&gt; int32_t {&#13;
    return t.getValue();&#13;
}&#13;
&#13;
class DerivedClass : public Base {&#13;
public:&#13;
    explicit DerivedClass(int32_t value)&#13;
        : Base(value) {&#13;
    }&#13;
&#13;
    [[nodiscard]] auto getValue() const -&gt; int32_t { return 1024; }&#13;
};&#13;
```&#13;
&#13;
## çº¦æŸè¡¨è¾¾å¼&#13;
&#13;
- åˆå–å¼ conjunctionsï¼Œé€»è¾‘ä¸ &#13;
```cpp&#13;
template &lt;typename T&gt;&#13;
concept integral = std::is_integral_v&lt;T&gt;;&#13;
&#13;
template &lt;typename T&gt;&#13;
concept signed_int = integral&lt;T&gt; &amp;&amp; std::is_signed_v&lt;T&gt;;&#13;
&#13;
```&#13;
- æå–å¼ disjunctionsï¼Œé€»è¾‘æˆ–&#13;
&#13;
```cpp&#13;
template &lt;typename T&gt;&#13;
concept integral = std::is_integral_v&lt;T&gt;;&#13;
&#13;
template &lt;typename T&gt;&#13;
concept floating_point = std::is_floating_point_v&lt;T&gt;;&#13;
&#13;
template &lt;typename T&gt;&#13;
concept number = integral&lt;T&gt; || floating_point&lt;T&gt;;&#13;
&#13;
```&#13;
- åŸå­çº¦æŸ atomic constraints &#13;
&#13;
```cpp&#13;
```&#13;
&#13;
## `requires` è¡¨è¾¾å¼&#13;
&#13;
&gt; é™¤äº†ä½¿ç”¨`type traits` å®šä¹‰æ¦‚å¿µä¹‹å¤–ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ `requires` è¡¨è¾¾å¼æ¥è¡¨è¾¾å¯¹æ¨¡æ¿å‚æ•°åŠå…¶å¯¹è±¡çš„ç‰¹å¾è¦æ±‚&#13;
&gt; æˆå‘˜å‡½æ•°ã€è‡ªç”±å‡½æ•°ã€å…³è”ç±»å‹ç­‰&#13;
&#13;
- åŸºæœ¬è¯­æ³• &#13;
&#13;
```cpp&#13;
&#13;
requires(å¯é€‰å‚æ•°åˆ—è¡¨) {&#13;
    è¡¨è¾¾å¼1&#13;
    è¡¨è¾¾å¼2&#13;
}&#13;
&#13;
```&#13;
&#13;
- åŸºæœ¬çº¦æŸ &#13;
```cpp&#13;
template &lt;typename T&gt;&#13;
concept Machine = requires(T t)&#13;
{&#13;
    // è¦æ±‚å­˜åœ¨åŒåçš„æˆå‘˜å‡½æ•°&#13;
    t.powerup();&#13;
&#13;
    t.powerDown();&#13;
    // è¦æ±‚å­˜åœ¨æˆå‘˜å˜é‡name&#13;
    t.name;&#13;
    // è¦æ±‚å­˜åœ¨é™æ€æˆå‘˜count&#13;
    T::count;&#13;
};&#13;
&#13;
template &lt;typename T&gt;&#13;
concept Animal = requires(T t1, T t2, T t3)&#13;
{&#13;
    // è¦æ±‚å­˜åœ¨ name æˆå‘˜å˜é‡&#13;
    t1.name;&#13;
&#13;
    // è¦æ±‚èƒ½å¤Ÿè¿›è¡Œåˆ¤ç­‰æ“ä½œ&#13;
    t1 == t2;&#13;
&#13;
    // è¦æ±‚èƒ½å¤Ÿè¿›è¡Œ åŠ ã€ä¹˜æ“ä½œ&#13;
    t1 + t2 * t3;&#13;
};&#13;
&#13;
```&#13;
&#13;
- ç±»å‹çº¦æŸ &#13;
```cpp&#13;
template &lt;typename T&gt;&#13;
concept C2 = requires&#13;
{&#13;
    // è¦æ±‚å­˜åœ¨ç±»å‹æˆå‘˜ type&#13;
    typename T::type;&#13;
&#13;
    // è¦æ±‚èƒ½å¤Ÿä¸vector ç»„åˆï¼Œå®ç°æ¨¡æ¿å®ä¾‹åŒ–&#13;
    typename std::vector&lt;T&gt;;&#13;
};&#13;
```&#13;
&#13;
- ç»„åˆçº¦æŸ **éœ€è¦å¤§æ‹¬å·æ‹¬èµ·æ¥**&#13;
```cpp&#13;
template &lt;typename T&gt;&#13;
concept C3 = requires(T t1, T t2) {&#13;
    // è¡¨è¾¾å¼ä¸èƒ½æœ‰å¼‚å¸¸&#13;
    { t1 = std::move(t2) } noexcept;&#13;
&#13;
    // è¦æ±‚æ¥å£è¿”å›ç±»å‹ä¸Tä¸€è‡´&#13;
    { t1.get_info() } -&gt; std::same_as&lt;T&gt;;&#13;
&#13;
    // è¦æ±‚æ¥å£è¿”å›ç±»å‹èƒ½å¤Ÿè½¬æ¢æˆfloat&#13;
    { t1.get_unit() } -&gt; std::convertible_to&lt;float&gt;;&#13;
};&#13;
&#13;
```&#13;
&#13;
- åµŒå¥—çº¦æŸ &#13;
```cpp&#13;
template &lt;typename T&gt;&#13;
concept C3 = requires {&#13;
    requires sizeof(T) &gt; 4;&#13;
};&#13;
```&#13;
&#13;
## `requires` å­å¥&#13;
&#13;
&gt; ç”¨äºåˆ¤æ–­æ‰€çº¦æŸçš„ç±»å‹åœ¨ä¸Šä¸‹æ–‡ä¸­ æ˜¯å¦å¯è¡Œ&#13;
&#13;
**ä¸Šä¸‹æ–‡** æ„Ÿè§‰æ˜¯åºŸè¯ï¼Œconcept ä¸å°±æ˜¯ä¸ºäº†ç®€åŒ–æ¨¡æ¿ç¼–ç¨‹ä¹ˆï¼Œè‚¯å®šåªèƒ½åœ¨æ¨¡æ¿ç¼–ç¨‹ä¸­å­˜åœ¨ &#13;
&#13;
1. å‡½æ•°æ¨¡æ¿&#13;
2. æ¨¡æ¿ç±» &#13;
3. æ¨¡æ¿ç±»çš„æˆå‘˜å‡½æ•° &#13;
&#13;
```cpp&#13;
// è¿™é‡Œæ˜¯ require å­å¥(åŒºåˆ«ä¸require è¡¨è¾¾å¼)&#13;
template &lt;typename T&gt;&#13;
    requires std::is_integral_v&lt;T&gt;&#13;
auto add(T t1, T t2) -&gt; T {&#13;
    return t1 + t2;&#13;
}&#13;
&#13;
// ç¼–è¯‘æˆåŠŸ&#13;
add(1, 2);&#13;
//  note: candidate template ignored: constraints not satisfied [with T = double]&#13;
//  note: because 'std::is_integral_v&lt;double&gt;' evaluated to false&#13;
// add(1.2, 2.2);&#13;
```&#13;
&#13;
## `concepts` header&#13;
&#13;
```cpp&#13;
&#13;
// æƒ³åŒç±»&#13;
template &lt;typename T, typename U&gt;&#13;
concept same_as = std::is_same_v&lt;T, U&gt;;&#13;
&#13;
// æ˜¯å¦æ˜¯æ´¾ç”Ÿå…³ç³» &#13;
template &lt;typename Base, typename Derived&gt;&#13;
concept derived_from = std::is_base_of_v&lt;Base, Derived&gt; &amp;&amp; std::is_convertible_v&lt;std::add_cv_t&lt;Derived *&gt;, std::add_cv_t&lt;Base *&gt;&gt;;&#13;
&#13;
// æ˜¯å¦å¯è½¬æ¢&#13;
template &lt;typename F, typename T&gt;&#13;
concept convertible_to = std::is_convertible_v&lt;F, T&gt; &amp;&amp; requires(std::add_rvalue_reference_t&lt;F&gt; (&amp;f)()) { static_cast&lt;T&gt;(f()); };&#13;
&#13;
```ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/9.html</guid><pubDate>Sat, 18 Nov 2023 11:51:47 +0000</pubDate></item><item><title>è™šæ‹Ÿæœºä½¿ç”¨å®¿ä¸»æœºä»£ç†</title><link>https://0x1042.github.io//post/8.html</link><description># mac è™šæ‹Ÿæœºä½¿ç”¨ä»£ç† &#13;
&#13;
- [mac è™šæ‹Ÿæœºä½¿ç”¨ä»£ç†](#mac-è™šæ‹Ÿæœºä½¿ç”¨ä»£ç†)&#13;
  - [å®‰è£…`gost`](#å®‰è£…gost)&#13;
  - [æ‰§è¡Œgost](#æ‰§è¡Œgost)&#13;
  - [è™šæ‹Ÿæœºé…ç½®](#è™šæ‹Ÿæœºé…ç½®)&#13;
&#13;
## å®‰è£…`gost`&#13;
&#13;
```shell&#13;
# å®‰è£…gost &#13;
&#13;
git clone https://github.com/go-gost/gost.git&#13;
cd gost/cmd/gost&#13;
go build&#13;
```&#13;
&#13;
## æ‰§è¡Œgost&#13;
&#13;
```shell&#13;
# å®¿ä¸»æœºä¾§åœ¨8080ç«¯å£çš„HTTPä»£ç†æœåŠ¡ï¼Œä½¿ç”¨æœ¬åœ°çš„1087ç«¯å£åšä¸ºä¸Šçº§ä»£ç†è¿›è¡Œè½¬å‘&#13;
./gost -L http://:8080 -F http://127.0.0.1:1087&#13;
```&#13;
&#13;
## è™šæ‹Ÿæœºé…ç½®&#13;
&#13;
```shell&#13;
&#13;
# shell&#13;
export https_proxy=http://10.0.0.67:8080 http_proxy=http://10.0.0.67:8080&#13;
# git &#13;
git config --global http.proxy 'http://10.0.0.67:8080'&#13;
```ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/8.html</guid><pubDate>Sat, 18 Nov 2023 08:46:24 +0000</pubDate></item><item><title>GDB ä½¿ç”¨ </title><link>https://0x1042.github.io//post/7.html</link><description>&#13;
- [GDB ä½¿ç”¨](#gdb-ä½¿ç”¨)&#13;
  - [èƒŒæ™¯](#èƒŒæ™¯)&#13;
  - [GDB dumpçº¿ç¨‹æ ˆ](#gdb-dumpçº¿ç¨‹æ ˆ)&#13;
  - [æ‰¾åˆ°è´Ÿè½½é«˜çš„çº¿ç¨‹](#æ‰¾åˆ°è´Ÿè½½é«˜çš„çº¿ç¨‹)&#13;
  - [å¯»æ‰¾å¯¹åº”çš„è¡Œå·](#å¯»æ‰¾å¯¹åº”çš„è¡Œå·)&#13;
&#13;
&#13;
## èƒŒæ™¯&#13;
&#13;
&gt; çº¿ä¸Šæµé‡æ²¡å˜ï¼Œä½†æ˜¯å‡ºç°ç¬æ—¶è´Ÿè½½å‘ˆç›´çº¿ä¸Šæ¶¨ï¼Œ1ï½2åˆ†é’Ÿæ•´ä¸ªæœåŠ¡ä¸å¯ç”¨ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/7.html</guid><pubDate>Fri, 17 Nov 2023 12:57:31 +0000</pubDate></item><item><title>ä¸‰ã€ç¼–è¯‘æ—¶å¤šæ€</title><link>https://0x1042.github.io//post/6.html</link><description># ç¼–è¯‘æ—¶å¤šæ€&#13;
&#13;
- [ç¼–è¯‘æ—¶å¤šæ€](#ç¼–è¯‘æ—¶å¤šæ€)&#13;
- [type traits ç±»å‹èƒå–](#type-traits-ç±»å‹èƒå–)&#13;
  - [è·å–ç±»å‹å±æ€§](#è·å–ç±»å‹å±æ€§)&#13;
  - [ç±»å‹å˜æ¢](#ç±»å‹å˜æ¢)&#13;
  - [æ ‡ç­¾åˆ†å‘](#æ ‡ç­¾åˆ†å‘)&#13;
  - [è¿­ä»£å™¨](#è¿­ä»£å™¨)&#13;
  - [`if constexpr`](#if-constexpr)&#13;
  - [`void_t` å…ƒå‡½æ•°](#void_t-å…ƒå‡½æ•°)&#13;
- [CTRTP å¥‡å¼‚é€’å½’æ¨¡ç‰ˆæ¨¡å¼](#ctrtp-å¥‡å¼‚é€’å½’æ¨¡ç‰ˆæ¨¡å¼)&#13;
  - [ä»£ç å¤ç”¨](#ä»£ç å¤ç”¨)&#13;
  - [é™æ€ç»‘å®š](#é™æ€ç»‘å®š)&#13;
  - [`enable_shared_from_this`](#enable_shared_from_this)&#13;
&#13;
&#13;
# type traits ç±»å‹èƒå–&#13;
&#13;
&gt; c++ é€šè¿‡æ¨¡ç‰ˆå®ç°æ³›å‹ç¼–ç¨‹ï¼Œä»è€Œå‡è½»è¿è¡Œæ—¶å¼€é”€ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/6.html</guid><pubDate>Sun, 12 Nov 2023 08:40:02 +0000</pubDate></item><item><title>äºŒã€c++ä¸­çš„ç±»å‹æ¨å¯¼</title><link>https://0x1042.github.io//post/5.html</link><description>- [ç±»å‹æ¨å¯¼](#ç±»å‹æ¨å¯¼)&#13;
- [`auto`](#auto)&#13;
- [`decltype`](#decltype)&#13;
  - [ä¸å¸¦æ‹¬å·(è·å–çš„æ˜¯æ ‡è¯†ç¬¦ å®šä¹‰æ—¶çš„ç±»å‹)](#ä¸å¸¦æ‹¬å·è·å–çš„æ˜¯æ ‡è¯†ç¬¦-å®šä¹‰æ—¶çš„ç±»å‹)&#13;
  - [å¸¦æ‹¬å· è·å–è¡¨è¾¾å¼çš„å€¼ç±»åˆ«](#å¸¦æ‹¬å·-è·å–è¡¨è¾¾å¼çš„å€¼ç±»åˆ«)&#13;
- [`decltype(auto)`](#decltypeauto)&#13;
- [`CTAD` ç±»æ¨¡æ¿å‚æ•°æ¨å¯¼](#ctad-ç±»æ¨¡æ¿å‚æ•°æ¨å¯¼)&#13;
&#13;
# ç±»å‹æ¨å¯¼ &#13;
&#13;
# `auto`&#13;
&#13;
**auto æ˜¯å€¼è¯­ä¹‰ï¼Œå³é€šè¿‡ç§»åŠ¨/æ‹·è´æ„é€ ï¼Œä¸ä¼šä¿ç•™cvå±æ€§ï¼Œå¦‚æœéœ€è¦ä¿ç•™cvå±æ€§ï¼Œéœ€è¦æ˜¾å¼æŒ‡å®š**&#13;
&#13;
```cpp&#13;
class Cat {};&#13;
&#13;
auto get_cat() -&gt; Cat *;&#13;
&#13;
auto get_const_cat() -&gt; const Cat *;&#13;
&#13;
&#13;
Cat cat{};&#13;
Cat * cat1 = &amp;cat;&#13;
const Cat * cat2 = &amp;cat;&#13;
&#13;
Cat &amp; lr_cat = cat;&#13;
const Cat &amp; ltc_cat = cat;&#13;
Cat&amp;&amp; rr_cat = Cat{};&#13;
```&#13;
&#13;
| è¡¨è¾¾å¼                         | autoæ¨å¯¼çš„ç±»å‹ |&#13;
| ------------------------------ | -------------- |&#13;
| `auto ccat1 = cat`             | `Cat`          |&#13;
| `auto ccat2 = cat1`            | `Cat*`         |&#13;
| `auto ccat3 = cat2`            | `const Cat*`   |&#13;
| `auto ccat4 = get_cat()`       | `Cat*`         |&#13;
| `auto ccat5 = get_const_cat()` | `const Cat*`   |&#13;
| `auto ccat6 = lr_cat`          | `Cat`          |&#13;
| `auto ccat7 = ltc_cat`         | `Cat`          |&#13;
| `auto ccat8 = rr_cat`          | `Cat`          |&#13;
| `auto &amp; ccat9 = lr_cat`        | `Cat&amp;`         |&#13;
| `const auto &amp; ccat10 = lr_cat` | `const Cat&amp;`   |&#13;
| `auto &amp; ccat11 = ltc_cat`      | `const Cat&amp;`   |&#13;
| `auto &amp;&amp; ccat12 = cat`         | `Cat&amp;`         |&#13;
| `auto &amp;&amp; ccat13 = Cat{}`       | `Cat&amp;&amp;`        |&#13;
&#13;
&#13;
# `decltype`&#13;
&#13;
&gt; ä½œç”¨ï¼šè·å– æ ‡è¯†ç¬¦è¢«å®šä¹‰æ—¶çš„ç±»å‹æˆ–è€… æ•´ä½“ä½œä¸º è¡¨è¾¾å¼ æ—¶çš„å€¼ç±»åˆ«&#13;
&#13;
- å‚æ•°å¸¦æ‹¬å· decltype((T))ï¼Œè·å–ä½œä¸ºè¡¨è¾¾å¼æ—¶çš„ å€¼ç±»åˆ«&#13;
- å‚æ•°ä¸å¸¦æ‹¬å· decltype(T), è·å–æ ‡è¯†ç¬¦ å®šä¹‰æ—¶çš„ç±»å‹ &#13;
&#13;
```cpp&#13;
class Student {&#13;
public:&#13;
    uint32_t id{0};&#13;
    std::string name;&#13;
};&#13;
&#13;
inline void test_decltype() {&#13;
    Student student;&#13;
    Student * st_ptr = &amp;student;&#13;
    const Student * st_cptr = &amp;student;&#13;
    Student &amp; st_ref = student;&#13;
    Student &amp;&amp; st_tmp = {};&#13;
}&#13;
```&#13;
&#13;
## ä¸å¸¦æ‹¬å·(è·å–çš„æ˜¯æ ‡è¯†ç¬¦ å®šä¹‰æ—¶çš„ç±»å‹)&#13;
&#13;
| è¡¨è¾¾å¼                                            | ç±»å‹             |&#13;
| ------------------------------------------------- | ---------------- |&#13;
| `using T1 = decltype(student)`                    | `Student`        |&#13;
| `using T2 = decltype(st_ptr)`                     | `Student*`       |&#13;
| `using T3 = decltype(st_cptr)`                    | `const Student*` |&#13;
| `using T4 = decltype(st_ref)`                     | `Student&amp;`       |&#13;
| `using T5 = decltype(st_tmp)`                     | `Student&amp;&amp;`      |&#13;
| `using T6 = decltype(student.id)`                 | `uint32_t`       |&#13;
| `using T7 = decltype(Student{1024, 'å¼ ä¸‰'}.name)` | `std::string`    |&#13;
&#13;
## å¸¦æ‹¬å· è·å–è¡¨è¾¾å¼çš„å€¼ç±»åˆ«&#13;
&#13;
| è¡¨è¾¾å¼                                              | ç±»å‹               |&#13;
| --------------------------------------------------- | ------------------ |&#13;
| `using T1 = decltype((student))`                    | `Student&amp;`         |&#13;
| `using T2 = decltype((st_ptr))`                     | `Student* &amp;`       |&#13;
| `using T3 = decltype((st_cptr))`                    | `const Student* &amp;` |&#13;
| `using T4 = decltype((st_ref))`                     | `Student&amp;`         |&#13;
| `using T5 = decltype((st_tmp))`                     | `Student&amp;`         |&#13;
| `using T6 = decltype((student.id))`                 | `uint32_t&amp;`        |&#13;
| `using T7 = decltype((Student{1024, 'å¼ ä¸‰'}))`      | `Student`          |&#13;
| `using T8 = decltype((Student{1024, 'å¼ ä¸‰'}.name))` | `std::string&amp;&amp;`    |&#13;
| `using T9 = decltype((++student.id))`               | `uint32_t&amp;`        |&#13;
| `using T10 = decltype((student.id++))`              | `uint32_t`         |&#13;
&#13;
- å¦‚æœè¡¨è¾¾å¼æ˜¯å·¦å€¼ï¼Œé‚£ä¹ˆ `decltype((exp))` å°±æ˜¯å·¦å€¼å¼•ç”¨ï¼ˆT1-&gt;T6ï¼‰&#13;
- `st_tmp`çš„ç±»å‹æ˜¯ å³å€¼å¼•ç”¨ï¼Œä½†æ˜¯ä½œä¸ºè¡¨è¾¾å¼ï¼Œå¯ä»¥è¢«å–åœ°å€ï¼Œæ‰€ä»¥æ˜¯å·¦å€¼å¼•ç”¨&#13;
- `T7` åŸå§‹è¡¨è¾¾å¼æ˜¯ä¸€ä¸ªçº¯å³å€¼ï¼Œ`decltype((exp))` æ˜¯å³å€¼ï¼ˆä¸å¸¦å¼•ç”¨ï¼‰&#13;
- `T8` æ˜¯ä¸€ä¸ªå°†äº¡å€¼&#13;
- `T9` ++xä½œä¸ºè¡¨è¾¾å¼æ˜¯å·¦å€¼&#13;
- `T10` x++ä½œä¸ºè¡¨è¾¾å¼æ˜¯å³å€¼&#13;
&#13;
# `decltype(auto)`&#13;
&#13;
&gt; é»˜è®¤ä½¿ç”¨`auto`æ—¶ï¼Œä¸¢å¤±äº†å¼•ç”¨æ€§å’Œ`cv`å±æ€§ï¼Œè‹¥æŒ‡æ˜äº† `const`å±æ€§ï¼Œåˆ™å¯¼è‡´ç»“æœå§‹ç»ˆä¸º`const`ï¼Œè‹¥é‡‡ç”¨å¼•ç”¨ï¼Œåˆ™éœ€è¦æ˜¾ç¤ºæŒ‡å®š`auto&amp;` æˆ–è€… `auto&amp;&amp;`,è¿™åˆä¼šå¯¼è‡´åªèƒ½è¡¨ç°ä¸º å¼•ç”¨è¯­ä¹‰ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/5.html</guid><pubDate>Sat, 11 Nov 2023 14:48:08 +0000</pubDate></item><item><title>ä¸€ã€c++ä¸­çš„å€¼ç±»å‹</title><link>https://0x1042.github.io//post/4.html</link><description># å€¼ç±»åˆ« &#13;
&#13;
- [å€¼ç±»åˆ«](#å€¼ç±»åˆ«)&#13;
  - [å¦‚ä½•åŒºåˆ†å·¦å€¼å’Œå³å€¼](#å¦‚ä½•åŒºåˆ†å·¦å€¼å’Œå³å€¼)&#13;
  - [å‡½æ•°å‚æ•°åŒ¹é…](#å‡½æ•°å‚æ•°åŒ¹é…)&#13;
  - [å€¼ç±»å‹](#å€¼ç±»å‹)&#13;
  - [ä¸‡èƒ½å¼•ç”¨ **universal reference**](#ä¸‡èƒ½å¼•ç”¨-universal-reference)&#13;
  - [å¼•ç”¨æŠ˜å  **reference collapsing**](#å¼•ç”¨æŠ˜å -reference-collapsing)&#13;
  - [å®Œç¾è½¬å‘ **perfect forward**](#å®Œç¾è½¬å‘-perfect-forward)&#13;
&#13;
## å¦‚ä½•åŒºåˆ†å·¦å€¼å’Œå³å€¼&#13;
&#13;
```c++&#13;
void log(std::string_view message, std::source_location location) {&#13;
    std::clog &lt;&lt; 'file: ' &lt;&lt; location.file_name() &lt;&lt; '(' &lt;&lt; location.line() &lt;&lt; ':' &lt;&lt; location.column() &lt;&lt; ') `' &lt;&lt; location.function_name()&#13;
              &lt;&lt; '`: ' &lt;&lt; message &lt;&lt; '\n';&#13;
}&#13;
&#13;
void foo(int &amp; /*val*/) {&#13;
    log('foo1');&#13;
}&#13;
&#13;
void foo(int &amp;&amp; /*val*/) {&#13;
    log('foo2');&#13;
}&#13;
```&#13;
&#13;
```cpp&#13;
int &amp;&amp; value = 1024;&#13;
foo(value); // è°ƒç”¨çš„æ˜¯ void foo(int &amp;)&#13;
```&#13;
&#13;
- åŒ¿åçš„ä¸´æ—¶å¯¹è±¡æ˜¯å³å€¼ï¼Œå…·åçš„å³å€¼å¼•ç”¨å¯¹è±¡æ˜¯å·¦å€¼ &#13;
- å¦‚æœè¡¨è¾¾å¼å¯ä»¥å–åœ°å€ï¼Œåˆ™ä¸ºå·¦å€¼è¡¨è¾¾å¼ï¼Œå¦åˆ™ï¼Œä¸ºå³å€¼è¡¨è¾¾å¼&#13;
- è¡¨è¾¾å¼ value æ˜¯å…·åçš„å³å€¼å¼•ç”¨å¯¹è±¡ï¼Œvalue ä¹Ÿå¯ä»¥å–åœ°å€ï¼Œæ‰€ä»¥ è¡¨è¾¾å¼value æ˜¯ä¸€ä¸ªå·¦å€¼ï¼ŒåŒ¹é…ç¬¬ä¸€ä¸ªå‡½æ•°&#13;
&#13;
## å‡½æ•°å‚æ•°åŒ¹é…&#13;
&#13;
| å‚æ•°ç±»å‹      | è¯´æ˜                                     |&#13;
| ------------- | ---------------------------------------- |&#13;
| Value&amp;        | åªèƒ½åŒ¹é…å·¦å€¼è¡¨è¾¾å¼                       |&#13;
| Value&amp;&amp;       | åªèƒ½ç»‘å®šå³å€¼è¡¨è¾¾å¼ï¼ˆæ¨¡æ¿å‡½æ•°ä¸‹å•ç‹¬è®¨è®ºï¼‰ |&#13;
| const Value&amp;  | å¯ä»¥åŒ¹é…å·¦å€¼å’Œå³å€¼è¡¨è¾¾å¼                 |&#13;
| const Value&amp;&amp; | å®é™…ä¸ä½¿ç”¨                               |&#13;
&#13;
&#13;
## å€¼ç±»å‹ &#13;
&#13;
- æ³›å·¦å€¼ï¼š å·¦å€¼ å’Œ å°†äº¡å€¼&#13;
- å³å€¼ï¼šçº¯å³å€¼ å’Œ å°†äº¡å€¼&#13;
- `static_cast&lt;Value&amp;&amp;&gt;(value)` æ˜¯å°†äº¡å€¼ï¼Œå¸¸è§çš„å°†äº¡å€¼æ˜¯ å‡½æ•°çš„è¿”å›å€¼ &#13;
![types](https://github.com/0x1042/0x1042.github.io/assets/7525242/0fae6f7f-bce8-41b6-ad2d-45cc312ec7b4)&#13;
&#13;
&#13;
## ä¸‡èƒ½å¼•ç”¨ **universal reference** &#13;
&#13;
&gt; å¦‚ä½•åŒºåˆ† Arg&amp;&amp; æ˜¯å³å€¼å¼•ç”¨è¿˜æ˜¯ä¸‡èƒ½å¼•ç”¨ï¼Ÿ&#13;
&#13;
- **å¦‚æœ Arg&amp;&amp; æ˜¯æ¨¡æ¿å‚æ•°æˆ–è€… autoï¼Œåˆ™æ˜¯ä¸‡èƒ½å¼•ç”¨ï¼Œã€Œæ—¢å¯ä»¥æ¥å—å·¦å€¼ï¼Œä¹Ÿå¯ä»¥æ¥å—å³å€¼ã€ï¼Œå¦åˆ™ä¸ºå³å€¼å¼•ç”¨**&#13;
- **ä¸‡èƒ½å¼•ç”¨åœ¨ç±»å‹æ¨å¯¼è¯­å¢ƒä¸‹ï¼Œå¯ä»¥ä¿ç•™ç±»å‹çš„cvé™å®šç¬¦ã€Œconstå’Œvolatileã€å’Œå€¼ç±»åˆ«**&#13;
&#13;
## å¼•ç”¨æŠ˜å  **reference collapsing**&#13;
&#13;
&gt; ä¸ºäº†è§£å†³ reference to reference çš„é—®é¢˜&#13;
&#13;
c++ ä¸­ä¸å…è®¸æŒ‡å‘å¼•ç”¨çš„å¼•ç”¨ï¼Œå¯¹äºæŒ‡å‘å¼•ç”¨çš„å¼•ç”¨ä¼šè¢«ç®€åŒ–ï¼Œæ¨å¯¼è§„åˆ™å¦‚ä¸‹ &#13;
&#13;
```cpp&#13;
template &lt;typename T&gt;&#13;
void Example(T &amp;&amp; input) {}&#13;
```&#13;
&#13;
- å‡½æ•°å½¢å‚æ˜¯å·¦å€¼ï¼ŒT&amp;ï¼Œä¼ å…¥çš„å®å‚æ˜¯å·¦å€¼ï¼Œå³input æ˜¯ `T&amp; &amp;`&#13;
- å‡½æ•°å½¢å‚æ˜¯å·¦å€¼ï¼ŒT&amp;ï¼Œä¼ å…¥çš„å®å‚æ˜¯å³å€¼ï¼Œå³input æ˜¯ `T&amp; &amp;&amp;`&#13;
- å‡½æ•°å½¢å‚æ˜¯å³å€¼ï¼ŒT&amp;&amp;ï¼Œä¼ å…¥çš„å®å‚æ˜¯å·¦å€¼ï¼Œå³input æ˜¯ `T&amp;&amp; &amp;`&#13;
- å‡½æ•°å½¢å‚æ˜¯å³å€¼ï¼ŒT&amp;&amp;ï¼Œä¼ å…¥çš„å®å‚æ˜¯å³å€¼ï¼Œå³input æ˜¯ `T&amp;&amp; &amp;&amp;`&#13;
&#13;
æ¨å¯¼è§„åˆ™æ˜¯ï¼š **ä»…å½“ä¸¤ä¸ªéƒ½æ˜¯å³å€¼å¼•ç”¨æ—¶ï¼Œæ¨å¯¼ä¸ºå³å€¼ï¼Œå…¶ä½™æƒ…å†µä¸ºå·¦å€¼**ï¼Œä¹Ÿå°±æ˜¯ `T&amp;&amp; &amp;&amp;`ä¸ºå³å€¼ï¼Œå…¶ä»–æƒ…å†µä¸ºå·¦å€¼ &#13;
&#13;
&#13;
## å®Œç¾è½¬å‘ **perfect forward** &#13;
&#13;
&gt; åœ¨ä¼ å‚çš„è¿‡ç¨‹ä¸­ï¼Œä¿ç•™å‚æ•°çš„åŸå§‹ç±»å‹ &#13;
&#13;
```cpp&#13;
void foo(int &amp; val);&#13;
void foo(int &amp;&amp; val);&#13;
&#13;
template &lt;typename T&gt; void call_foo(T &amp;&amp; t) {&#13;
    foo(std::forward&lt;T&gt;(t));&#13;
}&#13;
```&#13;
&#13;
å¦‚ä½•å®ç°çš„ï¼Ÿ&#13;
&#13;
```cpp&#13;
template &lt;class _Tp&gt;&#13;
_LIBCPP_NODISCARD_EXT inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR _Tp&amp;&amp;&#13;
forward(_LIBCPP_LIFETIMEBOUND __libcpp_remove_reference_t&lt;_Tp&gt;&amp; __t) _NOEXCEPT {&#13;
  return static_cast&lt;_Tp&amp;&amp;&gt;(__t);&#13;
}&#13;
&#13;
template &lt;class _Tp&gt;&#13;
_LIBCPP_NODISCARD_EXT inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR _Tp&amp;&amp;&#13;
forward(_LIBCPP_LIFETIMEBOUND __libcpp_remove_reference_t&lt;_Tp&gt;&amp;&amp; __t) _NOEXCEPT {&#13;
  static_assert(!is_lvalue_reference&lt;_Tp&gt;::value, 'cannot forward an rvalue as an lvalue');&#13;
  return static_cast&lt;_Tp&amp;&amp;&gt;(__t);&#13;
}&#13;
```&#13;
&#13;
- Tp æ˜¯å·¦å€¼ï¼Œ `static_cast&lt;_Tp&amp;&amp;&gt;(__t)` åæ˜¯ T&amp; &amp;&amp;ï¼ŒæŒ‰ç…§å¼•ç”¨æŠ˜å è§„åˆ™ï¼Œ`T&amp; &amp;&amp; -&gt; T&amp;`, Tpæ˜¯å·¦å€¼ &#13;
- Tp æ˜¯å³å€¼ï¼Œ `static_cast&lt;_Tp&amp;&amp;&gt;(__t)` åæ˜¯ T&amp;&amp; &amp;&amp;ï¼ŒæŒ‰ç…§å¼•ç”¨æŠ˜å è§„åˆ™ï¼Œ`T&amp;&amp; &amp;&amp; -&gt; T&amp;&amp;`, Tpæ˜¯å³å€¼ ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/4.html</guid><pubDate>Sat, 11 Nov 2023 08:48:15 +0000</pubDate></item><item><title>struct ä½¿ç”¨ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨</title><link>https://0x1042.github.io//post/3.html</link><description>```rust&#13;
#[derive(Debug)]&#13;
struct Sheep&lt;'c, 'd&gt; {&#13;
    age: &amp;'c u32,&#13;
    name: &amp;'d str,&#13;
}&#13;
&#13;
impl&lt;'c, 'd&gt; Sheep&lt;'c, 'd&gt; {&#13;
    /// Returns the get age of this [`Sheep`].&#13;
    pub fn get_age(&amp;self) -&gt; u32 {&#13;
        *self.age&#13;
    }&#13;
&#13;
    /// Returns the get name of this [`Sheep`].&#13;
    pub fn get_name(&amp;self) -&gt; String {&#13;
        self.name.to_owned()&#13;
    }&#13;
}&#13;
&#13;
#[cfg(test)]&#13;
mod tests {&#13;
    use super::Sheep;&#13;
    #[test]&#13;
    fn test_lt() {&#13;
        let age = 5;&#13;
        let name = 'dollor';&#13;
&#13;
        let sheep = Sheep {&#13;
            age: &amp;age,&#13;
            name: name,&#13;
        };&#13;
&#13;
        println!('name is {:?}', sheep.get_name());&#13;
        println!('age is {:?}', sheep.get_age());&#13;
&#13;
        println!('sheep :{:?}', sheep);&#13;
    }&#13;
}&#13;
```ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/3.html</guid><pubDate>Wed, 01 Nov 2023 16:55:48 +0000</pubDate></item><item><title>golangä¸­protobuf ååºåˆ—åŒ–æ€§èƒ½ä¼˜åŒ–</title><link>https://0x1042.github.io//post/2.html</link><description># èƒŒæ™¯&#13;
&#13;
çº¿ä¸Šæœ‰ä¸€äº›å…¬å…±ä½¿ç”¨çš„è¶…å¤§`protobuf`ï¼Œéƒ¨åˆ†å•**messageçš„fieldå¤§äº10000**ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/2.html</guid><pubDate>Sat, 28 Oct 2023 09:07:59 +0000</pubDate></item><item><title>c++ä¸­å®ç°golangä¸­çš„deferåŠŸèƒ½</title><link>https://0x1042.github.io//post/1.html</link><description># ä½¿ç”¨`folly`&#13;
&#13;
```c++&#13;
#include &lt;folly/ScopeGuard.h&gt;&#13;
&#13;
auto main() -&gt; int {&#13;
    std::string msg = 'exit...';&#13;
&#13;
    auto guard1 = folly::makeGuard([&amp;] { std::cerr &lt;&lt; 'from folly::makeGuard:' &lt;&lt; msg &lt;&lt; '\n'; });&#13;
&#13;
    std::cout &lt;&lt; 'Hello, World!' &lt;&lt; '\n';&#13;
    return 0;&#13;
}&#13;
&#13;
```&#13;
&#13;
# è‡ªå®šä¹‰å®ç°&#13;
&#13;
```c++&#13;
template &lt;typename Lambda&gt; &#13;
struct Defer : Lambda {&#13;
    ~Defer() { Lambda::operator()(); }&#13;
};&#13;
&#13;
template &lt;typename Lambda&gt; &#13;
Defer(Lambda) -&gt; Defer&lt;Lambda&gt;;&#13;
&#13;
auto main() -&gt; int {&#13;
    std::string msg = 'exit...';&#13;
&#13;
    Defer guard{[&amp;] { std::cerr &lt;&lt; msg &lt;&lt; '\n'; }};&#13;
&#13;
    std::cout &lt;&lt; 'Hello, World!' &lt;&lt; '\n';&#13;
    return 0;&#13;
}&#13;
```&#13;
ã€‚</description><guid isPermaLink="true">https://0x1042.github.io//post/1.html</guid><pubDate>Wed, 25 Oct 2023 15:57:21 +0000</pubDate></item></channel></rss>