<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Daily</title><link>http://0x1042.github.io</link><description>我自倾怀，君且随意。</description><copyright>Daily</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://raw.githubusercontent.com/0x1042/0x1042.github.io/master/synthwave_option_4.png</url><title>avatar</title><link>http://0x1042.github.io</link></image><lastBuildDate>Thu, 30 Nov 2023 16:54:46 +0000</lastBuildDate><managingEditor>Daily</managingEditor><pubDate>Thu, 30 Nov 2023 16:54:46 +0000</pubDate><ttl>60</ttl><webMaster>Daily</webMaster><item><title>c++中获取类定义的完整名字</title><link>http://0x1042.github.io/post/c%2B%2B-zhong-huo-qu-lei-ding-yi-de-wan-zheng-ming-zi.html</link><description># 说明&#13;
&#13;
&gt; 仅限于读取类定义&#13;
&#13;
```cpp&#13;
&#13;
#include &lt;memory&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
#include &lt;cxxabi.h&gt;&#13;
&#13;
template &lt;typename T&gt;&#13;
struct Name {&#13;
    Name() {&#13;
        std::unique_ptr&lt;char, decltype(free) *&gt; real_name(abi::__cxa_demangle(typeid(T).name(), nullptr, nullptr, nullptr), free);&#13;
        this-&gt;name = std::string(real_name.get());&#13;
    }&#13;
&#13;
    std::string name{};&#13;
};&#13;
&#13;
```&#13;
&#13;
测试 &#13;
&#13;
```cpp&#13;
namespace tests {&#13;
&#13;
namespace a::b::c {&#13;
    class A {};&#13;
} // namespace a::b::c&#13;
&#13;
namespace na {&#13;
    class B {};&#13;
} // namespace na&#13;
&#13;
namespace a::b::d {&#13;
    struct C {};&#13;
} // namespace a::b::d&#13;
&#13;
TEST_CASE("test name", "[name]") {&#13;
    // tests::a::b::c::A&#13;
    LOG(INFO) &lt;&lt; "infra::Name&lt;a::b::c::A&gt;().name:" &lt;&lt; infra::Name&lt;a::b::c::A&gt;().name;&#13;
    // tests::na::B&#13;
    LOG(INFO) &lt;&lt; "infra::Name&lt;na::B&gt;().name:" &lt;&lt; infra::Name&lt;na::B&gt;().name;&#13;
    // tests::a::b::d::C&#13;
    LOG(INFO) &lt;&lt; "infra::Name&lt;a::b::d::C&gt;().name:" &lt;&lt; infra::Name&lt;a::b::d::C&gt;().name;&#13;
}&#13;
} // namespace tests&#13;
```&#13;
。</description><guid isPermaLink="true">http://0x1042.github.io/post/c%2B%2B-zhong-huo-qu-lei-ding-yi-de-wan-zheng-ming-zi.html</guid><pubDate>Mon, 27 Nov 2023 15:28:20 +0000</pubDate></item><item><title>七、`constexpr` </title><link>http://0x1042.github.io/post/qi-%E3%80%81%60constexpr%60%20.html</link><description># constexpr 元编程&#13;
&#13;
- [constexpr 元编程](#constexpr-元编程)&#13;
  - [`constexpr` 变量](#constexpr-变量)&#13;
  - [`constinit` 初始化](#constinit-初始化)&#13;
  - [`constexpr` 函数](#constexpr-函数)&#13;
  - [`consteval` 函数](#consteval-函数)&#13;
- [`if constexpr`](#if-constexpr)&#13;
- [折叠表达式](#折叠表达式)&#13;
  - [右折叠](#右折叠)&#13;
  - [左折叠](#左折叠)&#13;
- [令人头大的`const`](#令人头大的const)&#13;
  - [`int const* ptr`](#int-const-ptr)&#13;
  - [`int * const ptr`](#int--const-ptr)&#13;
  - [终极CASE](#终极case)&#13;
&#13;
## `constexpr` 变量&#13;
&#13;
**与`const`变量的区别？**&#13;
&#13;
- `constexpr` 需要保证表达式可在编译时求值，否则会出现编译错误 &#13;
- `const` 表达式拥有常量性。</description><guid isPermaLink="true">http://0x1042.github.io/post/qi-%E3%80%81%60constexpr%60%20.html</guid><pubDate>Sun, 26 Nov 2023 10:44:29 +0000</pubDate></item><item><title>六、协程实现细节</title><link>http://0x1042.github.io/post/liu-%E3%80%81-xie-cheng-shi-xian-xi-jie.html</link><description># 协程实现细节&#13;
&#13;
- [协程实现细节](#协程实现细节)&#13;
- [协程的生命周期](#协程的生命周期)&#13;
  - [`promise_type`](#promise_type)&#13;
  - [协程类](#协程类)&#13;
  - [`coroutine_handle`](#coroutine_handle)&#13;
- [协程的调度](#协程的调度)&#13;
  - [`co_await`](#co_await)&#13;
  - [`co_yield`](#co_yield)&#13;
&#13;
&#13;
# 协程的生命周期 &#13;
&#13;
![call_routine](https://github.com/0x1042/0x1042.github.io/assets/7525242/f155fdff-fff4-49eb-88cb-500b55bd63ea)&#13;
&#13;
&#13;
1. 调用函数在**堆**上，创建协程帧(`coroutine_frame`)，里面包含了协程的`promise_type`,协程的实参，当前保存的局部变量，协程内部状态如挂起点. 由编译器实现&#13;
2. 创建协程帧之后，会返回给调用者`coroutine_handle`,也叫协程句柄，是控制协程的唯一入口，可以被传递到其他地方&#13;
3. 调用被调用协程，协程开始执行&#13;
4. 被调用协程执行到某个特定点，通过`co_await/co_yield` 将当前协程休眠，调用者恢复原本的执行流程继续执行剩余代码&#13;
5. 协程恢复者（比如另一个线程）通过`coroutine_handle`的恢复函数`resume` 恢复协程执行&#13;
6. 协程在恢复者上继续执行，结束后通过 `coroutine_handle` 销毁协程帧。</description><guid isPermaLink="true">http://0x1042.github.io/post/liu-%E3%80%81-xie-cheng-shi-xian-xi-jie.html</guid><pubDate>Sat, 18 Nov 2023 19:03:14 +0000</pubDate></item><item><title>五、协程基本使用</title><link>http://0x1042.github.io/post/wu-%E3%80%81-xie-cheng-ji-ben-shi-yong.html</link><description># 协程 ~~入门~~&#13;
&#13;
- [协程 ~~入门~~](#协程-入门)&#13;
  - [定义](#定义)&#13;
  - [基本原理](#基本原理)&#13;
    - [一、协程栈帧(编译器生成)](#一协程栈帧编译器生成)&#13;
    - [二、创建协程](#二创建协程)&#13;
    - [三、协程恢复(\_\_fibonacciResume)](#三协程恢复__fibonacciresume)&#13;
    - [四、销毁](#四销毁)&#13;
- [实现一个协程](#实现一个协程)&#13;
  - [定义 `Generator`](#定义-generator)&#13;
  - [定义 `promise_type`](#定义-promise_type)&#13;
  - [定义协程函数](#定义协程函数)&#13;
- [参考](#参考)&#13;
&#13;
&#13;
## 定义 &#13;
&#13;
c++20的协程定义是一个**可暂停、可恢复**的函数，具体到实现上，如果函数包含`co_await、co_yield、co_return` 关键字之一，就会被认为是协程&#13;
&#13;
![coroutine](https://github.com/0x1042/0x1042.github.io/assets/7525242/c2954b77-82a6-4a8f-b3a8-740adb8a9852)&#13;
&#13;
&#13;
- 暂停，即意味着需要保存函数执行过程中产生的上下文&#13;
- 恢复，调用方可以获取到这个协程在堆上的控制入口&#13;
&#13;
| 关键字      | 说明         |&#13;
| ----------- | ------------ |&#13;
| `co_await`  | 挂起         |&#13;
| `co_yield`  | 挂起并返回值 |&#13;
| `co_return` | 结束协程     |&#13;
&#13;
## 基本原理 &#13;
&#13;
参考 [C++20 Coroutine][1],[C++20协程][2].  核心是有编译器针对协程函数做patch，生成新的代码，区别于有栈协程，需要有对应的runtime来调度.&#13;
&#13;
可以在 [cppinsights.io](https://cppinsights.io) 上打开 `Show coroutine transformation` 选项，查看详细的细节，生成的结果中有注释，是一个近似的结果&#13;
&#13;
### 一、协程栈帧(编译器生成)&#13;
&#13;
```cpp&#13;
struct __fibonacciFrame&#13;
{&#13;
  void (*resume_fn)(__fibonacciFrame *);  // 协程恢复函数 &#13;
  void (*destroy_fn)(__fibonacciFrame *); // 协程销毁函数 &#13;
  std::coroutine_traits&lt;std::coroutine_handle&lt;promise&gt;, int&gt;::promise_type __promise; // 协程的promise_type&#13;
  int __suspend_index;&#13;
  bool __initial_await_suspend_called;&#13;
  int a;&#13;
  int i;&#13;
  int j;&#13;
  std::suspend_never __suspend_47_27;&#13;
  std::suspend_always __suspend_51_9;&#13;
  std::suspend_always __suspend_47_27_1;&#13;
};&#13;
```&#13;
&#13;
### 二、创建协程&#13;
&#13;
&gt; 调用方调用协程函数时(`fibonacci()`)，编译器会生成类似下面的代码, 这个函数的返回值时 `std::coroutine_handle&lt;promise&gt;`,也就是上面说的 协程的控制点(句柄)&#13;
&gt; 而这个返回值是通过 协程的 promise_type 对应的 get_return_object 函数获取&#13;
&#13;
```cpp&#13;
std::coroutine_handle&lt;promise&gt; fibonacci(int a)&#13;
{&#13;
  /* Allocate the frame including the promise */&#13;
  /* Note: The actual parameter new is __builtin_coro_size */&#13;
  __fibonacciFrame * __f = reinterpret_cast&lt;__fibonacciFrame *&gt;(operator new(sizeof(__fibonacciFrame)));&#13;
  __f-&gt;__suspend_index = 0;&#13;
  __f-&gt;__initial_await_suspend_called = false;&#13;
  __f-&gt;a = std::forward&lt;int&gt;(a);&#13;
  &#13;
  /* Construct the promise. */&#13;
  new (&amp;__f-&gt;__promise)std::coroutine_traits&lt;std::coroutine_handle&lt;promise&gt;, int&gt;::promise_type{__f-&gt;a};&#13;
  &#13;
  /* Forward declare the resume and destroy function. */&#13;
  void __fibonacciResume(__fibonacciFrame * __f);&#13;
  void __fibonacciDestroy(__fibonacciFrame * __f);&#13;
  &#13;
  /* Assign the resume and destroy function pointers. */&#13;
  __f-&gt;resume_fn = &amp;__fibonacciResume;&#13;
  __f-&gt;destroy_fn = &amp;__fibonacciDestroy;&#13;
  &#13;
  /* Call the made up function with the coroutine body for initial suspend.&#13;
     This function will be called subsequently by coroutine_handle&lt;&gt;::resume()&#13;
     which calls __builtin_coro_resume(__handle_) */&#13;
  __fibonacciResume(__f);&#13;
  &#13;
  &#13;
  return __f-&gt;__promise.get_return_object();&#13;
}&#13;
```&#13;
&#13;
&#13;
### 三、协程恢复(__fibonacciResume)&#13;
&#13;
&gt; 这个是协程的核心执行逻辑，也就是编译器patch后的结果 &#13;
&gt; 核心是 调用协程的promise_type相关的方法  &#13;
&#13;
```cpp&#13;
/* This function invoked by coroutine_handle&lt;&gt;::resume() */&#13;
void __fibonacciResume(__fibonacciFrame * __f)&#13;
{&#13;
  try &#13;
  {&#13;
    /* Create a switch to get to the correct resume point */&#13;
    switch(__f-&gt;__suspend_index) {&#13;
      case 0: break;&#13;
      case 1: goto __resume_fibonacci_1;&#13;
      case 2: goto __resume_fibonacci_2;&#13;
    }&#13;
    &#13;
    /* co_await insights.cpp:47 */&#13;
    __f-&gt;__suspend_47_27 = __f-&gt;__promise.initial_suspend();&#13;
    if(!__f-&gt;__suspend_47_27.await_ready()) {&#13;
      __f-&gt;__suspend_47_27.await_suspend(std::coroutine_handle&lt;promise&gt;::from_address(static_cast&lt;void *&gt;(__f)).operator std::coroutine_handle&lt;void&gt;());&#13;
      __f-&gt;__suspend_index = 1;&#13;
      __f-&gt;__initial_await_suspend_called = true;&#13;
      return;&#13;
    } &#13;
    &#13;
    __resume_fibonacci_1:&#13;
    __f-&gt;__suspend_47_27.await_resume();&#13;
    __f-&gt;i = 1;&#13;
    __f-&gt;j = __f-&gt;a;&#13;
    while(1) {&#13;
      std::tie(__f-&gt;i, __f-&gt;j).operator=(std::make_pair(__f-&gt;j, __f-&gt;i + __f-&gt;j));&#13;
      &#13;
      /* co_yield insights.cpp:51 */&#13;
      __f-&gt;__suspend_51_9 = __f-&gt;__promise.yield_value(__f-&gt;j);&#13;
      if(!__f-&gt;__suspend_51_9.await_ready()) {&#13;
        __f-&gt;__suspend_51_9.await_suspend(std::coroutine_handle&lt;promise&gt;::from_address(static_cast&lt;void *&gt;(__f)).operator std::coroutine_handle&lt;void&gt;());&#13;
        __f-&gt;__suspend_index = 2;&#13;
        return;&#13;
      } &#13;
      &#13;
      __resume_fibonacci_2:&#13;
      __f-&gt;__suspend_51_9.await_resume();&#13;
    }&#13;
    &#13;
    goto __final_suspend;&#13;
  } catch(...) {&#13;
    if(!__f-&gt;__initial_await_suspend_called) {&#13;
      throw ;&#13;
    } &#13;
    &#13;
    __f-&gt;__promise.unhandled_exception();&#13;
  }&#13;
  &#13;
  __final_suspend:&#13;
  &#13;
  /* co_await insights.cpp:47 */&#13;
  __f-&gt;__suspend_47_27_1 = __f-&gt;__promise.final_suspend();&#13;
  if(!__f-&gt;__suspend_47_27_1.await_ready()) {&#13;
    __f-&gt;__suspend_47_27_1.await_suspend(std::coroutine_handle&lt;promise&gt;::from_address(static_cast&lt;void *&gt;(__f)).operator std::coroutine_handle&lt;void&gt;());&#13;
  } &#13;
  &#13;
  ;&#13;
}&#13;
```&#13;
&#13;
### 四、销毁 &#13;
&#13;
```cpp&#13;
/* This function invoked by coroutine_handle&lt;&gt;::destroy() */&#13;
void __fibonacciDestroy(__fibonacciFrame * __f)&#13;
{&#13;
  /* destroy all variables with dtors */&#13;
  __f-&gt;~__fibonacciFrame();&#13;
  /* Deallocating the coroutine frame */&#13;
  /* Note: The actual argument to delete is __builtin_coro_frame with the promise as parameter */&#13;
  operator delete(static_cast&lt;void *&gt;(__f));&#13;
}&#13;
```&#13;
&#13;
**从编译器生成的代码看，如果要自己实现协程，就需要自定义这个协程的promise_type**&#13;
&#13;
`promise_type 必须包含一下成员函数`&#13;
&#13;
```cpp&#13;
SOME_TYPE get_return_object();//用于得到协程函数开始执行的返回值&#13;
SOME_TYPE initial_suspend();//用于协程函数开始执行时执行暂停操作&#13;
void return_void();//协程函数内部co_return终止返回void时执行的操作（和下面return_value同时只能有一个存在）&#13;
void return_value(SOME_TYPE);//协程函数内部co_return终止返回非void值时执行的操作&#13;
SOME_TYPE final_suspend()noexcept;//用于协程函数结束执行时执行暂停操作&#13;
void unhandled_exception();//用于协程函数内部有未接住的异常时执行&#13;
auto ield_value();&#13;
```&#13;
&#13;
&#13;
# 实现一个协程 &#13;
&#13;
## 定义 `Generator`&#13;
&#13;
**约束范型的类型约束是无符号整数**&#13;
&#13;
```cpp&#13;
template &lt;typename T&gt;&#13;
concept integral = std::is_integral_v&lt;T&gt; &amp;&amp; !std::is_signed_v&lt;T&gt;;&#13;
&#13;
template &lt;integral T&gt;&#13;
struct FibPromise;&#13;
&#13;
template &lt;integral T&gt;&#13;
struct FibGenerator {&#13;
    using promise_type = FibPromise&lt;T&gt;;&#13;
&#13;
    std::coroutine_handle&lt;promise_type&gt; handler;&#13;
&#13;
    auto next() -&gt; int {&#13;
        handler.resume();&#13;
        return handler.promise().value;&#13;
    }&#13;
&#13;
    explicit FibGenerator(promise_type * p)&#13;
        : handler{std::coroutine_handle&lt;promise_type&gt;::from_promise(*p)} {&#13;
    }&#13;
&#13;
    ~FibGenerator() {&#13;
        handler.destroy();&#13;
    }&#13;
};&#13;
```&#13;
&#13;
## 定义 `promise_type`&#13;
&#13;
```cpp&#13;
template &lt;integral T&gt;&#13;
struct FibPromise {&#13;
    std::exception_ptr exception;&#13;
&#13;
    FibPromise() = default;&#13;
&#13;
    FibPromise(T val)&#13;
        : value(val) {&#13;
    }&#13;
&#13;
    FibGenerator&lt;T&gt; get_return_object() { return FibGenerator{this}; }&#13;
&#13;
    auto initial_suspend() noexcept -&gt; std::suspend_always { return {}; }&#13;
&#13;
    auto final_suspend() noexcept -&gt; std::suspend_always { return {}; }&#13;
&#13;
    auto yield_value(T val) -&gt; std::suspend_always {&#13;
        value = val;&#13;
        return {};&#13;
    }&#13;
&#13;
    auto return_value(T val) -&gt; std::suspend_always {&#13;
        value = val;&#13;
        return {};&#13;
    }&#13;
    // void return_void() {}&#13;
&#13;
    void unhandled_exception() { exception = std::current_exception(); }&#13;
&#13;
    T value;&#13;
};&#13;
```&#13;
&#13;
## 定义协程函数&#13;
&#13;
```cpp&#13;
inline FibGenerator&lt;uint32_t&gt; fib(uint32_t n) {&#13;
    uint32_t first = 0;&#13;
    uint32_t second = 1;&#13;
    while (n--) {&#13;
        co_yield second;&#13;
        const auto tmp = first;&#13;
        first = second;&#13;
        second += tmp;&#13;
    }&#13;
}&#13;
&#13;
&#13;
// 测试 &#13;
void test_fib() {&#13;
    auto gen = fib(10);&#13;
    for (int i = 0; i &lt; 10; i++) {&#13;
        std::clog &lt;&lt; gen.next() &lt;&lt; '\n';&#13;
    }&#13;
}&#13;
```&#13;
&#13;
# 参考 &#13;
&#13;
[1]: https://owent.net/2019/1904.html  "C++20 Coroutine"&#13;
[2]: https://z3475.work/post/c20-xie-cheng-mai-xiang-yi-bu-part1-zui-jian-dan-de-xie-cheng/  "[C++20协程]迈向异步 Part1-最简单的协程"&#13;
&#13;
&#13;
。</description><guid isPermaLink="true">http://0x1042.github.io/post/wu-%E3%80%81-xie-cheng-ji-ben-shi-yong.html</guid><pubDate>Sat, 18 Nov 2023 14:20:07 +0000</pubDate></item><item><title>四、concept</title><link>http://0x1042.github.io/post/si-%E3%80%81concept.html</link><description># concept&#13;
&#13;
- [concept](#concept)&#13;
  - [基本定义和使用](#基本定义和使用)&#13;
  - [约束表达式](#约束表达式)&#13;
  - [`requires` 表达式](#requires-表达式)&#13;
  - [`requires` 子句](#requires-子句)&#13;
  - [`concepts` header](#concepts-header)&#13;
&#13;
## 基本定义和使用&#13;
&#13;
- 基本定义&#13;
```cpp&#13;
// 语法格式&#13;
// template&lt;typename T&gt;&#13;
// concept concept_name = constraint-expression(约束表达式);&#13;
&#13;
template &lt;typename T&gt;&#13;
concept integral = std::is_integral_v&lt;T&gt;;&#13;
&#13;
template &lt;typename T&gt;&#13;
concept floating_point = std::is_floating_point_v&lt;T&gt;;&#13;
&#13;
template &lt;typename T&gt;&#13;
concept C = std::is_integral_v&lt;T&gt; || (sizeof(T) &gt; 1);&#13;
&#13;
template &lt;typename T, typename U&gt;&#13;
concept Derived = std::is_base_of_v&lt;U, T&gt;;&#13;
&#13;
```&#13;
&#13;
- 基本使用 **使用`concept_name` 替换 `typename`**&#13;
&#13;
```cpp&#13;
&#13;
// 定义 &#13;
class Base {&#13;
public:&#13;
    [[nodiscard]] auto getValue() const -&gt; int32_t { return value; }&#13;
&#13;
    explicit Base(const int32_t value)&#13;
        : value(value) {&#13;
    }&#13;
&#13;
private:&#13;
    int32_t value;&#13;
};&#13;
&#13;
template &lt;typename T&gt;&#13;
concept DerivedBase = std::is_base_of_v&lt;Base, T&gt;;&#13;
&#13;
// 使用concept_name 替换 typename&#13;
template &lt;DerivedBase T&gt;&#13;
auto doGetValue(const T &amp; t) -&gt; int32_t {&#13;
    return t.getValue();&#13;
}&#13;
&#13;
class DerivedClass : public Base {&#13;
public:&#13;
    explicit DerivedClass(int32_t value)&#13;
        : Base(value) {&#13;
    }&#13;
&#13;
    [[nodiscard]] auto getValue() const -&gt; int32_t { return 1024; }&#13;
};&#13;
```&#13;
&#13;
## 约束表达式&#13;
&#13;
- 合取式 conjunctions，逻辑与 &#13;
```cpp&#13;
template &lt;typename T&gt;&#13;
concept integral = std::is_integral_v&lt;T&gt;;&#13;
&#13;
template &lt;typename T&gt;&#13;
concept signed_int = integral&lt;T&gt; &amp;&amp; std::is_signed_v&lt;T&gt;;&#13;
&#13;
```&#13;
- 析取式 disjunctions，逻辑或&#13;
&#13;
```cpp&#13;
template &lt;typename T&gt;&#13;
concept integral = std::is_integral_v&lt;T&gt;;&#13;
&#13;
template &lt;typename T&gt;&#13;
concept floating_point = std::is_floating_point_v&lt;T&gt;;&#13;
&#13;
template &lt;typename T&gt;&#13;
concept number = integral&lt;T&gt; || floating_point&lt;T&gt;;&#13;
&#13;
```&#13;
- 原子约束 atomic constraints &#13;
&#13;
```cpp&#13;
```&#13;
&#13;
## `requires` 表达式&#13;
&#13;
&gt; 除了使用`type traits` 定义概念之外，也可以使用 `requires` 表达式来表达对模板参数及其对象的特征要求&#13;
&gt; 成员函数、自由函数、关联类型等&#13;
&#13;
- 基本语法 &#13;
&#13;
```cpp&#13;
&#13;
requires(可选参数列表) {&#13;
    表达式1&#13;
    表达式2&#13;
}&#13;
&#13;
```&#13;
&#13;
- 基本约束 &#13;
```cpp&#13;
template &lt;typename T&gt;&#13;
concept Machine = requires(T t)&#13;
{&#13;
    // 要求存在同名的成员函数&#13;
    t.powerup();&#13;
&#13;
    t.powerDown();&#13;
    // 要求存在成员变量name&#13;
    t.name;&#13;
    // 要求存在静态成员count&#13;
    T::count;&#13;
};&#13;
&#13;
template &lt;typename T&gt;&#13;
concept Animal = requires(T t1, T t2, T t3)&#13;
{&#13;
    // 要求存在 name 成员变量&#13;
    t1.name;&#13;
&#13;
    // 要求能够进行判等操作&#13;
    t1 == t2;&#13;
&#13;
    // 要求能够进行 加、乘操作&#13;
    t1 + t2 * t3;&#13;
};&#13;
&#13;
```&#13;
&#13;
- 类型约束 &#13;
```cpp&#13;
template &lt;typename T&gt;&#13;
concept C2 = requires&#13;
{&#13;
    // 要求存在类型成员 type&#13;
    typename T::type;&#13;
&#13;
    // 要求能够与vector 组合，实现模板实例化&#13;
    typename std::vector&lt;T&gt;;&#13;
};&#13;
```&#13;
&#13;
- 组合约束 **需要大括号括起来**&#13;
```cpp&#13;
template &lt;typename T&gt;&#13;
concept C3 = requires(T t1, T t2) {&#13;
    // 表达式不能有异常&#13;
    { t1 = std::move(t2) } noexcept;&#13;
&#13;
    // 要求接口返回类型与T一致&#13;
    { t1.get_info() } -&gt; std::same_as&lt;T&gt;;&#13;
&#13;
    // 要求接口返回类型能够转换成float&#13;
    { t1.get_unit() } -&gt; std::convertible_to&lt;float&gt;;&#13;
};&#13;
&#13;
```&#13;
&#13;
- 嵌套约束 &#13;
```cpp&#13;
template &lt;typename T&gt;&#13;
concept C3 = requires {&#13;
    requires sizeof(T) &gt; 4;&#13;
};&#13;
```&#13;
&#13;
## `requires` 子句&#13;
&#13;
&gt; 用于判断所约束的类型在上下文中 是否可行&#13;
&#13;
**上下文** 感觉是废话，concept 不就是为了简化模板编程么，肯定只能在模板编程中存在 &#13;
&#13;
1. 函数模板&#13;
2. 模板类 &#13;
3. 模板类的成员函数 &#13;
&#13;
```cpp&#13;
// 这里是 require 子句(区别与require 表达式)&#13;
template &lt;typename T&gt;&#13;
    requires std::is_integral_v&lt;T&gt;&#13;
auto add(T t1, T t2) -&gt; T {&#13;
    return t1 + t2;&#13;
}&#13;
&#13;
// 编译成功&#13;
add(1, 2);&#13;
//  note: candidate template ignored: constraints not satisfied [with T = double]&#13;
//  note: because 'std::is_integral_v&lt;double&gt;' evaluated to false&#13;
// add(1.2, 2.2);&#13;
```&#13;
&#13;
## `concepts` header&#13;
&#13;
```cpp&#13;
&#13;
// 想同类&#13;
template &lt;typename T, typename U&gt;&#13;
concept same_as = std::is_same_v&lt;T, U&gt;;&#13;
&#13;
// 是否是派生关系 &#13;
template &lt;typename Base, typename Derived&gt;&#13;
concept derived_from = std::is_base_of_v&lt;Base, Derived&gt; &amp;&amp; std::is_convertible_v&lt;std::add_cv_t&lt;Derived *&gt;, std::add_cv_t&lt;Base *&gt;&gt;;&#13;
&#13;
// 是否可转换&#13;
template &lt;typename F, typename T&gt;&#13;
concept convertible_to = std::is_convertible_v&lt;F, T&gt; &amp;&amp; requires(std::add_rvalue_reference_t&lt;F&gt; (&amp;f)()) { static_cast&lt;T&gt;(f()); };&#13;
&#13;
```。</description><guid isPermaLink="true">http://0x1042.github.io/post/si-%E3%80%81concept.html</guid><pubDate>Sat, 18 Nov 2023 11:51:47 +0000</pubDate></item><item><title>虚拟机使用宿主机代理</title><link>http://0x1042.github.io/post/xu-ni-ji-shi-yong-su-zhu-ji-dai-li.html</link><description># mac 虚拟机使用代理 &#13;
&#13;
- [mac 虚拟机使用代理](#mac-虚拟机使用代理)&#13;
  - [安装`gost`](#安装gost)&#13;
  - [执行gost](#执行gost)&#13;
  - [虚拟机配置](#虚拟机配置)&#13;
&#13;
## 安装`gost`&#13;
&#13;
```shell&#13;
# 安装gost &#13;
&#13;
git clone https://github.com/go-gost/gost.git&#13;
cd gost/cmd/gost&#13;
go build&#13;
```&#13;
&#13;
## 执行gost&#13;
&#13;
```shell&#13;
# 宿主机侧在8080端口的HTTP代理服务，使用本地的1087端口做为上级代理进行转发&#13;
./gost -L http://:8080 -F http://127.0.0.1:1087&#13;
```&#13;
&#13;
## 虚拟机配置&#13;
&#13;
```shell&#13;
&#13;
# shell&#13;
export https_proxy=http://10.0.0.67:8080 http_proxy=http://10.0.0.67:8080&#13;
# git &#13;
git config --global http.proxy 'http://10.0.0.67:8080'&#13;
```。</description><guid isPermaLink="true">http://0x1042.github.io/post/xu-ni-ji-shi-yong-su-zhu-ji-dai-li.html</guid><pubDate>Sat, 18 Nov 2023 08:46:24 +0000</pubDate></item><item><title>GDB 使用 </title><link>http://0x1042.github.io/post/GDB%20-shi-yong-%20.html</link><description>&#13;
- [GDB 使用](#gdb-使用)&#13;
  - [背景](#背景)&#13;
  - [GDB dump线程栈](#gdb-dump线程栈)&#13;
  - [找到负载高的线程](#找到负载高的线程)&#13;
  - [寻找对应的行号](#寻找对应的行号)&#13;
&#13;
&#13;
## 背景&#13;
&#13;
&gt; 线上流量没变，但是出现瞬时负载呈直线上涨，1～2分钟整个服务不可用。</description><guid isPermaLink="true">http://0x1042.github.io/post/GDB%20-shi-yong-%20.html</guid><pubDate>Fri, 17 Nov 2023 12:57:31 +0000</pubDate></item><item><title>三、编译时多态</title><link>http://0x1042.github.io/post/san-%E3%80%81-bian-yi-shi-duo-tai.html</link><description># 编译时多态&#13;
&#13;
- [编译时多态](#编译时多态)&#13;
- [type traits 类型萃取](#type-traits-类型萃取)&#13;
  - [获取类型属性](#获取类型属性)&#13;
  - [类型变换](#类型变换)&#13;
  - [标签分发](#标签分发)&#13;
  - [迭代器](#迭代器)&#13;
  - [`if constexpr`](#if-constexpr)&#13;
  - [`void_t` 元函数](#void_t-元函数)&#13;
- [CTRTP 奇异递归模版模式](#ctrtp-奇异递归模版模式)&#13;
  - [代码复用](#代码复用)&#13;
  - [静态绑定](#静态绑定)&#13;
  - [`enable_shared_from_this`](#enable_shared_from_this)&#13;
&#13;
&#13;
# type traits 类型萃取&#13;
&#13;
&gt; c++ 通过模版实现泛型编程，从而减轻运行时开销。</description><guid isPermaLink="true">http://0x1042.github.io/post/san-%E3%80%81-bian-yi-shi-duo-tai.html</guid><pubDate>Sun, 12 Nov 2023 08:40:02 +0000</pubDate></item><item><title>二、c++中的类型推导</title><link>http://0x1042.github.io/post/er-%E3%80%81c%2B%2B-zhong-de-lei-xing-tui-dao.html</link><description>- [类型推导](#类型推导)&#13;
- [`auto`](#auto)&#13;
- [`decltype`](#decltype)&#13;
  - [不带括号(获取的是标识符 定义时的类型)](#不带括号获取的是标识符-定义时的类型)&#13;
  - [带括号 获取表达式的值类别](#带括号-获取表达式的值类别)&#13;
- [`decltype(auto)`](#decltypeauto)&#13;
- [`CTAD` 类模板参数推导](#ctad-类模板参数推导)&#13;
&#13;
# 类型推导 &#13;
&#13;
# `auto`&#13;
&#13;
**auto 是值语义，即通过移动/拷贝构造，不会保留cv属性，如果需要保留cv属性，需要显式指定**&#13;
&#13;
```cpp&#13;
class Cat {};&#13;
&#13;
auto get_cat() -&gt; Cat *;&#13;
&#13;
auto get_const_cat() -&gt; const Cat *;&#13;
&#13;
&#13;
Cat cat{};&#13;
Cat * cat1 = &amp;cat;&#13;
const Cat * cat2 = &amp;cat;&#13;
&#13;
Cat &amp; lr_cat = cat;&#13;
const Cat &amp; ltc_cat = cat;&#13;
Cat&amp;&amp; rr_cat = Cat{};&#13;
```&#13;
&#13;
| 表达式                         | auto推导的类型 |&#13;
| ------------------------------ | -------------- |&#13;
| `auto ccat1 = cat`             | `Cat`          |&#13;
| `auto ccat2 = cat1`            | `Cat*`         |&#13;
| `auto ccat3 = cat2`            | `const Cat*`   |&#13;
| `auto ccat4 = get_cat()`       | `Cat*`         |&#13;
| `auto ccat5 = get_const_cat()` | `const Cat*`   |&#13;
| `auto ccat6 = lr_cat`          | `Cat`          |&#13;
| `auto ccat7 = ltc_cat`         | `Cat`          |&#13;
| `auto ccat8 = rr_cat`          | `Cat`          |&#13;
| `auto &amp; ccat9 = lr_cat`        | `Cat&amp;`         |&#13;
| `const auto &amp; ccat10 = lr_cat` | `const Cat&amp;`   |&#13;
| `auto &amp; ccat11 = ltc_cat`      | `const Cat&amp;`   |&#13;
| `auto &amp;&amp; ccat12 = cat`         | `Cat&amp;`         |&#13;
| `auto &amp;&amp; ccat13 = Cat{}`       | `Cat&amp;&amp;`        |&#13;
&#13;
&#13;
# `decltype`&#13;
&#13;
&gt; 作用：获取 标识符被定义时的类型或者 整体作为 表达式 时的值类别&#13;
&#13;
- 参数带括号 decltype((T))，获取作为表达式时的 值类别&#13;
- 参数不带括号 decltype(T), 获取标识符 定义时的类型 &#13;
&#13;
```cpp&#13;
class Student {&#13;
public:&#13;
    uint32_t id{0};&#13;
    std::string name;&#13;
};&#13;
&#13;
inline void test_decltype() {&#13;
    Student student;&#13;
    Student * st_ptr = &amp;student;&#13;
    const Student * st_cptr = &amp;student;&#13;
    Student &amp; st_ref = student;&#13;
    Student &amp;&amp; st_tmp = {};&#13;
}&#13;
```&#13;
&#13;
## 不带括号(获取的是标识符 定义时的类型)&#13;
&#13;
| 表达式                                            | 类型             |&#13;
| ------------------------------------------------- | ---------------- |&#13;
| `using T1 = decltype(student)`                    | `Student`        |&#13;
| `using T2 = decltype(st_ptr)`                     | `Student*`       |&#13;
| `using T3 = decltype(st_cptr)`                    | `const Student*` |&#13;
| `using T4 = decltype(st_ref)`                     | `Student&amp;`       |&#13;
| `using T5 = decltype(st_tmp)`                     | `Student&amp;&amp;`      |&#13;
| `using T6 = decltype(student.id)`                 | `uint32_t`       |&#13;
| `using T7 = decltype(Student{1024, "张三"}.name)` | `std::string`    |&#13;
&#13;
## 带括号 获取表达式的值类别&#13;
&#13;
| 表达式                                              | 类型               |&#13;
| --------------------------------------------------- | ------------------ |&#13;
| `using T1 = decltype((student))`                    | `Student&amp;`         |&#13;
| `using T2 = decltype((st_ptr))`                     | `Student* &amp;`       |&#13;
| `using T3 = decltype((st_cptr))`                    | `const Student* &amp;` |&#13;
| `using T4 = decltype((st_ref))`                     | `Student&amp;`         |&#13;
| `using T5 = decltype((st_tmp))`                     | `Student&amp;`         |&#13;
| `using T6 = decltype((student.id))`                 | `uint32_t&amp;`        |&#13;
| `using T7 = decltype((Student{1024, "张三"}))`      | `Student`          |&#13;
| `using T8 = decltype((Student{1024, "张三"}.name))` | `std::string&amp;&amp;`    |&#13;
| `using T9 = decltype((++student.id))`               | `uint32_t&amp;`        |&#13;
| `using T10 = decltype((student.id++))`              | `uint32_t`         |&#13;
&#13;
- 如果表达式是左值，那么 `decltype((exp))` 就是左值引用（T1-&gt;T6）&#13;
- `st_tmp`的类型是 右值引用，但是作为表达式，可以被取地址，所以是左值引用&#13;
- `T7` 原始表达式是一个纯右值，`decltype((exp))` 是右值（不带引用）&#13;
- `T8` 是一个将亡值&#13;
- `T9` ++x作为表达式是左值&#13;
- `T10` x++作为表达式是右值&#13;
&#13;
# `decltype(auto)`&#13;
&#13;
&gt; 默认使用`auto`时，丢失了引用性和`cv`属性，若指明了 `const`属性，则导致结果始终为`const`，若采用引用，则需要显示指定`auto&amp;` 或者 `auto&amp;&amp;`,这又会导致只能表现为 引用语义。</description><guid isPermaLink="true">http://0x1042.github.io/post/er-%E3%80%81c%2B%2B-zhong-de-lei-xing-tui-dao.html</guid><pubDate>Sat, 11 Nov 2023 14:48:08 +0000</pubDate></item><item><title>一、c++中的值类型</title><link>http://0x1042.github.io/post/yi-%E3%80%81c%2B%2B-zhong-de-zhi-lei-xing.html</link><description># 值类别 &#13;
&#13;
- [值类别](#值类别)&#13;
  - [如何区分左值和右值](#如何区分左值和右值)&#13;
  - [函数参数匹配](#函数参数匹配)&#13;
  - [值类型](#值类型)&#13;
  - [万能引用 **universal reference**](#万能引用-universal-reference)&#13;
  - [引用折叠 **reference collapsing**](#引用折叠-reference-collapsing)&#13;
  - [完美转发 **perfect forward**](#完美转发-perfect-forward)&#13;
&#13;
## 如何区分左值和右值&#13;
&#13;
```c++&#13;
void log(std::string_view message, std::source_location location) {&#13;
    std::clog &lt;&lt; "file: " &lt;&lt; location.file_name() &lt;&lt; '(' &lt;&lt; location.line() &lt;&lt; ':' &lt;&lt; location.column() &lt;&lt; ") `" &lt;&lt; location.function_name()&#13;
              &lt;&lt; "`: " &lt;&lt; message &lt;&lt; '\n';&#13;
}&#13;
&#13;
void foo(int &amp; /*val*/) {&#13;
    log("foo1");&#13;
}&#13;
&#13;
void foo(int &amp;&amp; /*val*/) {&#13;
    log("foo2");&#13;
}&#13;
```&#13;
&#13;
```cpp&#13;
int &amp;&amp; value = 1024;&#13;
foo(value); // 调用的是 void foo(int &amp;)&#13;
```&#13;
&#13;
- 匿名的临时对象是右值，具名的右值引用对象是左值 &#13;
- 如果表达式可以取地址，则为左值表达式，否则，为右值表达式&#13;
- 表达式 value 是具名的右值引用对象，value 也可以取地址，所以 表达式value 是一个左值，匹配第一个函数&#13;
&#13;
## 函数参数匹配&#13;
&#13;
| 参数类型      | 说明                                     |&#13;
| ------------- | ---------------------------------------- |&#13;
| Value&amp;        | 只能匹配左值表达式                       |&#13;
| Value&amp;&amp;       | 只能绑定右值表达式（模板函数下单独讨论） |&#13;
| const Value&amp;  | 可以匹配左值和右值表达式                 |&#13;
| const Value&amp;&amp; | 实际不使用                               |&#13;
&#13;
&#13;
## 值类型 &#13;
&#13;
- 泛左值： 左值 和 将亡值&#13;
- 右值：纯右值 和 将亡值&#13;
- `static_cast&lt;Value&amp;&amp;&gt;(value)` 是将亡值，常见的将亡值是 函数的返回值 &#13;
![types](https://github.com/0x1042/0x1042.github.io/assets/7525242/0fae6f7f-bce8-41b6-ad2d-45cc312ec7b4)&#13;
&#13;
&#13;
## 万能引用 **universal reference** &#13;
&#13;
&gt; 如何区分 Arg&amp;&amp; 是右值引用还是万能引用？&#13;
&#13;
- **如果 Arg&amp;&amp; 是模板参数或者 auto，则是万能引用，「既可以接受左值，也可以接受右值」，否则为右值引用**&#13;
- **万能引用在类型推导语境下，可以保留类型的cv限定符「const和volatile」和值类别**&#13;
&#13;
## 引用折叠 **reference collapsing**&#13;
&#13;
&gt; 为了解决 reference to reference 的问题&#13;
&#13;
c++ 中不允许指向引用的引用，对于指向引用的引用会被简化，推导规则如下 &#13;
&#13;
```cpp&#13;
template &lt;typename T&gt;&#13;
void Example(T &amp;&amp; input) {}&#13;
```&#13;
&#13;
- 函数形参是左值，T&amp;，传入的实参是左值，即input 是 `T&amp; &amp;`&#13;
- 函数形参是左值，T&amp;，传入的实参是右值，即input 是 `T&amp; &amp;&amp;`&#13;
- 函数形参是右值，T&amp;&amp;，传入的实参是左值，即input 是 `T&amp;&amp; &amp;`&#13;
- 函数形参是右值，T&amp;&amp;，传入的实参是右值，即input 是 `T&amp;&amp; &amp;&amp;`&#13;
&#13;
推导规则是： **仅当两个都是右值引用时，推导为右值，其余情况为左值**，也就是 `T&amp;&amp; &amp;&amp;`为右值，其他情况为左值 &#13;
&#13;
&#13;
## 完美转发 **perfect forward** &#13;
&#13;
&gt; 在传参的过程中，保留参数的原始类型 &#13;
&#13;
```cpp&#13;
void foo(int &amp; val);&#13;
void foo(int &amp;&amp; val);&#13;
&#13;
template &lt;typename T&gt; void call_foo(T &amp;&amp; t) {&#13;
    foo(std::forward&lt;T&gt;(t));&#13;
}&#13;
```&#13;
&#13;
如何实现的？&#13;
&#13;
```cpp&#13;
template &lt;class _Tp&gt;&#13;
_LIBCPP_NODISCARD_EXT inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR _Tp&amp;&amp;&#13;
forward(_LIBCPP_LIFETIMEBOUND __libcpp_remove_reference_t&lt;_Tp&gt;&amp; __t) _NOEXCEPT {&#13;
  return static_cast&lt;_Tp&amp;&amp;&gt;(__t);&#13;
}&#13;
&#13;
template &lt;class _Tp&gt;&#13;
_LIBCPP_NODISCARD_EXT inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR _Tp&amp;&amp;&#13;
forward(_LIBCPP_LIFETIMEBOUND __libcpp_remove_reference_t&lt;_Tp&gt;&amp;&amp; __t) _NOEXCEPT {&#13;
  static_assert(!is_lvalue_reference&lt;_Tp&gt;::value, "cannot forward an rvalue as an lvalue");&#13;
  return static_cast&lt;_Tp&amp;&amp;&gt;(__t);&#13;
}&#13;
```&#13;
&#13;
- Tp 是左值， `static_cast&lt;_Tp&amp;&amp;&gt;(__t)` 后是 T&amp; &amp;&amp;，按照引用折叠规则，`T&amp; &amp;&amp; -&gt; T&amp;`, Tp是左值 &#13;
- Tp 是右值， `static_cast&lt;_Tp&amp;&amp;&gt;(__t)` 后是 T&amp;&amp; &amp;&amp;，按照引用折叠规则，`T&amp;&amp; &amp;&amp; -&gt; T&amp;&amp;`, Tp是右值 。</description><guid isPermaLink="true">http://0x1042.github.io/post/yi-%E3%80%81c%2B%2B-zhong-de-zhi-lei-xing.html</guid><pubDate>Sat, 11 Nov 2023 08:48:15 +0000</pubDate></item><item><title>struct 使用生命周期标注</title><link>http://0x1042.github.io/post/struct%20-shi-yong-sheng-ming-zhou-qi-biao-zhu.html</link><description>```rust&#13;
#[derive(Debug)]&#13;
struct Sheep&lt;'c, 'd&gt; {&#13;
    age: &amp;'c u32,&#13;
    name: &amp;'d str,&#13;
}&#13;
&#13;
impl&lt;'c, 'd&gt; Sheep&lt;'c, 'd&gt; {&#13;
    /// Returns the get age of this [`Sheep`].&#13;
    pub fn get_age(&amp;self) -&gt; u32 {&#13;
        *self.age&#13;
    }&#13;
&#13;
    /// Returns the get name of this [`Sheep`].&#13;
    pub fn get_name(&amp;self) -&gt; String {&#13;
        self.name.to_owned()&#13;
    }&#13;
}&#13;
&#13;
#[cfg(test)]&#13;
mod tests {&#13;
    use super::Sheep;&#13;
    #[test]&#13;
    fn test_lt() {&#13;
        let age = 5;&#13;
        let name = "dollor";&#13;
&#13;
        let sheep = Sheep {&#13;
            age: &amp;age,&#13;
            name: name,&#13;
        };&#13;
&#13;
        println!("name is {:?}", sheep.get_name());&#13;
        println!("age is {:?}", sheep.get_age());&#13;
&#13;
        println!("sheep :{:?}", sheep);&#13;
    }&#13;
}&#13;
```。</description><guid isPermaLink="true">http://0x1042.github.io/post/struct%20-shi-yong-sheng-ming-zhou-qi-biao-zhu.html</guid><pubDate>Wed, 01 Nov 2023 16:55:48 +0000</pubDate></item><item><title>golang中protobuf 反序列化性能优化</title><link>http://0x1042.github.io/post/golang-zhong-protobuf%20-fan-xu-lie-hua-xing-neng-you-hua.html</link><description># 背景&#13;
&#13;
线上有一些公共使用的超大`protobuf`，部分单**message的field大于10000**。</description><guid isPermaLink="true">http://0x1042.github.io/post/golang-zhong-protobuf%20-fan-xu-lie-hua-xing-neng-you-hua.html</guid><pubDate>Sat, 28 Oct 2023 09:07:59 +0000</pubDate></item><item><title>c++中实现golang中的defer功能</title><link>http://0x1042.github.io/post/c%2B%2B-zhong-shi-xian-golang-zhong-de-defer-gong-neng.html</link><description># 使用`folly`&#13;
&#13;
```c++&#13;
#include &lt;folly/ScopeGuard.h&gt;&#13;
&#13;
auto main() -&gt; int {&#13;
    std::string msg = "exit...";&#13;
&#13;
    auto guard1 = folly::makeGuard([&amp;] { std::cerr &lt;&lt; "from folly::makeGuard:" &lt;&lt; msg &lt;&lt; '\n'; });&#13;
&#13;
    std::cout &lt;&lt; "Hello, World!" &lt;&lt; '\n';&#13;
    return 0;&#13;
}&#13;
&#13;
```&#13;
&#13;
# 自定义实现&#13;
&#13;
```c++&#13;
template &lt;typename Lambda&gt; &#13;
struct Defer : Lambda {&#13;
    ~Defer() { Lambda::operator()(); }&#13;
};&#13;
&#13;
template &lt;typename Lambda&gt; &#13;
Defer(Lambda) -&gt; Defer&lt;Lambda&gt;;&#13;
&#13;
auto main() -&gt; int {&#13;
    std::string msg = "exit...";&#13;
&#13;
    Defer guard{[&amp;] { std::cerr &lt;&lt; msg &lt;&lt; '\n'; }};&#13;
&#13;
    std::cout &lt;&lt; "Hello, World!" &lt;&lt; '\n';&#13;
    return 0;&#13;
}&#13;
```&#13;
。</description><guid isPermaLink="true">http://0x1042.github.io/post/c%2B%2B-zhong-shi-xian-golang-zhong-de-defer-gong-neng.html</guid><pubDate>Wed, 25 Oct 2023 15:57:21 +0000</pubDate></item></channel></rss>