<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Daily</title><link>http://0x1042.github.io</link><description>我自倾怀，君且随意。</description><copyright>Daily</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://raw.githubusercontent.com/0x1042/0x1042.github.io/master/synthwave_option_4.png</url><title>avatar</title><link>http://0x1042.github.io</link></image><lastBuildDate>Sat, 11 Nov 2023 14:48:30 +0000</lastBuildDate><managingEditor>Daily</managingEditor><pubDate>Sat, 11 Nov 2023 14:48:30 +0000</pubDate><ttl>60</ttl><webMaster>Daily</webMaster><item><title>二、c++中的类型推导</title><link>http://0x1042.github.io/post/er-%E3%80%81c%2B%2B-zhong-de-lei-xing-tui-dao.html</link><description>- [类型推导](#类型推导)&#13;
- [`auto`](#auto)&#13;
- [`decltype`](#decltype)&#13;
  - [不带括号(获取的是标识符 定义时的类型)](#不带括号获取的是标识符-定义时的类型)&#13;
  - [带括号 获取表达式的值类别](#带括号-获取表达式的值类别)&#13;
- [`decltype(auto)`](#decltypeauto)&#13;
- [`CTAD` 类模板参数推导](#ctad-类模板参数推导)&#13;
&#13;
# 类型推导 &#13;
&#13;
# `auto`&#13;
&#13;
**auto 是值语义，即通过移动/拷贝构造，不会保留cv属性，如果需要保留cv属性，需要显式指定**&#13;
&#13;
```cpp&#13;
class Cat {};&#13;
&#13;
auto get_cat() -&gt; Cat *;&#13;
&#13;
auto get_const_cat() -&gt; const Cat *;&#13;
&#13;
&#13;
Cat cat{};&#13;
Cat * cat1 = &amp;cat;&#13;
const Cat * cat2 = &amp;cat;&#13;
&#13;
Cat &amp; lr_cat = cat;&#13;
const Cat &amp; ltc_cat = cat;&#13;
Cat&amp;&amp; rr_cat = Cat{};&#13;
```&#13;
&#13;
| 表达式                         | auto推导的类型 |&#13;
| ------------------------------ | -------------- |&#13;
| `auto ccat1 = cat`             | `Cat`          |&#13;
| `auto ccat2 = cat1`            | `Cat*`         |&#13;
| `auto ccat3 = cat2`            | `const Cat*`   |&#13;
| `auto ccat4 = get_cat()`       | `Cat*`         |&#13;
| `auto ccat5 = get_const_cat()` | `const Cat*`   |&#13;
| `auto ccat6 = lr_cat`          | `Cat`          |&#13;
| `auto ccat7 = ltc_cat`         | `Cat`          |&#13;
| `auto ccat8 = rr_cat`          | `Cat`          |&#13;
| `auto &amp; ccat9 = lr_cat`        | `Cat&amp;`         |&#13;
| `const auto &amp; ccat10 = lr_cat` | `const Cat&amp;`   |&#13;
| `auto &amp; ccat11 = ltc_cat`      | `const Cat&amp;`   |&#13;
| `auto &amp;&amp; ccat12 = cat`         | `Cat&amp;`         |&#13;
| `auto &amp;&amp; ccat13 = Cat{}`       | `Cat&amp;&amp;`        |&#13;
&#13;
&#13;
# `decltype`&#13;
&#13;
&gt; 作用：获取 标识符被定义时的类型或者 整体作为 表达式 时的值类别&#13;
&#13;
- 参数带括号 decltype((T))，获取作为表达式时的 值类别&#13;
- 参数不带括号 decltype(T), 获取标识符 定义时的类型 &#13;
&#13;
```cpp&#13;
class Student {&#13;
public:&#13;
    uint32_t id{0};&#13;
    std::string name;&#13;
};&#13;
&#13;
inline void test_decltype() {&#13;
    Student student;&#13;
    Student * st_ptr = &amp;student;&#13;
    const Student * st_cptr = &amp;student;&#13;
    Student &amp; st_ref = student;&#13;
    Student &amp;&amp; st_tmp = {};&#13;
}&#13;
```&#13;
&#13;
## 不带括号(获取的是标识符 定义时的类型)&#13;
&#13;
| 表达式                                            | 类型             |&#13;
| ------------------------------------------------- | ---------------- |&#13;
| `using T1 = decltype(student)`                    | `Student`        |&#13;
| `using T2 = decltype(st_ptr)`                     | `Student*`       |&#13;
| `using T3 = decltype(st_cptr)`                    | `const Student*` |&#13;
| `using T4 = decltype(st_ref)`                     | `Student&amp;`       |&#13;
| `using T5 = decltype(st_tmp)`                     | `Student&amp;&amp;`      |&#13;
| `using T6 = decltype(student.id)`                 | `uint32_t`       |&#13;
| `using T7 = decltype(Student{1024, "张三"}.name)` | `std::string`    |&#13;
&#13;
## 带括号 获取表达式的值类别&#13;
&#13;
| 表达式                                              | 类型               |&#13;
| --------------------------------------------------- | ------------------ |&#13;
| `using T1 = decltype((student))`                    | `Student&amp;`         |&#13;
| `using T2 = decltype((st_ptr))`                     | `Student* &amp;`       |&#13;
| `using T3 = decltype((st_cptr))`                    | `const Student* &amp;` |&#13;
| `using T4 = decltype((st_ref))`                     | `Student&amp;`         |&#13;
| `using T5 = decltype((st_tmp))`                     | `Student&amp;`         |&#13;
| `using T6 = decltype((student.id))`                 | `uint32_t&amp;`        |&#13;
| `using T7 = decltype((Student{1024, "张三"}))`      | `Student`          |&#13;
| `using T8 = decltype((Student{1024, "张三"}.name))` | `std::string&amp;&amp;`    |&#13;
| `using T9 = decltype((++student.id))`               | `uint32_t&amp;`        |&#13;
| `using T10 = decltype((student.id++))`              | `uint32_t`         |&#13;
&#13;
- 如果表达式是左值，那么 `decltype((exp))` 就是左值引用（T1-&gt;T6）&#13;
- `st_tmp`的类型是 右值引用，但是作为表达式，可以被取地址，所以是左值引用&#13;
- `T7` 原始表达式是一个纯右值，`decltype((exp))` 是右值（不带引用）&#13;
- `T8` 是一个将亡值&#13;
- `T9` ++x作为表达式是左值&#13;
- `T10` x++作为表达式是右值&#13;
&#13;
# `decltype(auto)`&#13;
&#13;
&gt; 默认使用`auto`时，丢失了引用性和`cv`属性，若指明了 `const`属性，则导致结果始终为`const`，若采用引用，则需要显示指定`auto&amp;` 或者 `auto&amp;&amp;`,这又会导致只能表现为 引用语义。</description><guid isPermaLink="true">http://0x1042.github.io/post/er-%E3%80%81c%2B%2B-zhong-de-lei-xing-tui-dao.html</guid><pubDate>Sat, 11 Nov 2023 14:48:08 +0000</pubDate></item><item><title>一、c++中的值类型</title><link>http://0x1042.github.io/post/yi-%E3%80%81c%2B%2B-zhong-de-zhi-lei-xing.html</link><description># 值类别 &#13;
&#13;
- [值类别](#值类别)&#13;
  - [如何区分左值和右值](#如何区分左值和右值)&#13;
  - [函数参数匹配](#函数参数匹配)&#13;
  - [值类型](#值类型)&#13;
  - [万能引用 **universal reference**](#万能引用-universal-reference)&#13;
  - [引用折叠 **reference collapsing**](#引用折叠-reference-collapsing)&#13;
  - [完美转发 **perfect forward**](#完美转发-perfect-forward)&#13;
&#13;
## 如何区分左值和右值&#13;
&#13;
```c++&#13;
void log(std::string_view message, std::source_location location) {&#13;
    std::clog &lt;&lt; "file: " &lt;&lt; location.file_name() &lt;&lt; '(' &lt;&lt; location.line() &lt;&lt; ':' &lt;&lt; location.column() &lt;&lt; ") `" &lt;&lt; location.function_name()&#13;
              &lt;&lt; "`: " &lt;&lt; message &lt;&lt; '\n';&#13;
}&#13;
&#13;
void foo(int &amp; /*val*/) {&#13;
    log("foo1");&#13;
}&#13;
&#13;
void foo(int &amp;&amp; /*val*/) {&#13;
    log("foo2");&#13;
}&#13;
```&#13;
&#13;
```cpp&#13;
int &amp;&amp; value = 1024;&#13;
foo(value); // 调用的是 void foo(int &amp;)&#13;
```&#13;
&#13;
- 匿名的临时对象是右值，具名的右值引用对象是左值 &#13;
- 如果表达式可以取地址，则为左值表达式，否则，为右值表达式&#13;
- 表达式 value 是具名的右值引用对象，value 也可以取地址，所以 表达式value 是一个左值，匹配第一个函数&#13;
&#13;
## 函数参数匹配&#13;
&#13;
| 参数类型      | 说明                                     |&#13;
| ------------- | ---------------------------------------- |&#13;
| Value&amp;        | 只能匹配左值表达式                       |&#13;
| Value&amp;&amp;       | 只能绑定右值表达式（模板函数下单独讨论） |&#13;
| const Value&amp;  | 可以匹配左值和右值表达式                 |&#13;
| const Value&amp;&amp; | 实际不使用                               |&#13;
&#13;
&#13;
## 值类型 &#13;
&#13;
- 泛左值： 左值 和 将亡值&#13;
- 右值：纯右值 和 将亡值&#13;
- `static_cast&lt;Value&amp;&amp;&gt;(value)` 是将亡值，常见的将亡值是 函数的返回值 &#13;
![types](https://github.com/0x1042/0x1042.github.io/assets/7525242/0fae6f7f-bce8-41b6-ad2d-45cc312ec7b4)&#13;
&#13;
&#13;
## 万能引用 **universal reference** &#13;
&#13;
&gt; 如何区分 Arg&amp;&amp; 是右值引用还是万能引用？&#13;
&#13;
- **如果 Arg&amp;&amp; 是模板参数或者 auto，则是万能引用，「既可以接受左值，也可以接受右值」，否则为右值引用**&#13;
- **万能引用在类型推导语境下，可以保留类型的cv限定符「const和volatile」和值类别**&#13;
&#13;
## 引用折叠 **reference collapsing**&#13;
&#13;
&gt; 为了解决 reference to reference 的问题&#13;
&#13;
c++ 中不允许指向引用的引用，对于指向引用的引用会被简化，推导规则如下 &#13;
&#13;
```cpp&#13;
template &lt;typename T&gt;&#13;
void Example(T &amp;&amp; input) {}&#13;
```&#13;
&#13;
- 函数形参是左值，T&amp;，传入的实参是左值，即input 是 `T&amp; &amp;`&#13;
- 函数形参是左值，T&amp;，传入的实参是右值，即input 是 `T&amp; &amp;&amp;`&#13;
- 函数形参是右值，T&amp;&amp;，传入的实参是左值，即input 是 `T&amp;&amp; &amp;`&#13;
- 函数形参是右值，T&amp;&amp;，传入的实参是右值，即input 是 `T&amp;&amp; &amp;&amp;`&#13;
&#13;
推导规则是： **仅当两个都是右值引用时，推导为右值，其余情况为左值**，也就是 `T&amp;&amp; &amp;&amp;`为右值，其他情况为左值 &#13;
&#13;
&#13;
## 完美转发 **perfect forward** &#13;
&#13;
&gt; 在传参的过程中，保留参数的原始类型 &#13;
&#13;
```cpp&#13;
void foo(int &amp; val);&#13;
void foo(int &amp;&amp; val);&#13;
&#13;
template &lt;typename T&gt; void call_foo(T &amp;&amp; t) {&#13;
    foo(std::forward&lt;T&gt;(t));&#13;
}&#13;
```&#13;
&#13;
如何实现的？&#13;
&#13;
```cpp&#13;
template &lt;class _Tp&gt;&#13;
_LIBCPP_NODISCARD_EXT inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR _Tp&amp;&amp;&#13;
forward(_LIBCPP_LIFETIMEBOUND __libcpp_remove_reference_t&lt;_Tp&gt;&amp; __t) _NOEXCEPT {&#13;
  return static_cast&lt;_Tp&amp;&amp;&gt;(__t);&#13;
}&#13;
&#13;
template &lt;class _Tp&gt;&#13;
_LIBCPP_NODISCARD_EXT inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR _Tp&amp;&amp;&#13;
forward(_LIBCPP_LIFETIMEBOUND __libcpp_remove_reference_t&lt;_Tp&gt;&amp;&amp; __t) _NOEXCEPT {&#13;
  static_assert(!is_lvalue_reference&lt;_Tp&gt;::value, "cannot forward an rvalue as an lvalue");&#13;
  return static_cast&lt;_Tp&amp;&amp;&gt;(__t);&#13;
}&#13;
```&#13;
&#13;
- Tp 是左值， `static_cast&lt;_Tp&amp;&amp;&gt;(__t)` 后是 T&amp; &amp;&amp;，按照引用折叠规则，`T&amp; &amp;&amp; -&gt; T&amp;`, Tp是左值 &#13;
- Tp 是右值， `static_cast&lt;_Tp&amp;&amp;&gt;(__t)` 后是 T&amp;&amp; &amp;&amp;，按照引用折叠规则，`T&amp;&amp; &amp;&amp; -&gt; T&amp;&amp;`, Tp是右值 。</description><guid isPermaLink="true">http://0x1042.github.io/post/yi-%E3%80%81c%2B%2B-zhong-de-zhi-lei-xing.html</guid><pubDate>Sat, 11 Nov 2023 08:48:15 +0000</pubDate></item><item><title>struct 使用生命周期标注</title><link>http://0x1042.github.io/post/struct%20-shi-yong-sheng-ming-zhou-qi-biao-zhu.html</link><description>```rust&#13;
#[derive(Debug)]&#13;
struct Sheep&lt;'c, 'd&gt; {&#13;
    age: &amp;'c u32,&#13;
    name: &amp;'d str,&#13;
}&#13;
&#13;
impl&lt;'c, 'd&gt; Sheep&lt;'c, 'd&gt; {&#13;
    /// Returns the get age of this [`Sheep`].&#13;
    pub fn get_age(&amp;self) -&gt; u32 {&#13;
        *self.age&#13;
    }&#13;
&#13;
    /// Returns the get name of this [`Sheep`].&#13;
    pub fn get_name(&amp;self) -&gt; String {&#13;
        self.name.to_owned()&#13;
    }&#13;
}&#13;
&#13;
#[cfg(test)]&#13;
mod tests {&#13;
    use super::Sheep;&#13;
    #[test]&#13;
    fn test_lt() {&#13;
        let age = 5;&#13;
        let name = "dollor";&#13;
&#13;
        let sheep = Sheep {&#13;
            age: &amp;age,&#13;
            name: name,&#13;
        };&#13;
&#13;
        println!("name is {:?}", sheep.get_name());&#13;
        println!("age is {:?}", sheep.get_age());&#13;
&#13;
        println!("sheep :{:?}", sheep);&#13;
    }&#13;
}&#13;
```。</description><guid isPermaLink="true">http://0x1042.github.io/post/struct%20-shi-yong-sheng-ming-zhou-qi-biao-zhu.html</guid><pubDate>Wed, 01 Nov 2023 16:55:48 +0000</pubDate></item><item><title>golang中protobuf 反序列化性能优化</title><link>http://0x1042.github.io/post/golang-zhong-protobuf%20-fan-xu-lie-hua-xing-neng-you-hua.html</link><description># 背景&#13;
&#13;
线上有一些公共使用的超大`protobuf`，部分单**message的field大于10000**。</description><guid isPermaLink="true">http://0x1042.github.io/post/golang-zhong-protobuf%20-fan-xu-lie-hua-xing-neng-you-hua.html</guid><pubDate>Sat, 28 Oct 2023 09:07:59 +0000</pubDate></item><item><title>c++中实现golang中的defer功能</title><link>http://0x1042.github.io/post/c%2B%2B-zhong-shi-xian-golang-zhong-de-defer-gong-neng.html</link><description># 使用`folly`&#13;
&#13;
```c++&#13;
#include &lt;folly/ScopeGuard.h&gt;&#13;
&#13;
auto main() -&gt; int {&#13;
    std::string msg = "exit...";&#13;
&#13;
    auto guard1 = folly::makeGuard([&amp;] { std::cerr &lt;&lt; "from folly::makeGuard:" &lt;&lt; msg &lt;&lt; '\n'; });&#13;
&#13;
    std::cout &lt;&lt; "Hello, World!" &lt;&lt; '\n';&#13;
    return 0;&#13;
}&#13;
&#13;
```&#13;
&#13;
# 自定义实现&#13;
&#13;
```c++&#13;
template &lt;typename Lambda&gt; &#13;
struct Defer : Lambda {&#13;
    ~Defer() { Lambda::operator()(); }&#13;
};&#13;
&#13;
template &lt;typename Lambda&gt; &#13;
Defer(Lambda) -&gt; Defer&lt;Lambda&gt;;&#13;
&#13;
auto main() -&gt; int {&#13;
    std::string msg = "exit...";&#13;
&#13;
    Defer guard{[&amp;] { std::cerr &lt;&lt; msg &lt;&lt; '\n'; }};&#13;
&#13;
    std::cout &lt;&lt; "Hello, World!" &lt;&lt; '\n';&#13;
    return 0;&#13;
}&#13;
```&#13;
。</description><guid isPermaLink="true">http://0x1042.github.io/post/c%2B%2B-zhong-shi-xian-golang-zhong-de-defer-gong-neng.html</guid><pubDate>Wed, 25 Oct 2023 15:57:21 +0000</pubDate></item></channel></rss>